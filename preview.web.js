/*! For license information please see preview.web.js.LICENSE.txt */
(()=>{var __webpack_modules__={34892:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.createBaseCjsModuleSystem=void 0;const global_this_js_1=__webpack_require__(74124),falseModule={get exports(){return{}},filename:"",id:"",children:[]};function createBaseCjsModuleSystem(options){const{resolveFrom,dirname,readFileSync,globals={},loadModuleHook}=options,requireCache=new Map,load=loadModuleHook?loadModuleHook(loadModule):loadModule;return{requireModule(e){var n;return!1===e?{}:(null!==(n=requireCache.get(e))&&void 0!==n?n:load(e)).exports},requireFrom:(e,n)=>loadFrom(e,n).exports,resolveFrom,requireCache,globals};function resolveThrow(e,n,t){const r=resolveFrom(e,n,t);if(void 0===r)throw new Error(`Cannot resolve "${n}" in ${t||e}`);return r}function loadFrom(e,n,t){var r;const o=requireCache.get(n);if(o)return o;const i=resolveThrow(e,n,t);return!1===i?falseModule:null!==(r=requireCache.get(i))&&void 0!==r?r:load(i)}function loadModule(filePath){const newModule={exports:{},filename:filePath,id:filePath,children:[]},contextPath=dirname(filePath),fileContents=readFileSync(filePath);if(filePath.endsWith(".json"))return newModule.exports=JSON.parse(fileContents),requireCache.set(filePath,newModule),newModule;const localRequire=e=>{const n=loadFrom(contextPath,e,filePath);return n===falseModule||newModule.children.includes(n)||newModule.children.push(n),n.exports};localRequire.resolve=e=>resolveThrow(contextPath,e,filePath);const moduleBuiltins={module:newModule,exports:newModule.exports,__filename:filePath,__dirname:contextPath,require:localRequire},injectedGlobals={global:global_this_js_1.envGlobal,...globals},fnArgs=Object.keys(moduleBuiltins).join(", "),globalsArgs=Object.keys(injectedGlobals).join(", "),moduleSource=`${fileContents}\n//# sourceURL=${filePath}\n`,globalFn=eval(`(function (${globalsArgs}){ return (function (${fnArgs}){${moduleSource}}); })`);requireCache.set(filePath,newModule);try{const e=globalFn(...Object.values(injectedGlobals));e(...Object.values(moduleBuiltins))}catch(e){throw requireCache.delete(filePath),e instanceof Error&&!e.filePath&&(e.filePath=filePath),e}return newModule}}exports.createBaseCjsModuleSystem=createBaseCjsModuleSystem},24096:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.createCjsModuleSystem=void 0;const r=t(26315),o=t(34892);n.createCjsModuleSystem=function(e){const{fs:n,globals:t}=e,{dirname:i,readFileSync:s}=n,{resolver:a=(0,r.createRequestResolver)({fs:n}),loadModuleHook:c}=e;return(0,o.createBaseCjsModuleSystem)({resolveFrom:(e,n,t)=>a(e,n,t).resolvedFile,readFileSync:e=>s(e,"utf8"),dirname:i,globals:t,loadModuleHook:c})}},74124:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.envGlobal=void 0,n.envGlobal="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:void 0!==t.g?t.g:void 0},96435:function(e,n,t){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,n,t,r){void 0===r&&(r=t);var o=Object.getOwnPropertyDescriptor(n,t);o&&!("get"in o?!n.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return n[t]}}),Object.defineProperty(e,r,o)}:function(e,n,t,r){void 0===r&&(r=t),e[r]=n[t]}),o=this&&this.__exportStar||function(e,n){for(var t in e)"default"===t||Object.prototype.hasOwnProperty.call(n,t)||r(n,e,t)};Object.defineProperty(n,"__esModule",{value:!0}),o(t(34892),n),o(t(24096),n),o(t(8246),n),o(t(66530),n)},66530:(e,n)=>{"use strict";function*t(e,n,r=new Set){if(r.has(e))return;r.add(e);const o=n.get(e);if(o){yield o;for(const[e,i]of n)i.children.includes(o)&&(yield*t(e,n,r))}}Object.defineProperty(n,"__esModule",{value:!0}),n.getModulesTree=n.invalidateModule=void 0,n.invalidateModule=(e,n)=>{for(const{filename:r}of t(e,n))n.delete(r)},n.getModulesTree=t},8246:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0})},73654:e=>{const n=65,t=97,r=90,o=122,i=46,s=47,a=92,c=58,l={cwd:function(){return"/"},env:{}};function d(e){const n=typeof e;return"object"===n&&null===e?"null":n}function u(e,n){if("string"!=typeof e)throw new TypeError(`[ERR_INVALID_ARG_TYPE]: The "${n}" argument must be of type string. Received ${d(e)}`)}function p(e){return e===s||e===a}function h(e){return e===s}function f(e){return e>=n&&e<=r||e>=t&&e<=o}function m(e,n,t,r){let o="",a=0,c=-1,l=0,d=0;for(let u=0;u<=e.length;++u){if(u<e.length)d=e.charCodeAt(u);else{if(r(d))break;d=s}if(r(d)){if(c===u-1||1===l);else if(2===l){if(o.length<2||2!==a||o.charCodeAt(o.length-1)!==i||o.charCodeAt(o.length-2)!==i){if(o.length>2){const e=o.lastIndexOf(t);-1===e?(o="",a=0):(o=o.slice(0,e),a=o.length-1-o.lastIndexOf(t)),c=u,l=0;continue}if(0!==o.length){o="",a=0,c=u,l=0;continue}}n&&(o+=o.length>0?`${t}..`:"..",a=2)}else o.length>0?o+=`${t}${e.slice(c+1,u)}`:o=e.slice(c+1,u),a=u-c-1;c=u,l=0}else d===i&&-1!==l?++l:l=-1}return o}function g(e,n){if(null===n||"object"!=typeof n)throw new TypeError(`[ERR_INVALID_ARG_TYPE]: The "pathObject" argument must be of type object. Received ${d(n)}`);const t=n.dir||n.root,r=n.base||`${n.name||""}${n.ext||""}`;return t?t===n.root?`${t}${r}`:`${t}${e}${r}`:r}const y={resolve(...e){let n="",t="",r=!1;for(let o=e.length-1;o>=-1;o--){let i;if(o>=0){if(i=e[o],u(i,"path"),0===i.length)continue}else 0===n.length?i=l.cwd():(i=l.env[`=${n}`]||l.cwd(),(void 0===i||i.slice(0,2).toLowerCase()!==n.toLowerCase()&&i.charCodeAt(2)===a)&&(i=`${n}\\`));const s=i.length;let d=0,h="",m=!1;const g=i.charCodeAt(0);if(1===s)p(g)&&(d=1,m=!0);else if(p(g))if(m=!0,p(i.charCodeAt(1))){let e=2,n=e;for(;e<s&&!p(i.charCodeAt(e));)e++;if(e<s&&e!==n){const t=i.slice(n,e);for(n=e;e<s&&p(i.charCodeAt(e));)e++;if(e<s&&e!==n){for(n=e;e<s&&!p(i.charCodeAt(e));)e++;e!==s&&e===n||(h=`\\\\${t}\\${i.slice(n,e)}`,d=e)}}}else d=1;else f(g)&&i.charCodeAt(1)===c&&(h=i.slice(0,2),d=2,s>2&&p(i.charCodeAt(2))&&(m=!0,d=3));if(h.length>0)if(n.length>0){if(h.toLowerCase()!==n.toLowerCase())continue}else n=h;if(r){if(n.length>0)break}else if(t=`${i.slice(d)}\\${t}`,r=m,m&&n.length>0)break}return t=m(t,!r,"\\",p),r?`${n}\\${t}`:`${n}${t}`||"."},normalize(e){u(e,"path");const n=e.length;if(0===n)return".";let t,r=0,o=!1;const i=e.charCodeAt(0);if(1===n)return h(i)?"\\":e;if(p(i))if(o=!0,p(e.charCodeAt(1))){let o=2,i=o;for(;o<n&&!p(e.charCodeAt(o));)o++;if(o<n&&o!==i){const s=e.slice(i,o);for(i=o;o<n&&p(e.charCodeAt(o));)o++;if(o<n&&o!==i){for(i=o;o<n&&!p(e.charCodeAt(o));)o++;if(o===n)return`\\\\${s}\\${e.slice(i)}\\`;o!==i&&(t=`\\\\${s}\\${e.slice(i,o)}`,r=o)}}}else r=1;else f(i)&&e.charCodeAt(1)===c&&(t=e.slice(0,2),r=2,n>2&&p(e.charCodeAt(2))&&(o=!0,r=3));let s=r<n?m(e.slice(r),!o,"\\",p):"";return 0!==s.length||o||(s="."),s.length>0&&p(e.charCodeAt(n-1))&&(s+="\\"),void 0===t?o?`\\${s}`:s:o?`${t}\\${s}`:`${t}${s}`},isAbsolute(e){u(e,"path");const n=e.length;if(0===n)return!1;const t=e.charCodeAt(0);return p(t)||n>2&&f(t)&&e.charCodeAt(1)===c&&p(e.charCodeAt(2))},join(...e){if(0===e.length)return".";let n,t;for(let r=0;r<e.length;++r){const o=e[r];u(o,"path"),o.length>0&&(void 0===n?n=t=o:n+=`\\${o}`)}if(void 0===n)return".";let r=!0,o=0;if(p(t.charCodeAt(0))){++o;const e=t.length;e>1&&p(t.charCodeAt(1))&&(++o,e>2&&(p(t.charCodeAt(2))?++o:r=!1))}if(r){for(;o<n.length&&p(n.charCodeAt(o));)o++;o>=2&&(n=`\\${n.slice(o)}`)}return y.normalize(n)},relative(e,n){if(u(e,"from"),u(n,"to"),e===n)return"";const t=y.resolve(e),r=y.resolve(n);if(t===r)return"";if((e=t.toLowerCase())===(n=r.toLowerCase()))return"";let o=0;for(;o<e.length&&e.charCodeAt(o)===a;)o++;let i=e.length;for(;i-1>o&&e.charCodeAt(i-1)===a;)i--;const s=i-o;let c=0;for(;c<n.length&&n.charCodeAt(c)===a;)c++;let l=n.length;for(;l-1>c&&n.charCodeAt(l-1)===a;)l--;const d=l-c,p=s<d?s:d;let h=-1,f=0;for(;f<p;f++){const t=e.charCodeAt(o+f);if(t!==n.charCodeAt(c+f))break;t===a&&(h=f)}if(f!==p){if(-1===h)return r}else{if(d>p){if(n.charCodeAt(c+f)===a)return r.slice(c+f+1);if(2===f)return r.slice(c+f)}s>p&&(e.charCodeAt(o+f)===a?h=f:2===f&&(h=3)),-1===h&&(h=0)}let m="";for(f=o+h+1;f<=i;++f)f!==i&&e.charCodeAt(f)!==a||(m+=0===m.length?"..":"\\..");return c+=h,m.length>0?`${m}${r.slice(c,l)}`:(r.charCodeAt(c)===a&&++c,r.slice(c,l))},toNamespacedPath(e){if("string"!=typeof e)return e;if(0===e.length)return"";const n=y.resolve(e);if(n.length<=2)return e;if(n.charCodeAt(0)===a){if(n.charCodeAt(1)===a){const e=n.charCodeAt(2);if(63!==e&&e!==i)return`\\\\?\\UNC\\${n.slice(2)}`}}else if(f(n.charCodeAt(0))&&n.charCodeAt(1)===c&&n.charCodeAt(2)===a)return`\\\\?\\${n}`;return e},dirname(e){u(e,"path");const n=e.length;if(0===n)return".";let t=-1,r=0;const o=e.charCodeAt(0);if(1===n)return p(o)?e:".";if(p(o)){if(t=r=1,p(e.charCodeAt(1))){let o=2,i=o;for(;o<n&&!p(e.charCodeAt(o));)o++;if(o<n&&o!==i){for(i=o;o<n&&p(e.charCodeAt(o));)o++;if(o<n&&o!==i){for(i=o;o<n&&!p(e.charCodeAt(o));)o++;if(o===n)return e;o!==i&&(t=r=o+1)}}}}else f(o)&&e.charCodeAt(1)===c&&(t=n>2&&p(e.charCodeAt(2))?3:2,r=t);let i=-1,s=!0;for(let t=n-1;t>=r;--t)if(p(e.charCodeAt(t))){if(!s){i=t;break}}else s=!1;if(-1===i){if(-1===t)return".";i=t}return e.slice(0,i)},basename(e,n){void 0!==n&&u(n,"ext"),u(e,"path");let t=0,r=-1,o=!0;if(e.length>=2&&f(e.charCodeAt(0))&&e.charCodeAt(1)===c&&(t=2),void 0!==n&&n.length>0&&n.length<=e.length){if(n===e)return"";let i=n.length-1,s=-1;for(let a=e.length-1;a>=t;--a){const c=e.charCodeAt(a);if(p(c)){if(!o){t=a+1;break}}else-1===s&&(o=!1,s=a+1),i>=0&&(c===n.charCodeAt(i)?-1==--i&&(r=a):(i=-1,r=s))}return t===r?r=s:-1===r&&(r=e.length),e.slice(t,r)}for(let n=e.length-1;n>=t;--n)if(p(e.charCodeAt(n))){if(!o){t=n+1;break}}else-1===r&&(o=!1,r=n+1);return-1===r?"":e.slice(t,r)},extname(e){u(e,"path");let n=0,t=-1,r=0,o=-1,s=!0,a=0;e.length>=2&&e.charCodeAt(1)===c&&f(e.charCodeAt(0))&&(n=r=2);for(let c=e.length-1;c>=n;--c){const n=e.charCodeAt(c);if(p(n)){if(!s){r=c+1;break}}else-1===o&&(s=!1,o=c+1),n===i?-1===t?t=c:1!==a&&(a=1):-1!==t&&(a=-1)}return-1===t||-1===o||0===a||1===a&&t===o-1&&t===r+1?"":e.slice(t,o)},format:g.bind(null,"\\"),parse(e){u(e,"path");const n={root:"",dir:"",base:"",ext:"",name:""};if(0===e.length)return n;const t=e.length;let r=0,o=e.charCodeAt(0);if(1===t)return p(o)?(n.root=n.dir=e,n):(n.base=n.name=e,n);if(p(o)){if(r=1,p(e.charCodeAt(1))){let n=2,o=n;for(;n<t&&!p(e.charCodeAt(n));)n++;if(n<t&&n!==o){for(o=n;n<t&&p(e.charCodeAt(n));)n++;if(n<t&&n!==o){for(o=n;n<t&&!p(e.charCodeAt(n));)n++;n===t?r=n:n!==o&&(r=n+1)}}}}else if(f(o)&&e.charCodeAt(1)===c){if(t<=2)return n.root=n.dir=e,n;if(r=2,p(e.charCodeAt(2))){if(3===t)return n.root=n.dir=e,n;r=3}}r>0&&(n.root=e.slice(0,r));let s=-1,a=r,l=-1,d=!0,h=e.length-1,m=0;for(;h>=r;--h)if(o=e.charCodeAt(h),p(o)){if(!d){a=h+1;break}}else-1===l&&(d=!1,l=h+1),o===i?-1===s?s=h:1!==m&&(m=1):-1!==s&&(m=-1);return-1!==l&&(-1===s||0===m||1===m&&s===l-1&&s===a+1?n.base=n.name=e.slice(a,l):(n.name=e.slice(a,s),n.base=e.slice(a,l),n.ext=e.slice(s,l))),n.dir=a>0&&a!==r?e.slice(0,a-1):n.root,n},sep:"\\",delimiter:";",win32:null,posix:null},_={resolve(...e){let n="",t=!1;for(let r=e.length-1;r>=-1&&!t;r--){const o=r>=0?e[r]:l.cwd();u(o,"path"),0!==o.length&&(n=`${o}/${n}`,t=o.charCodeAt(0)===s)}return n=m(n,!t,"/",h),t?`/${n}`:n.length>0?n:"."},normalize(e){if(u(e,"path"),0===e.length)return".";const n=e.charCodeAt(0)===s,t=e.charCodeAt(e.length-1)===s;return 0===(e=m(e,!n,"/",h)).length?n?"/":t?"./":".":(t&&(e+="/"),n?`/${e}`:e)},isAbsolute:e=>(u(e,"path"),e.length>0&&e.charCodeAt(0)===s),join(...e){if(0===e.length)return".";let n;for(let t=0;t<e.length;++t){const r=e[t];u(r,"path"),r.length>0&&(void 0===n?n=r:n+=`/${r}`)}return void 0===n?".":_.normalize(n)},relative(e,n){if(u(e,"from"),u(n,"to"),e===n)return"";if((e=_.resolve(e))===(n=_.resolve(n)))return"";const t=e.length,r=t-1,o=n.length-1,i=r<o?r:o;let a=-1,c=0;for(;c<i;c++){const t=e.charCodeAt(1+c);if(t!==n.charCodeAt(1+c))break;t===s&&(a=c)}if(c===i)if(o>i){if(n.charCodeAt(1+c)===s)return n.slice(1+c+1);if(0===c)return n.slice(1+c)}else r>i&&(e.charCodeAt(1+c)===s?a=c:0===c&&(a=0));let l="";for(c=1+a+1;c<=t;++c)c!==t&&e.charCodeAt(c)!==s||(l+=0===l.length?"..":"/..");return`${l}${n.slice(1+a)}`},toNamespacedPath:e=>e,dirname(e){if(u(e,"path"),0===e.length)return".";const n=e.charCodeAt(0)===s;let t=-1,r=!0;for(let n=e.length-1;n>=1;--n)if(e.charCodeAt(n)===s){if(!r){t=n;break}}else r=!1;return-1===t?n?"/":".":n&&1===t?"//":e.slice(0,t)},basename(e,n){void 0!==n&&u(n,"ext"),u(e,"path");let t=0,r=-1,o=!0;if(void 0!==n&&n.length>0&&n.length<=e.length){if(n===e)return"";let i=n.length-1,a=-1;for(let c=e.length-1;c>=0;--c){const l=e.charCodeAt(c);if(l===s){if(!o){t=c+1;break}}else-1===a&&(o=!1,a=c+1),i>=0&&(l===n.charCodeAt(i)?-1==--i&&(r=c):(i=-1,r=a))}return t===r?r=a:-1===r&&(r=e.length),e.slice(t,r)}for(let n=e.length-1;n>=0;--n)if(e.charCodeAt(n)===s){if(!o){t=n+1;break}}else-1===r&&(o=!1,r=n+1);return-1===r?"":e.slice(t,r)},extname(e){u(e,"path");let n=-1,t=0,r=-1,o=!0,a=0;for(let c=e.length-1;c>=0;--c){const l=e.charCodeAt(c);if(l!==s)-1===r&&(o=!1,r=c+1),l===i?-1===n?n=c:1!==a&&(a=1):-1!==n&&(a=-1);else if(!o){t=c+1;break}}return-1===n||-1===r||0===a||1===a&&n===r-1&&n===t+1?"":e.slice(n,r)},format:g.bind(null,"/"),parse(e){u(e,"path");const n={root:"",dir:"",base:"",ext:"",name:""};if(0===e.length)return n;const t=e.charCodeAt(0)===s;let r;t?(n.root="/",r=1):r=0;let o=-1,a=0,c=-1,l=!0,d=e.length-1,p=0;for(;d>=r;--d){const n=e.charCodeAt(d);if(n!==s)-1===c&&(l=!1,c=d+1),n===i?-1===o?o=d:1!==p&&(p=1):-1!==o&&(p=-1);else if(!l){a=d+1;break}}if(-1!==c){const r=0===a&&t?1:a;-1===o||0===p||1===p&&o===c-1&&o===a+1?n.base=n.name=e.slice(r,c):(n.name=e.slice(r,o),n.base=e.slice(r,c),n.ext=e.slice(o,c))}return a>0?n.dir=e.slice(0,a-1):t&&(n.dir="/"),n},sep:"/",delimiter:":",win32:null,posix:null};_.win32=y.win32=y,_.posix=y.posix=_,y._makeLong=y.toNamespacedPath,_._makeLong=_.toNamespacedPath,e.exports="win32"===l.platform?y:_},51607:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.createDependencyResolver=void 0;const{hasOwnProperty:t}=Object.prototype;n.createDependencyResolver=function({extractRequests:e,resolveRequest:n}){return(r,o)=>{const i=Object.create(null),s=Array.isArray(r)?[...r]:[r];for(;s.length>0;){const r=s.shift();if(i[r])continue;const a=Object.create(null);i[r]=a;const c=e(r);for(const e of c){if(t.call(a,e))continue;const i=n(r,e);a[e]=i,o&&void 0!==i&&!1!==i&&s.push(i)}}return i}}},26315:function(e,n,t){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,n,t,r){void 0===r&&(r=t);var o=Object.getOwnPropertyDescriptor(n,t);o&&!("get"in o?!n.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return n[t]}}),Object.defineProperty(e,r,o)}:function(e,n,t,r){void 0===r&&(r=t),e[r]=n[t]}),o=this&&this.__exportStar||function(e,n){for(var t in e)"default"===t||Object.prototype.hasOwnProperty.call(n,t)||r(n,e,t)};Object.defineProperty(n,"__esModule",{value:!0}),o(t(51607),n),o(t(48522),n),o(t(20096),n)},48522:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.createRequestRemapper=n.createRequestResolver=void 0;const t="browser",r=["node_modules"],o=[".js",".json"],i=e=>"."===e||".."===e||e.startsWith("./")||e.startsWith("../"),s={throwIfNoEntry:!1};function a(e){const n=new Map;let t=!1;for(const[r,o]of Object.entries(e)){let e=r,i=o;r.endsWith("/*")&&(t=!0,e={prefix:r.slice(0,-1)},"string"==typeof o&&o.endsWith("/*")&&(i={prefix:o.slice(0,-1)})),n.set(e,i)}return t?e=>function(e,n){for(const[t,r]of e){const e=typeof t;if("string"===e){if(n===t)return r}else if("object"===e){const{prefix:e}=t;if(n.startsWith(e)&&n.length>e.length)return"object"==typeof r?r.prefix+n.slice(e.length):r}}}(n,e):e=>n.get(e)}n.createRequestResolver=function(e){const{fs:{statSync:n,readFileSync:c,realpathSync:l,dirname:d,join:u,resolve:p,isAbsolute:h},packageRoots:f=r,extensions:m=o,target:g=t,resolvedPacakgesCache:y=new Map,alias:_={},fallback:b={}}=e,v=function(e,n=new Map){return t=>{if(n.has(t))return n.get(t);{const r=e(t);return n.set(t,r),r}}}((function(e){const n=u(e,"package.json"),t=function(e){const{stackTraceLimit:n}=Error;try{return Error.stackTraceLimit=0,JSON.parse(c(e,"utf8"))}catch{return}finally{Error.stackTraceLimit=n}}(n);if("object"!=typeof t||null===t)return;const r=function({main:e,browser:n}){return"browser"===g&&"string"==typeof n?n:"string"==typeof e?e:void 0}(t),{browser:o}=t;let s;if("browser"===g&&"object"==typeof o&&null!==o){s=Object.create(null);for(const[n,t]of Object.entries(o)){const r=i(n)?O(u(e,n)):n;if(r&&void 0!==t){const n=R(e,t);void 0!==n&&(s[r]=n)}}}return{filePath:n,directoryPath:e,mainPath:r,browserMappings:s}}),y),w=a(_),E=a(b);return function(e,n){var t,r;const o=new Set;for(const i of function*(e,n,t){var r;const o=w(n);let i=!1;if(void 0!==o&&(i=!0,yield o),!i&&"browser"===g){const o=I(e);if(o){t.add(o.filePath);const e=null===(r=o.browserMappings)||void 0===r?void 0:r[n];void 0!==e&&(i=!0,yield e)}}i||(yield n);const s=E(n);void 0!==s&&(yield s)}(e,n,o)){if(!1===i)return{resolvedFile:i,visitedPaths:o};for(const n of S(e,i)){if(o.add(n),!(null===(t=P(n))||void 0===t?void 0:t.isFile()))continue;if("browser"===g){const e=I(d(n));if(e){o.add(e.filePath);const t=null===(r=e.browserMappings)||void 0===r?void 0:r[n];if(void 0!==t)return!1!==t&&o.add(t),{resolvedFile:t,originalFilePath:n,visitedPaths:o}}}const e=D(n);return o.add(e),{resolvedFile:e,visitedPaths:o}}}return{resolvedFile:void 0,visitedPaths:o}};function*S(e,n){if(i(n)||h(n)){const t=p(e,n);yield*T(t),yield*k(t)}else yield*function*(e,n){var t;for(const r of function*(e){for(const n of f)for(const t of M(e))yield u(t,n)}(e)){if(!(null===(t=P(r))||void 0===t?void 0:t.isDirectory()))continue;const e=u(r,n);yield*T(e),yield*k(e)}}(e,n)}function*T(e){yield e;for(const n of m)yield e+n}function*C(e){yield*T(e),yield*T(u(e,"index"))}function*k(e){var n;if(!(null===(n=P(e))||void 0===n?void 0:n.isDirectory()))return;const t=v(e),r=null==t?void 0:t.mainPath;void 0!==r?yield*C(u(e,r)):yield*T(u(e,"index"))}function I(e){for(const n of M(e)){const e=v(n);if(e)return e}}function R(e,n){return!1===n?n:"string"==typeof n?i(n)?O(u(e,n)):n:void 0}function O(e){var n;for(const t of C(e))if(null===(n=P(t))||void 0===n?void 0:n.isFile())return D(t)}function P(e){const{stackTraceLimit:t}=Error;try{return Error.stackTraceLimit=0,n(e,s)}catch{return}finally{Error.stackTraceLimit=t}}function D(e){const{stackTraceLimit:n}=Error;try{return Error.stackTraceLimit=0,l(e)}catch{return e}finally{Error.stackTraceLimit=n}}function*M(e){let n;for(;n!==e;)yield e,n=e,e=d(e)}},n.createRequestRemapper=a},20096:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0})},68834:(e,n,t)=>{"use strict";t.r(n),t.d(n,{classes:()=>o,containers:()=>a,cssStates:()=>d,keyframes:()=>i,layers:()=>s,namespace:()=>r,st:()=>p,stVars:()=>c,style:()=>u,vars:()=>l});const r="o169",o={root:"s476",icon:"s477"},i={},s={},a={},c={},l={},d=t.stc.bind(null,r),u=t.sts.bind(null,r),p=u},81948:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.declareComEmitter=n.Communication=void 0;const r=t(45522),o=t(55329),i=t(78558),s=t(31035),a=t(53427),c=t(53433),l=t(24681),d=t(33808),u=t(72880),p=t(48074);n.Communication=class{constructor(e,n,t={},i={},s=!1,a){this.topology=t,this.resolvedContexts=i,this.isServer=s,this.idsCounter=new o.MultiCounter,this.disposing=!1,this.callbackTimeout=3e5,this.slowThreshold=5e3,this.callbacks={},this.pendingEnvs=new c.SetMultiMap,this.pendingMessages=new c.SetMultiMap,this.handlers=new Map,this.eventDispatchers={},this.apis={},this.apisOverrides={},this.readyEnvs=new Set,this.environments={},this.messageHandlers=new WeakMap,this.disposeListeners=new Set,this.callbackToEnvMapping=new Map,this.handleEvent=({data:e})=>{this.handleMessage(e).catch(r.reportError)},this.options={warnOnSlow:!1,publicPath:"",connectedEnvironments:{},...a},this.rootEnvId=n,this.rootEnvName=n.split("/")[0],this.registerMessageHandler(e),this.registerEnv(n,e),this.environments["*"]={id:n,host:e},this.post(this.getPostEndpoint(e),{type:"ready",from:n,to:"*",origin:n,forwardingChain:[]});for(const[e,n]of Object.entries(this.options.connectedEnvironments))n.registerMessageHandler&&this.registerMessageHandler(n.host),this.environments[e]=n}registerEnv(e,n){if(this.environments[e])throw new Error((0,r.DUPLICATE_REGISTER)(e,"Environment"));this.environments[e]={id:e,host:n}}registerAPI({id:e},n){if(this.apis[e])throw new Error((0,r.DUPLICATE_REGISTER)(e,"RemoteService"));return this.apis[e]=n,this.applyApiDirectives(e,n),n}getEnvironmentContext(e){return this.resolvedContexts[e.env]}getEnvironmentInstanceId(e,n){return"single"===n?e:this.generateEnvInstanceID(e)}getPublicPath(){return this.options.publicPath}setTopology(e,n){this.topology[e]=n}subscribeToEnvironmentDispose(e){this.disposeListeners.add(e)}unsubscribeToEnvironmentDispose(e){this.disposeListeners.delete(e)}apiProxy(e,{id:n},t={}){return new Proxy(Object.create(null),{get:(r,o)=>{if("string"==typeof o){let i=r[o];return i||(i=async(...r)=>this.callMethod((await e).id,n,o,r,this.rootEnvId,t,[]),r[o]=i),i}}})}registerMessageHandler(e){var n;const t=null!==(n=e.parent)&&void 0!==n?n:e,r=({data:e})=>{(0,u.isMessage)(e)&&(this.environments[e.from]||this.registerEnv(e.from,t),this.environments[e.origin]||this.registerEnv(e.origin,t),this.handleEvent({data:e}))};e.addEventListener("message",r,!0),this.messageHandlers.set(e,r)}removeMessageHandler(e){const n=this.messageHandlers.get(e);n&&e.removeEventListener("message",n,!0)}generateEnvInstanceID(e){return this.idsCounter.next(`${e}/`)}callMethod(e,n,t,r,o,i,s){return new Promise(((a,c)=>{var l,d;const u=(null===(l=i[t])||void 0===l?void 0:l.emitOnly)?void 0:this.idsCounter.next("c");if(this.isListenCall(r)||(null===(d=i[t])||void 0===d?void 0:d.removeAllListeners))this.addOrRemoveListener(e,n,t,u,o,i,r[0],s,a,c);else{const i={to:e,from:this.rootEnvId,type:"call",data:{api:n,method:t,args:r},callbackId:u,origin:o,forwardingChain:s};this.callWithCallback(e,i,u,a,c)}}))}async handleMessage(e){if("dispose"===e.type&&"*"===e.to)return void this.clearEnvironment(e.origin,this.rootEnvId);const n=this.environments[e.to];if(n)if(n.id===this.rootEnvId)switch(e.type){case"call":await this.handleCall(e);break;case"callback":this.handleCallback(e);break;case"event":this.handleEventMessage(e);break;case"listen":await this.handleListen(e);break;case"unlisten":await this.handleUnListen(e);break;case"ready":this.handleReady(e);break;case"dispose":e.from!==this.rootEnvId&&this.clearEnvironment(e.origin,e.from)}else await this.forwardMessage(e,n);else this.unhandledMessage(e)}dispose(){this.disposing=!0;for(const{host:e,id:n}of Object.values(this.environments))e instanceof d.WsClientHost&&(e.subscribers.clear(),e.dispose()),this.removeMessageHandler(e),this.locallyClear(n);this.locallyClear(this.rootEnvId),this.disposeListeners.clear();for(const[e,{timerId:n}]of Object.entries(this.callbacks))clearTimeout(n),delete this.callbacks[e]}getEnvironmentId(){return this.rootEnvId}getEnvironmentName(){return this.rootEnvName}getEnvironmentHost(e){var n;return null===(n=this.environments[e])||void 0===n?void 0:n.host}getRegisteredEnvironmentInstances(){return Object.keys(this.environments).filter((e=>"*"!==e))}parseHandlerId(e,n){const[t,r]=e.slice(n.length).split("@");return{api:t,method:r}}reconnectHandler(e,n){return new Promise(((t,r)=>{const o={to:e,from:this.rootEnvId,type:"listen",data:this.parseHandlerId(n,this.createHandlerIdPrefix({from:this.rootEnvId,to:e})),callbackId:this.idsCounter.next("c"),origin:this.rootEnvId,handlerId:n,forwardingChain:[]};this.createCallbackRecord(o,o.callbackId,t,r),this.sendTo(e,o)}))}async reconnectHandlers(e){const n=this.createHandlerIdPrefix({from:this.rootEnvId,to:e});for(const t of this.handlers.keys())t.startsWith(n)&&await this.reconnectHandler(e,t)}createHandlerIdPrefix({from:e,to:n}){return`${e}__${n}_`}applyApiDirectives(e,n){const t=n[s.SERVICE_CONFIG];if(t){this.apisOverrides[e]={};for(const r of Object.keys(t)){const o=t[r](n);o.proxyFunction&&(this.apisOverrides[e][r]=o.proxyFunction)}}}envReady(e){const{promise:n,resolve:t}=(0,p.deferred)();return this.readyEnvs.has(e)?(this.handleReady({from:e}),t()):this.pendingEnvs.add(e,(()=>t())),n}clearEnvironment(e,n=e,t=!0){const r=Object.keys(this.options.connectedEnvironments);if(t&&(this.readyEnvs.has(e)||r.includes(e)))for(const t of[...this.readyEnvs,...r])[e,n,this.rootEnvId].includes(t)||this.sendTo(t,{type:"dispose",from:this.rootEnvId,to:t,origin:e,forwardingChain:[]});this.locallyClear(e)}locallyClear(e){var n;this.readyEnvs.delete(e),this.pendingMessages.deleteKey(e),this.pendingEnvs.deleteKey(e),delete this.environments[e];for(const[t,o]of null!==(n=this.callbackToEnvMapping.entries())&&void 0!==n?n:[])if(o===e&&this.callbacks[t]){const{timerId:n,reject:o}=this.callbacks[t];clearTimeout(n),o(new Error((0,r.ENV_DISCONNECTED)(e))),delete this.callbacks[t],this.callbackToEnvMapping.delete(t)}for(const n of this.disposeListeners)n(e)}async forwardMessage(e,n){const t={from:e.to,to:e.from,callbackId:e.callbackId,origin:e.to,type:"callback",forwardingChain:[this.rootEnvId]};if(e.forwardingChain.indexOf(this.rootEnvId)>-1)this.sendTo(e.from,{...t,error:new Error(`cannot reach environment '${e.to}' from '${e.from}' since it's stuck in circular messaging loop`)});else if(e.forwardingChain=[...e.forwardingChain,this.rootEnvId],"call"===e.type)try{const r=await this.callMethod(n.id,e.data.api,e.data.method,e.data.args,e.origin,{},e.forwardingChain);e.callbackId&&this.sendTo(e.from,{...t,data:r})}catch(n){e.callbackId&&this.sendTo(e.from,{...t,error:(0,a.serializeError)(n)})}else if("callback"===e.type||"dispose"===e.type)if("callback"===e.type&&e.callbackId)if(this.callbacks[e.callbackId]){const{resolve:n,timerId:t}=this.callbacks[e.callbackId];n(e.data),clearTimeout(t)}else this.sendTo(e.to,e);else this.sendTo(e.to,e);else"unlisten"===e.type?await this.forwardUnlisten(e):"listen"===e.type&&await this.forwardListenMessage(e)}async forwardListenMessage(e){const n=this.idsCounter.next("c"),t=await new Promise(((t,r)=>{const o=e.handlerId,i=(...n)=>{this.sendTo(e.from,{to:e.from,from:e.to,type:"event",data:n,handlerId:o,origin:e.from,forwardingChain:[]})};this.eventDispatchers[o]=i,this.addOrRemoveListener(e.to,e.data.api,e.data.method,n,e.origin,{[e.data.method]:{listener:!0}},i,e.forwardingChain,t,r)})),r={to:e.from,type:"callback",callbackId:e.callbackId,from:e.to,origin:e.origin,data:t,forwardingChain:[]};this.sendTo(e.from,r)}apiCall(e,n,t,r){var o;return(null===(o=this.apisOverrides[n])||void 0===o?void 0:o[t])?this.apisOverrides[n][t](e,...r):this.apis[n][t](...r)}unhandledMessage(e){}addOrRemoveListener(e,n,t,r,o,i,s,a,c,l){var d,u,p,h;const f=(null===(d=i[t])||void 0===d?void 0:d.removeAllListeners)||(null===(u=i[t])||void 0===u?void 0:u.removeListener);if(f){const r=this.getHandlerId(e,n,f),l=this.handlers.get(r);if(!l)return void c();if((null===(p=i[t])||void 0===p?void 0:p.removeListener)?l.delete(s):l.clear(),0===l.size){const i={to:e,from:this.rootEnvId,type:"unlisten",data:{api:n,method:t},handlerId:r,origin:o,forwardingChain:a};this.sendTo(e,i),c()}else c()}else{if(!(null===(h=i[t])||void 0===h?void 0:h.listener))throw new Error(`cannot add listener to unconfigured method ${n} ${t}`);{const i=this.handlers.get(this.getHandlerId(e,n,t));if(i&&0!==i.size){if(i.has(s))throw new Error("Cannot add same listener instance twice "+this.getHandlerId(e,n,t));i.add(s),c()}else{const i={to:e,from:this.rootEnvId,type:"listen",data:{api:n,method:t},handlerId:this.createHandlerRecord(e,n,t,s),callbackId:r,origin:o,forwardingChain:a};this.callWithCallback(e,i,r,c,l)}}}}callWithCallback(e,n,t,r,o){t&&this.createCallbackRecord(n,t,r,o),this.sendTo(e,n),t||r()}sendTo(e,n){this.pendingEnvs.get(e)?this.pendingMessages.add(e,(()=>this.post(this.resolveMessageTarget(e),n))):this.post(this.resolveMessageTarget(e),n)}post(e,n){(0,o.isWorkerContext)(e)?e.postMessage(n):e.postMessage(n,"*")}resolveMessageTarget(e){const n=this.environments[e]||this.environments[this.rootEnvId];if(!n)return i.HOST_REMOVED;const{host:t}=n;return n.id!==this.rootEnvId?t:t instanceof l.BaseHost?t.parent||t:this.getPostEndpoint(t)}getPostEndpoint(e){return(0,o.isWindow)(e)?e.opener||e.parent:e}handleEventMessage(e){const n=this.handlers.get(e.handlerId);if(n)for(const t of n)t(...e.data)}handleReady({from:e}){this.readyEnvs.add(e);const n=this.pendingEnvs.get(e);if(n){this.pendingEnvs.deleteKey(e);const t=this.pendingMessages.get(e);if(t){for(const e of t)e();this.pendingMessages.deleteKey(e)}for(const e of n)e()}}async handleUnListen(e){const n=e.handlerId+e.origin,t=this.eventDispatchers[n];if(t){delete this.eventDispatchers[n];const r=await this.apiCall(e.origin,e.data.api,e.data.method,[t]);e.callbackId&&this.sendTo(e.from,{to:e.from,from:this.rootEnvId,type:"callback",data:r,callbackId:e.callbackId,origin:this.rootEnvId,forwardingChain:[]})}}async forwardUnlisten(e){const n=this.idsCounter.next("c"),{method:t,api:r}=this.parseHandlerId(e.handlerId,this.createHandlerIdPrefix(e)),o=await new Promise(((o,i)=>this.addOrRemoveListener(e.to,r,e.data.method,n,e.origin,{[e.data.method]:{removeListener:t}},this.eventDispatchers[e.handlerId],e.forwardingChain,o,i)));delete this.eventDispatchers[e.handlerId],e.callbackId&&this.sendTo(e.from,{to:e.from,from:e.to,type:"callback",data:o,callbackId:e.callbackId,origin:e.to,forwardingChain:[]})}async handleListen(e){try{const n=e.handlerId+e.origin,t=this.eventDispatchers[n]||this.createDispatcher(e.from,e),r=await this.apiCall(e.origin,e.data.api,e.data.method,[t]);e.callbackId&&this.sendTo(e.from,{to:e.from,from:this.rootEnvId,type:"callback",data:r,callbackId:e.callbackId,origin:this.rootEnvId,forwardingChain:[]})}catch(n){this.sendTo(e.from,{to:e.from,from:this.rootEnvId,type:"callback",error:(0,a.serializeError)(n),callbackId:e.callbackId,origin:this.rootEnvId,forwardingChain:[]})}}async handleCall(e){try{const n=await this.apiCall(e.origin,e.data.api,e.data.method,e.data.args);e.callbackId&&this.sendTo(e.from,{to:e.origin,from:this.rootEnvId,type:"callback",data:n,callbackId:e.callbackId,origin:this.rootEnvId,forwardingChain:[]})}catch(n){this.sendTo(e.from,{to:e.from,from:this.rootEnvId,type:"callback",error:(0,a.serializeError)(n),callbackId:e.callbackId,origin:this.rootEnvId,forwardingChain:[]})}}handleCallback(e){const n=e.callbackId?this.callbacks[e.callbackId]:null;if(n&&e.error){const t=Object.assign(new Error,e.error);t.stack=(0,r.REMOTE_CALL_FAILED)(e.from,t.stack),n.reject(t)}else if(n)n.resolve(e.data);else if(e.callbackId)throw new Error((0,r.UNKNOWN_CALLBACK_ID)(h(e)))}createDispatcher(e,n){const t=n.handlerId+n.origin;return this.eventDispatchers[t]=(...t)=>{this.sendTo(e,{to:e,from:this.rootEnvId,type:"event",data:t,handlerId:n.handlerId,origin:this.rootEnvId,forwardingChain:[]})}}isListenCall(e){return"function"==typeof e[0]&&1===e.length}getHandlerId(e,n,t){return`${this.createHandlerIdPrefix({from:this.rootEnvId,to:e})}${n}@${t}`}createHandlerRecord(e,n,t,r){const o=this.getHandlerId(e,n,t),i=this.handlers.get(o);return i||this.subscribeToEnvironmentDispose((n=>{e===n&&this.handlers.delete(o)})),i?i.add(r):this.handlers.set(o,new Set([r])),o}createCallbackRecord(e,n,t,o){if(!this.disposing){this.callbackToEnvMapping.set(n,e.to);const i=e=>{this.callbackToEnvMapping.delete(n),delete this.callbacks[n],clearTimeout(a),t(e)},s=e=>{this.callbackToEnvMapping.delete(n),delete this.callbacks[n],clearTimeout(a),o(e)};this.options.warnOnSlow&&setTimeout((()=>{this.callbacks[n]&&console.error((0,r.CALLBACK_TIMEOUT)(n,this.rootEnvId,h(e)))}),this.slowThreshold);const a=setTimeout((()=>{s(new Error((0,r.CALLBACK_TIMEOUT)(n,this.rootEnvId,h(e))))}),this.callbackTimeout);this.callbacks[n]={timerId:a,resolve:i,reject:s}}}};const h=e=>{if("call"===(e={...e}).type||"callback"===e.type){const{data:n}=e;n&&n.args&&(n.args=void 0)}return e};n.declareComEmitter=function(e,n,t){if("string"!=typeof e)throw"onMethod ref must be a string";return{[e]:{listener:!0},[n]:{removeListener:e},...t?{[t]:{removeAllListeners:e}}:void 0}}},45522:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.reportError=n.MISSING_CONTEXT_FOR_API_PROXY=n.SPAWNED_MORE_THEN_ONCE=n.MISSING_COM_CONTEXT=n.MISSING_FORWARD_FOR_MESSAGE=n.MISSING_ENV=n.CALLBACK_TIMEOUT=n.UNKNOWN_CALLBACK_ID=n.ENV_DISCONNECTED=n.REMOTE_CALL_FAILED=n.GLOBAL_REF=n.DUPLICATE_REGISTER=void 0,n.DUPLICATE_REGISTER=(e,n)=>`Could not register same id ${e} as ${n}`,n.GLOBAL_REF=e=>`Com with id "${e}" is already running.`,n.REMOTE_CALL_FAILED=(e,n)=>`Remote call failed in ${e}${n?`\n${n}`:""}`,n.ENV_DISCONNECTED=e=>`Remote call failed in ${e} - environment disconnected`,n.UNKNOWN_CALLBACK_ID=e=>`Unknown callback id "${e.callbackId}" in message:\n${JSON.stringify(e)}`,n.CALLBACK_TIMEOUT=(e,n,t)=>`Callback timeout "${e}" at ${n} on message:\n${JSON.stringify(t)}`,n.MISSING_ENV=(e,n)=>`Destination environment ${e} is not registered. available environments: [${n.join(", ")}]`,n.MISSING_FORWARD_FOR_MESSAGE=e=>`Not implemented forward for ${e.type}`,n.MISSING_COM_CONTEXT=(e,n)=>`Missing communication context for "${e}" when ${n}`,n.SPAWNED_MORE_THEN_ONCE=e=>`Environment with id ${e} can only spawned once`,n.MISSING_CONTEXT_FOR_API_PROXY=(e,n)=>`Missing ${e} when trying to get remote service api proxy for ${n}`,n.reportError=function(e){console.error(e)}},55329:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.MultiCounter=n.isIframe=n.isWindow=n.isWorkerContext=void 0,n.isWorkerContext=function(e){return"undefined"!=typeof Worker&&e instanceof Worker||"undefined"!=typeof WorkerGlobalScope&&e instanceof WorkerGlobalScope},n.isWindow=function(e){return"undefined"!=typeof Window&&e instanceof Window},n.isIframe=function(e){return"undefined"!=typeof HTMLIFrameElement&&e instanceof HTMLIFrameElement},n.MultiCounter=class{constructor(){this.ids={}}next(e){return this.ids[e]=this.ids[e]||0,`${e}${this.ids[e]++}`}}},24681:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.BaseHost=void 0;class t{constructor(){this.name="base-host",this.parent=void 0,this.handlers=new Map}addEventListener(e,n,t){const r=this.handlers.get(e);r?r.add(n):this.handlers.set(e,new Set([n]))}removeEventListener(e,n,t){const r=this.handlers.get(e);r&&r.delete(n)}postMessage(e){this.emitMessageHandlers(e)}open(){const e=new t;return e.parent=this,e}emitMessageHandlers(e){for(const n of this.handlers.get("message")||[])n({data:e})}}n.BaseHost=t},69976:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.EventEmitterHost=void 0;const r=t(24681);class o extends r.BaseHost{constructor(e){super(),this.host=e,this.host.on("message",(e=>this.emitMessageHandlers(e)))}postMessage(e){this.emitMessageHandlers(e)}}n.EventEmitterHost=o},64673:function(e,n,t){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,n,t,r){void 0===r&&(r=t);var o=Object.getOwnPropertyDescriptor(n,t);o&&!("get"in o?!n.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return n[t]}}),Object.defineProperty(e,r,o)}:function(e,n,t,r){void 0===r&&(r=t),e[r]=n[t]}),o=this&&this.__exportStar||function(e,n){for(var t in e)"default"===t||Object.prototype.hasOwnProperty.call(n,t)||r(n,e,t)};Object.defineProperty(n,"__esModule",{value:!0}),o(t(24681),n),o(t(33808),n),o(t(69976),n)},33808:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.WsClientHost=void 0;const r=t(16580),o=t(24681),i=t(53433),s=t(48074);class a extends o.BaseHost{constructor(e,n){super(),this.subscribers=new i.EventEmitter;const{path:t,...o}=Object.fromEntries(new URL(e).searchParams),{promise:a,resolve:c}=(0,s.deferred)();this.connected=a,this.socketClient=(0,r.io)(e,{transports:["websocket"],forceNew:!0,withCredentials:!0,path:t,query:o,...n}),this.socketClient.on("connect",(()=>{this.socketClient.on("message",(e=>{this.emitMessageHandlers(e)})),c()})),this.socketClient.on("disconnect",(()=>{this.subscribers.emit("disconnect",void 0),this.socketClient.close()})),this.socketClient.on("reconnect",(()=>{this.subscribers.emit("reconnect",void 0)})),this.socketClient.connect()}postMessage(e){this.socketClient.emit("message",e)}dispose(){this.subscribers.clear(),this.socketClient.close()}}n.WsClientHost=a},85026:function(e,n,t){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,n,t,r){void 0===r&&(r=t);var o=Object.getOwnPropertyDescriptor(n,t);o&&!("get"in o?!n.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return n[t]}}),Object.defineProperty(e,r,o)}:function(e,n,t,r){void 0===r&&(r=t),e[r]=n[t]}),o=this&&this.__exportStar||function(e,n){for(var t in e)"default"===t||Object.prototype.hasOwnProperty.call(n,t)||r(n,e,t)};Object.defineProperty(n,"__esModule",{value:!0}),o(t(24681),n),o(t(81948),n),o(t(45522),n),o(t(55329),n),o(t(20031),n),o(t(85053),n),o(t(72880),n),o(t(70339),n),o(t(78558),n),o(t(33808),n),o(t(93596),n),o(t(64673),n)},61456:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.initializeContextualEnv=void 0,n.initializeContextualEnv=function({communication:e,env:{env:n,environments:t},envInitializers:r}){const o=e.resolvedContexts[n],i=t.find((e=>e.env===o));if(!i)throw new Error(`${o} cannot be found in definition of ${n} environment`);if(i.env in r){const t=r[i.env];if(!t)throw new Error(`environment initializer is not set for ${i.env}`);return t({communication:e,env:{...i,env:n}})}throw new Error("error")}},63289:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.deferredIframeInitializer=n.iframeInitializer=n.INSTANCE_ID_PARAM_NAME=void 0;const r=t(85053);function o({communication:e,env:{env:t,endpointType:o}}){const c=e.getEnvironmentInstanceId(t,o),l=e.envReady(c);return{id:c,initialize:({iframeElement:o,hashParams:d,src:u,origin:p})=>{const h=e.getPublicPath();return async function({com:e,iframe:t,instanceId:o,src:a,envReadyPromise:c}){var l;if(!t.contentWindow)throw new Error("Cannot initialize environment in a detached iframe");null===(l=i.get(t))||void 0===l||l();const d=new Promise(((e,n)=>{i.set(t,(()=>{n("Cancelled environment initialization in an iframe")}))})),u=()=>{e.clearEnvironment(o)};try{const l=t.contentWindow,p=new URL(a,window.location.href);e.registerEnv(o,l),p.searchParams.set(n.INSTANCE_ID_PARAM_NAME,o),t.src=p.href,await Promise.race([d,s(t),c]);const h=e.apiProxy({id:o},{id:r.WindowInitializerService.apiId},{oncePageHide:{listener:!0}}),f=await h.getHref();if(t.contentWindow!==l||f!==p.href)throw new Error("Iframe location has changed during environment initialization");return await h.oncePageHide((()=>{u()})),i.delete(t),o}catch(e){throw u(),e}}({com:e,envReadyPromise:l,instanceId:c,iframe:o,src:null!=u?u:a(t,h,d,p)})}}}n.INSTANCE_ID_PARAM_NAME="iframe-instance-id",n.iframeInitializer=async function({communication:e,env:n,...t}){const{initialize:r}=o({communication:e,env:n});return{id:await r(t)}},n.deferredIframeInitializer=o;const i=new WeakMap,s=e=>new Promise((n=>e.addEventListener("load",n,{once:!0}))),a=(e,n="",t,r="")=>`${r}${n}${e}.html${location.search}${null!=t?t:""}`},93596:function(e,n,t){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,n,t,r){void 0===r&&(r=t);var o=Object.getOwnPropertyDescriptor(n,t);o&&!("get"in o?!n.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return n[t]}}),Object.defineProperty(e,r,o)}:function(e,n,t,r){void 0===r&&(r=t),e[r]=n[t]}),o=this&&this.__exportStar||function(e,n){for(var t in e)"default"===t||Object.prototype.hasOwnProperty.call(n,t)||r(n,e,t)};Object.defineProperty(n,"__esModule",{value:!0}),o(t(43790),n),o(t(28338),n),o(t(61456),n),o(t(57972),n),o(t(63289),n),o(t(43281),n),o(t(18503),n)},43281:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.ipcInitializer=void 0,n.ipcInitializer=async({communication:e,env:{env:n,endpointType:t}})=>{const r=e.getEnvironmentInstanceId(n,t),o=e.getEnvironmentHost(n);if(!o)throw new Error("IPC hosts should be registered and forked before the initializer run");return e.registerMessageHandler(o),await e.envReady(n),{id:r}}},43790:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.socketClientInitializer=void 0;const r=t(33808);n.socketClientInitializer=async({communication:e,env:{env:n},...t})=>{const o=e.topology[n];if(!o)throw new Error(`Could not find node topology for ${n} environment`);const i=n,s=new r.WsClientHost(o,t);return e.getEnvironmentHost(i)&&e.clearEnvironment(i,void 0,!1),e.registerMessageHandler(s),e.registerEnv(i,s),await s.connected,e.handleReady({from:i}),{id:i,onDisconnect:e=>{s.subscribers.on("disconnect",e)},onReconnect:e=>{s.subscribers.on("reconnect",e)}}}},18503:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0})},57972:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.webWorkerInitializer=void 0,n.webWorkerInitializer=async function({communication:e,env:{env:n,endpointType:t}}){const r="single"===t?n:e.generateEnvInstanceID(n),o=new Worker(`${e.getPublicPath()}${n}.webworker.js${location.search}`,{name:r});return e.registerMessageHandler(o),e.registerEnv(r,o),await e.envReady(r),{id:r}}},28338:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.windowInitializer=void 0;const r=t(55329),o=t(53427);n.windowInitializer=async function({communication:e,env:{env:n,endpointType:t},host:i}){const s=e.getEnvironmentInstanceId(n,t),a=(0,r.isIframe)(i)?i.contentWindow:i;if(!a)throw new Error("cannot spawn detached iframe.");return await(0,o.injectScript)(a,s,`${e.getPublicPath()}${n}.web.js${location.search}`),{id:s}}},20031:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.LoggerService=void 0;const r=t(53433),o=t(83456);class i extends r.EventEmitter{constructor(e=[],n={},t={severity:o.LogLevel.DEBUG}){super(),this.transports=e,this.baseMetadata=n,this.config=t,this.messages=[],this.debug=e=>this.log(e,o.LogLevel.DEBUG),this.info=e=>this.log(e,o.LogLevel.INFO),this.warn=e=>this.log(e,o.LogLevel.WARN),this.error=e=>this.log(e,o.LogLevel.ERROR)}getMessages(){return this.messages}logMessage(e){if(e.level>=this.config.severity){this.addToMessages(e),this.emit("message",e),this.config.logToConsole&&function({message:e,metadata:n={},level:t}){switch(t){case o.LogLevel.DEBUG:console.log(e,n);break;case o.LogLevel.INFO:console.info(e,n);break;case o.LogLevel.WARN:console.warn(e,n);break;case o.LogLevel.ERROR:console.error(e,n)}}(e);for(const n of this.transports)n.handleMessage(e)}}clearMessages(){this.messages=[]}log(e,n){const{value:t,metadata:r}=function(e){const n={value:""};if("function"==typeof e){const t=e();"string"==typeof t?n.value=t:(n.value=t.value,n.metadata=t.metadata||n.metadata)}else"string"==typeof e?n.value=e:(n.value=e.value,n.metadata=e.metadata);return n}(e);this.logMessage({message:t,timestamp:Date.now(),level:n,metadata:{base:this.baseMetadata,...r}})}addToMessages(e){this.messages.length+1>this.config.maxLogMessages&&this.messages.shift(),this.messages.push(e)}}n.LoggerService=i},72880:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.isMessage=void 0,n.isMessage=function(e){return"object"==typeof e&&null!==e&&"to"in e&&"from"in e&&"type"in e}},70339:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.multiTenantMethod=void 0,n.multiTenantMethod=function(e){return n=>({getArgs:function([e,...n]){return n},proxyFunction:function(...t){if("function"==typeof e)return e.call(n,...t);throw new Error("No Such function")}})}},78558:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.HOST_REMOVED=void 0,t(31035),n.HOST_REMOVED={name:"HOST_REMOVED",addEventListener:()=>{},removeEventListener:()=>{},postMessage:()=>{}}},85053:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.WindowInitializerService=void 0;class t{oncePageHide(e){window.addEventListener("pagehide",(()=>e()),{once:!0})}getHref(){return window.location.href}}n.WindowInitializerService=t,t.apiId="WindowInitializerService"},75986:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0})},18430:(e,n,t)=>{"use strict";var r=t(34406);Object.defineProperty(n,"__esModule",{value:!0});const o=t(24681),i=t(81948),s=t(20031),a=t(37684),c=t(80067),l=t(47421),d=t(75121),u=t(2750),p=t(31035),h=t(83456),f=t(85053);n.default=new l.Feature({id:"COM",api:{config:a.Config.withType().defineEntity({id:"",loggerSeverity:h.LogLevel.DEBUG,maxLogMessages:100,topology:{},resolvedContexts:{}},((e,n)=>({...e,...n,topology:{...e.topology,...n.topology},resolvedContexts:{...e.resolvedContexts,...n.resolvedContexts},connectedEnvironments:{...e.connectedEnvironments,...n.connectedEnvironments}}))),loggerTransports:u.Slot.withType().defineEntity(c.Universal),loggerService:d.Value.withType().defineEntity(c.Universal),communication:d.Value.withType().defineEntity(c.AllEnvironments)}}).setup(c.Universal,(({config:{host:e,id:n,topology:t,maxLogMessages:a,loggerSeverity:c,logToConsole:l,resolvedContexts:d,publicPath:u,connectedEnvironments:h={}},loggerTransports:m,[p.RUN_OPTIONS]:g,[p.ENGINE]:y,onDispose:_})=>{var b;const v=void 0!==r&&!!(null===(b=r.versions)||void 0===b?void 0:b.node)&&"browser"!==r.title&&"renderer"!==r.type,w=n||e&&e.name||"undefined"!=typeof self&&self.name||y.entryEnvironment.env,E={warnOnSlow:g.has("warnOnSlow"),publicPath:u,connectedEnvironments:h},S=new i.Communication(v?e||new o.BaseHost:self,w,t,d,v,E);S.registerAPI({id:f.WindowInitializerService.apiId},new f.WindowInitializerService);const T=new s.LoggerService(m,{environment:S.getEnvironmentId()},{severity:c,maxLogMessages:a,logToConsole:l});return _((()=>S.dispose())),{loggerService:T,communication:S}}))},37684:(e,n,t)=>{"use strict";var r;Object.defineProperty(n,"__esModule",{value:!0}),n.Config=void 0;const o=t(31035),i=t(80067),s=t(29763);class a extends s.FeatureInput{static withType(){return{defineEntity:(e,n,t)=>new a(e,n,t)}}constructor(e,n=((e,n)=>({...e,...n})),t=i.AllEnvironments){super(i.AllEnvironments,t),this.defaultValue=e,this.mergeConfig=n,this[r]=!0}[(r=o.CONFIGURABLE,o.CREATE_RUNTIME)](e,n,t){return e.getTopLevelConfig(n,t).reduce(((e,n)=>this.mergeConfig(e,n)),this.defaultValue)}[o.REGISTER_VALUE](e,n,t,r,o){return t}}n.Config=a},80067:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.testEnvironmentCollision=n.normEnvVisibility=n.SingleEndpointContextualEnvironment=n.orderedEnvDependencies=n.globallyProvidingEnvironments=n.AllEnvironments=n.Universal=n.EnvironmentContext=n.Environment=void 0;const r=t(36938);class o{constructor(e,n,t,r=[]){this.env=e,this.envType=n,this.endpointType=t,this.dependencies=r}}n.Environment=o;class i{constructor(e,n){this.env=e,this.activeEnvironmentName=n}}n.EnvironmentContext=i,n.Universal=new o("<Universal>","window","multi"),n.AllEnvironments=new o("<All>","window","multi"),n.globallyProvidingEnvironments=new Set([n.Universal.env,n.AllEnvironments.env]),n.orderedEnvDependencies=function e(n){var t,r;return null!==(r=null===(t=n.dependencies)||void 0===t?void 0:t.flatMap(e).concat(n.env))&&void 0!==r?r:[]},n.SingleEndpointContextualEnvironment=class extends o{constructor(e,n){if(super(e,"context","single"),this.environments=n,0===n.length)throw new Error(`Contextual Environment ${e} initiated without child environments`)}useContext(e){return new i(this.env,e)}withContext(){return{type:(0,r.runtimeType)(this.env+" context")}}getEnvironmentById(e){return this.environments.find((({env:n})=>n===e))}},n.normEnvVisibility=function(e){const n=new Set,t=e=>{for(const{env:r,dependencies:o}of e.dependencies)n.add(r),o.map(t)},r=Array.isArray(e)?e:[e];for(const e of r)n.add(e.env),t(e);return n},n.testEnvironmentCollision=function(e,n){const t=new Set,r=e=>{n.has(e)?t.add(e):n.add(e)};if(Array.isArray(e))for(const n of e)r(n.env);else r("string"==typeof e?e:e.env);return[...t]}},47421:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.Feature=n.RuntimeFeature=void 0;const r=t(31035),o=t(80067),i=t(53433),s=t(48074),a={dispose:()=>{}};class c{constructor(e,n,t){this.feature=e,this.api=n,this.dependencies=t,this.running=!1,this.runHandlers=new i.SetMultiMap,this.disposeHandlers=new i.SetMultiMap}addRunHandler(e,n){this.runHandlers.add(n,e)}addOnDisposeHandler(e,n){this.disposeHandlers.add(n,e)}async[r.RUN](e){if(this.running)return;this.running=!0;const n=[];for(const t of e.referencedEnvs){for(const t of this.feature.dependencies)n.push(e.runFeature(t));const r=this.runHandlers.get(t)||[];for(const e of r)n.push(e())}await Promise.all(n)}async[r.DISPOSE](e){const{entryEnvironment:{env:n}}=e;if(this.disposing)return this.disposing.promise;this.disposing=(0,s.deferred)();for(const n of this.feature.dependencies)await e.dispose(n);const t=this.disposeHandlers.get(n)||new Set;for(const e of t)await e();return this.disposing.resolve()}}n.RuntimeFeature=c;class l{constructor(e){this.asDependency=this,this.environmentIml=new Set,this.setupHandlers=new i.SetMultiMap,this.contextHandlers=new Map,this.id=e.id,this.dependencies=e.dependencies||[],this.api=e.api||{},this.context=e.context||{},this.identifyApis()}setup(e,n){return function(e,n,t){const r=(0,o.testEnvironmentCollision)(e,t);if(r.length){const e=r.join(", ");throw new Error(`Feature can only have single setup for each environment. ${n} Feature already implements: ${e}`)}}(e,this.id,this.environmentIml),this.setupHandlers.add(e.env,n),this}use(e){return[this.id,e]}setupContext(e,n,t){return function(e,n,t){if(t.get(e))throw new Error(`Feature can only have single setupContext for each context id. ${n} Feature already implements: ${String(e)}`)}(n,this.id,this.contextHandlers),this.contextHandlers.set(n,t),this}[r.CREATE_RUNTIME](e){const{features:n,runOptions:t,referencedEnvs:o,entryEnvironment:{env:i}}=e,s={},l={},d={},u={},p={},h={},f=Object.entries(this.api),m=new c(this,d,s);n.set(this,m);for(const n of this.dependencies)s[n.id]=e.initFeature(n),l[n.id]=s[n.id].api;for(const[n,t]of f){const o=t[r.CREATE_RUNTIME](e,this.id,n);void 0!==o&&(u[n]=o)}const g={...u,id:this.id,run(e){m.addRunHandler(e,i)},onDispose(e){m.addOnDisposeHandler(e,i)},[r.RUN_OPTIONS]:t,[r.ENGINE]:e,runningEnvironmentName:i};for(const[e,n]of this.contextHandlers)h[e]={...a,...n(l)};for(const e of o){const n=this.setupHandlers.get(e);if(n)for(const e of n){const n=e(g,l,h);if(n){for(const[e,t]of Object.entries(n))g[e]=t;Object.assign(p,n)}}}for(const[n,t]of f){const o=t[r.REGISTER_VALUE](e,p[n],u[n],this.id,n);void 0!==o&&(d[n]=o)}return m}identifyApis(){for(const[e,n]of Object.entries(this.api)){const t=n[r.IDENTIFY_API];t&&t.call(n,this.id,e)}}}n.Feature=l},34517:function(e,n,t){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,n,t,r){void 0===r&&(r=t);var o=Object.getOwnPropertyDescriptor(n,t);o&&!("get"in o?!n.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return n[t]}}),Object.defineProperty(e,r,o)}:function(e,n,t,r){void 0===r&&(r=t),e[r]=n[t]}),o=this&&this.__exportStar||function(e,n){for(var t in e)"default"===t||Object.prototype.hasOwnProperty.call(n,t)||r(n,e,t)};Object.defineProperty(n,"__esModule",{value:!0}),o(t(37684),n),o(t(80067),n),o(t(47421),n),o(t(29763),n),o(t(79426),n),o(t(90452),n),o(t(314),n),o(t(19239),n),o(t(2750),n)},29763:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.FeatureInput=void 0;const r=t(36938),o=t(31035);class i{constructor(e,n){this.providedFrom=e,this.visibleAt=n,this.mode="input",this.type=(0,r.runtimeType)(),this.proxyType=(0,r.runtimeType)(),this.remoteAccess=!1}[o.REGISTER_VALUE](e,n,t,r,o){return t}}n.FeatureInput=i},79426:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.MapSlot=n.MapRegistry=void 0;const r=t(31035),o=t(29763);class i{constructor(){this.items=new Map,this.callbacks=new Set}register(e,n){this.items.set(e,n);for(const t of this.callbacks)t(e,n)}[Symbol.iterator](){return this.items[Symbol.iterator]()}subscribe(e){this.callbacks.add(e)}unSubscribe(e){this.callbacks.delete(e)}stream(e){for(const[n,t]of this)e(n,t);return this.subscribe(e),()=>this.unSubscribe(e)}asMap(){return this.items}get(e){return this.items.get(e)}values(){return this.items.values()}}n.MapRegistry=i;class s extends o.FeatureInput{static withType(){return{defineEntity:e=>new s(e,e)}}[r.CREATE_RUNTIME](){return new i}}n.MapSlot=s},90452:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.OrderedSlot=n.OrderedRegistry=void 0;const r=t(31035),o=t(29763);function i(e,n){const t=e.indexOf(n);return t<0?1/0:t}function s(e,n){return e<n?-1:e>n?1:0}function a(e,n){return(t,r)=>e(t,r)||n(t,r)}const{hasOwnProperty:c}=Object.prototype;class l{constructor(){this.items=[],this.callbacks=new Set,this.compareFunction=(e,n)=>0}register(e){this.items.push(e),this.sortItems();for(const n of this.callbacks)n(e)}[Symbol.iterator](){return this.items[Symbol.iterator]()}subscribe(e){this.callbacks.add(e)}unSubscribe(e){this.callbacks.delete(e)}stream(e){for(const n of this)e(n);return this.subscribe(e),()=>this.unSubscribe(e)}setItems(e){return this.items=e,this.sortItems(),this}setSortingOrder(e){return this.compareFunction=function(e){let n=(e,n)=>0;for(const t in e)if(c.call(e,t)){const[r,o]=e[t];n=a(n,!0===o?(e,n)=>s(n[r],e[r]):!1===o?(e,n)=>s(e[r],n[r]):(e,n)=>i(o,e[r])-i(o,n[r]))}return n}(e),this.sortItems(),this}sortItems(){this.items.sort(this.compareFunction)}}n.OrderedRegistry=l;class d extends o.FeatureInput{static withType(){return{defineEntity:e=>new d(e,e)}}[r.CREATE_RUNTIME](){return new l}}n.OrderedSlot=d},314:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.FeatureOutput=void 0;const r=t(36938);t(31035),n.FeatureOutput=class{constructor(e,n,t){this.providedFrom=e,this.visibleAt=n,this.remoteAccess=t,this.mode="output",this.type=(0,r.runtimeType)(),this.proxyType=(0,r.runtimeType)()}}},19239:function(e,n,t){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0}),n.Service=void 0;const o=r(t(18430)),i=t(31035),s=t(80067),a=t(314);class c extends a.FeatureOutput{static withType(){return{defineEntity:e=>new c(e,e,!1)}}constructor(e,n,t,r={}){super(e,n,t),this.providedFrom=e,this.visibleAt=n,this.remoteAccess=t,this.options=r}allowRemoteAccess(e){return new c(this.providedFrom,s.AllEnvironments,!0,e)}[i.REGISTER_VALUE](e,n,t,r,i){if(this.remoteAccess){const{communication:a}=e.get(o.default).api,c=e.entityID(r,i),l=(0,s.normEnvVisibility)(this.providedFrom),d=a.getEnvironmentName();if(l.has(d)||l.has(s.Universal.env)){if(!n)throw new Error(`Service is not provided at runtime.\nMake sure the environment setup file exists and named correctly: [featureName].[envName].env.[ext]\nService name: ${i}\nFeature id: ${r}\nEnvironment: ${d}\n                        `);return a.registerAPI({id:c},n),n}return t||this.getApiProxy(e,c)}return n}[i.CREATE_RUNTIME](e,n,t){if(this.remoteAccess)return this.getApiProxy(e,e.entityID(n,t))}getApiProxy(e,n){const{communication:t}=e.get(o.default).api,r=function(e){if(function(e){return!!e&&e.endpointType&&"single"===e.endpointType}(e))return e.env}(this.providedFrom);return r?t.apiProxy({id:r},{id:n},this.options):{get:e=>t.apiProxy(e,{id:n},this.options)}}}n.Service=c},2750:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.Slot=n.Registry=void 0;const r=t(31035),o=t(29763);class i{constructor(){this.items=[],this.callbacks=new Set}register(e){this.items.push(e);for(const n of this.callbacks)n(e)}[Symbol.iterator](){return this.items[Symbol.iterator]()}subscribe(e){this.callbacks.add(e)}unSubscribe(e){this.callbacks.delete(e)}asArray(){return this.items}stream(e){for(const n of this)e(n);return this.subscribe(e),()=>this.unSubscribe(e)}}n.Registry=i;class s extends o.FeatureInput{static withType(){return{defineEntity:e=>new s(e,e)}}[r.CREATE_RUNTIME](){return new i}}n.Slot=s},75121:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.Value=void 0;const r=t(31035),o=t(314);class i extends o.FeatureOutput{static withType(){return{defineEntity:e=>new i(e)}}constructor(e){super(e,e,!1),this.providedFrom=e}[r.REGISTER_VALUE](e,n){return n}[r.CREATE_RUNTIME](){}}n.Value=i},36938:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.runtimeType=void 0,n.runtimeType=function(e){return Symbol(e)}},83561:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.flattenTree=n.returnsTrue=void 0,n.returnsTrue=()=>!0,n.flattenTree=function(e,t,r=n.returnsTrue){const o=new Set,i=new Set,s=[e];for(;s.length;){const e=s.shift();i.has(e)||(i.add(e),r(e)&&o.add(e),s.push(...t(e)))}return o}},53427:function(e,n,t){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,n,t,r){void 0===r&&(r=t);var o=Object.getOwnPropertyDescriptor(n,t);o&&!("get"in o?!n.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return n[t]}}),Object.defineProperty(e,r,o)}:function(e,n,t,r){void 0===r&&(r=t),e[r]=n[t]}),o=this&&this.__exportStar||function(e,n){for(var t in e)"default"===t||Object.prototype.hasOwnProperty.call(n,t)||r(n,e,t)};Object.defineProperty(n,"__esModule",{value:!0}),o(t(83561),n),o(t(7799),n),o(t(90616),n)},90616:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.serializeError=void 0,n.serializeError=function(e){return e instanceof Error?{...e,name:e.name,message:e.message,stack:e.stack}:{name:"Error",message:"string"==typeof e?e:JSON.stringify(e)}}},7799:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.injectScript=void 0,n.injectScript=function(e,n,t){return new Promise(((r,o)=>{e.name=n;const i=e.document.createElement("script");i.src=t,i.onload=()=>r(e),i.onerror=e=>o(e),e.document.head.appendChild(i)}))}},93849:function(e,n,t){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,n,t,r){void 0===r&&(r=t);var o=Object.getOwnPropertyDescriptor(n,t);o&&!("get"in o?!n.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return n[t]}}),Object.defineProperty(e,r,o)}:function(e,n,t,r){void 0===r&&(r=t),e[r]=n[t]}),o=this&&this.__exportStar||function(e,n){for(var t in e)"default"===t||Object.prototype.hasOwnProperty.call(n,t)||r(n,e,t)},i=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0}),n.RuntimeMetadata=n.COM=void 0,o(t(85026),n),o(t(53427),n),o(t(34517),n),o(t(75986),n),o(t(36938),n),o(t(99458),n),o(t(16363),n),o(t(31035),n),o(t(83456),n),o(t(18430),n),o(t(68104),n);const s=i(t(18430));n.COM=s.default;const a=i(t(68104));n.RuntimeMetadata=a.default},99458:function(e,n,t){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0}),n.canAccessWindow=n.getTopWindow=n.FeatureLoadersRegistry=n.runEngineApp=n.getFeaturesDeep=n.run=void 0;const o=r(t(18430)),i=t(16363),s=t(53427),a=t(48074);function c(e){try{return"string"==typeof e.location.search}catch{return!1}}n.run=function({entryFeature:e,topLevelConfig:n=[],env:t,runOptions:r}){return new i.RuntimeEngine(t,n,r).run(e)},n.getFeaturesDeep=e=>(0,s.flattenTree)(e,(e=>e.dependencies)),n.runEngineApp=function({config:e=[],options:n,env:t,publicPath:r,features:s=[],resolvedContexts:a={}}){const c=new i.RuntimeEngine(t,[o.default.use({config:{resolvedContexts:a,publicPath:r}}),...e],n),l=c.run(s);return{engine:c,async dispose(){await l;for(const e of s)await c.dispose(e)}}},n.FeatureLoadersRegistry=class{constructor(e=new Map,n={}){this.featureMapping=e,this.resolvedContexts=n,this.pendingLoaderRequests=new Map,this.loadedFeatures=new Set}register(e,n){var t;this.featureMapping.set(e,n),null===(t=this.pendingLoaderRequests.get(e))||void 0===t||t.resolve(n),this.pendingLoaderRequests.delete(e)}get(e){const n=this.featureMapping.get(e);if(n)return n;let t=this.pendingLoaderRequests.get(e);return t||(t=(0,a.deferred)(),this.pendingLoaderRequests.set(e,t)),t.promise}getRegistered(){return[...this.featureMapping.keys()]}async getLoadedFeatures(e,n={}){const t=[],r=await this.getFeatureDependencies(e);for await(const e of r.reverse())if(!this.loadedFeatures.has(e)){this.loadedFeatures.add(e);const n=this.get(e);t.push(n)}const o=await Promise.all(t),i=[];for(const e of o)if(e.preload){const n=await e.preload(this.resolvedContexts);n&&i.push(...n)}for(const e of i)await e(n);return Promise.all(o.map((({load:e})=>e(this.resolvedContexts))))}async getFeatureDependencies(e){const n=[e],t=[e];for(;t.length;){const{depFeatures:e}=await this.get(t.shift());for(const r of e)n.includes(r)||(n.push(r),t.push(r))}return n}},n.getTopWindow=function(e){for(;e.parent&&e.parent!==e&&c(e.parent);)e=e.parent;return e},n.canAccessWindow=c},16363:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.RuntimeEngine=void 0;const r=t(34517),o=t(31035);n.RuntimeEngine=class{constructor(e,n=[],t=new Map){this.entryEnvironment=e,this.runOptions=t,this.features=new Map,this.running=!1,this.topLevelConfigMap=this.createConfigMap(n),this.referencedEnvs=new Set([...r.globallyProvidingEnvironments,...(0,r.orderedEnvDependencies)(e)])}get(e){const n=this.features.get(e);if(n)return n;throw new Error(`missing feature ${e.id}`)}async run(e){if(this.running)throw new Error("Engine already running!");this.running=!0,Array.isArray(e)||(e=[e]);for(const n of e)this.initFeature(n);const n=[];for(const t of e)n.push(this.runFeature(t));return await Promise.all(n),this}initFeature(e){let n=this.features.get(e);return n||(n=e[o.CREATE_RUNTIME](this)),n}async runFeature(e){const n=this.features.get(e);if(!n)throw new Error("Could not find running feature: "+e.id);await n[o.RUN](this)}async dispose(e){const n=this.features.get(e);n&&(await n[o.DISPOSE](this),this.features.delete(e))}getTopLevelConfig(e,n){return this.topLevelConfigMap[this.entityID(e,n)]||[]}entityID(e,n){return`${e}.${n}`}createConfigMap(e){const n={};for(const[t,r]of e)for(const[e,o]of Object.entries(r)){const r=this.entityID(t,e);n[r]=n[r]||[],n[r].push(o)}return n}}},68104:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(37684),o=t(47421);n.default=new o.Feature({id:"runtimeMetadata",dependencies:[],api:{engineerMetadataConfig:new r.Config({applicationPath:""})}})},31035:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.CONFIGURABLE=n.ENGINE=n.RUN_OPTIONS=n.SERVICE_CONFIG=n.REGISTER_VALUE=n.CREATE_RUNTIME=n.IDENTIFY_API=n.DISPOSE=n.RUN=void 0,n.RUN=Symbol.for("__ENGINE__RUN"),n.DISPOSE=Symbol.for("__ENGINE__DISPOSE"),n.IDENTIFY_API=Symbol.for("__ENGINE__IDENTIFY_API"),n.CREATE_RUNTIME=Symbol.for("__ENGINE__CREATE"),n.REGISTER_VALUE=Symbol.for("__ENGINE__REGISTER_VALUE"),n.SERVICE_CONFIG=Symbol.for("__ENGINE__SERVICE_CONFIG"),n.RUN_OPTIONS=Symbol.for("__ENGINE__RUN_OPTIONS"),n.ENGINE=Symbol.for("__RUNTIME_ENGINE__"),n.CONFIGURABLE=Symbol.for("__ENGINE__CONFIGURABLE")},83456:(e,n,t)=>{"use strict";var r;Object.defineProperty(n,"__esModule",{value:!0}),n.LogLevel=void 0,t(31035),Symbol(""),(r=n.LogLevel||(n.LogLevel={}))[r.DEBUG=0]="DEBUG",r[r.INFO=1]="INFO",r[r.WARN=2]="WARN",r[r.ERROR=3]="ERROR"},13064:(e,n,t)=>{"use strict";n.M=void 0,n.M=async function(e,n){const r=n?`${e}.${n}`:e,o=`${t.p}configs/${r}.json`,i=await fetch(o);return await i.json()}},17340:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>r});const r=(0,t(13064).M)("stylable-playground/example","")},53433:(e,n,t)=>{"use strict";function r(){const e=new Set;return{async dispose(){const n=Array.from(e).reverse();e.clear();for(const e of n)"function"==typeof e?await e():await e.dispose()},add(n){e.add(n)},remove(n){e.delete(n)}}}t.r(n),t.d(n,{Debouncer:()=>j,EventEmitter:()=>i,LRUCache:()=>s,SetMultiMap:()=>A,Signal:()=>o,createDisposables:()=>r,isSetMultiMap:()=>F});class o extends Set{constructor(){super(...arguments),this.subscribe=e=>{this.add(e)},this.unsubscribe=e=>{this.delete(e)},this.notify=e=>{for(const n of this)n(e)}}}class i{constructor(){this.events=new Map,this.emitOnce=new Map,this.hasSubscribers=e=>this.events.has(e),this.subscribe=(e,n)=>{const t=this.events.get(e);t?t.add(n):this.events.set(e,new o([n]))},this.on=this.subscribe,this.once=(e,n)=>{this.off(e,n);const t=this.emitOnce.get(e);t?t.add(n):this.emitOnce.set(e,new o([n]))},this.unsubscribe=(e,n)=>{let t=this.events.get(e);null==t||t.delete(n),0===(null==t?void 0:t.size)&&this.events.delete(e),t=this.emitOnce.get(e),null==t||t.delete(n),0===(null==t?void 0:t.size)&&this.events.delete(e)},this.off=this.unsubscribe,this.delete=e=>{this.events.delete(e),this.emitOnce.delete(e)},this.clear=()=>{this.events=new Map,this.emitOnce=new Map},this.notify=(e,n)=>{var t,r;null===(t=this.events.get(e))||void 0===t||t.notify(n),null===(r=this.emitOnce.get(e))||void 0===r||r.notify(n),this.emitOnce.delete(e)},this.emit=this.notify}}class s{constructor(e={}){var n;if(this.config=e,this.cache=new Map,this.keys=[],this.maxSize=null!==(n=e.maxSize)&&void 0!==n?n:1/0,this.maxSize<1)throw new Error("LRUCache max size must be larger than 0")}set(e,n){if(this.updateKeysOrder(e),this.keys.length>this.maxSize){const e=this.keys.shift();this.cache.delete(e)}this.cache.set(e,n)}get(e){if(this.cache.has(e))return this.updateKeysOrder(e),this.cache.get(e)}delete(e){const n=this.keys.indexOf(e);n>-1&&this.keys.splice(n,1),this.cache.delete(e)}has(e){return this.cache.has(e)}size(){return this.cache.size}clear(){this.cache.clear(),this.keys=[]}updateKeysOrder(e){const n=this.keys.indexOf(e);n>-1&&this.keys.splice(n,1),this.keys.push(e)}}function a(e){let n;if(e)for(const t of e)n=t;return n}function c(e){return u(e,0)}function l(e){for(const n of e)return!1;return!0}function d(e){let n=0;if(e)for(const t of e)n++;return n}function u(e,n){if(e){if(n<0){const t=Array.from(e);return t[t.length+n]}let t=0;for(const r of e)if(t++===n)return r}}function p(e,n){let t=!1;if(e)for(const r of e){if(t)return r;r===n&&(t=!0)}}function h(e,n){let t;if(e)for(const r of e){if(r===n)return t;t=r}}function*f(e,n=(e=>e)){const t=new Set;if(e){for(const r of e)t.has(n(r))||(t.add(n(r)),yield r);t.clear()}}function*m(e,n){if(e)for(const t of e)yield n(t)}function*g(e,n){yield*T(m(e,n))}function*y(e,n){if(e)for(const t of e)n(t)&&(yield t)}function*_(...e){for(const n of e)n&&(yield*n)}function b(e,n){if(e)for(const t of e)n(t)}function v(e,n){if(e)for(const t of e)if(n(t))return t}function w(e,n){return!!v(e,(e=>e===n))}function E(e,n){return!!v(e,n)}function S(e,n){for(const t of e)if(!n(t))return!1;return!0}function*T(e,n=!1){if(e)for(const r of e)null!=(t=r)&&"object"==typeof t&&Symbol.iterator in t?yield*n?T(r):r:yield r;var t}function C(e,n){return e?[...e].sort(n):[]}function k(e,n,t){let r=t;if(e)for(const t of e)r=n(r,t);return r}function I(e,n){if(!e)return"";let t=c(e)||"",r=null;for(const o of R(e,1))r&&(t=t+n+r),r=o;return r&&(t=t+n+r),t}function*R(e,n){if(e)for(const t of e)0===n?yield t:n--}function O(e,n){return Object.fromEntries(Object.entries(e).map((([e,t])=>[e,n(t,e)])))}const P=Symbol(),D=(e,n)=>Object.fromEntries(M(Object.entries(e)).filter((([e])=>n[e]!==D.DELETE)).map((([e,t])=>[n[e]||e,t])).iterable);function M(e){const n=void 0===e?[]:null===e?[null]:"object"==typeof e&&Symbol.iterator in e?e:[e];return n===e?x(n):N(e)}function x(e){const n={join:I,last:a,first:c,isEmpty:l,size:d,at:u,next:p,prev:h,find:v,some:E,includes:w,every:S,reduce:k},t=O({skip:R,map:m,flatMap:g,filter:y,concat:_,flat:T,unique:f,sort:C},(n=>(...t)=>x(n(e,...t)))),r=O(n,(n=>(...t)=>N(n(e,...t))));return{value:e,iterable:e,...t,...r,forEach:n=>(b(e,n),x(e))}}function N(e){return{...x(void 0===e?[]:[e]),value:e}}D.DELETE=P;class A{constructor(e){this.map=new Map,b(e,(([e,n])=>{this.add(e,n)}))}get size(){return M(this.map).map((([e,{size:n}])=>n)).reduce(((e,n)=>e+n),0).value}get(e){return this.map.get(e)}add(e,n){const t=this.map.get(e);return t?t.add(n):this.map.set(e,new Set([n])),this}clear(){this.map.clear()}delete(e,n){const t=this.map.get(e);if(t){const r=t.delete(n);return 0===t.size&&this.map.delete(e),r}return!1}deleteKey(e){return this.map.delete(e)}has(e,n){const t=this.map.get(e);return!!t&&t.has(n)}hasKey(e){const n=this.map.get(e);return!!n&&n.size>0}[Symbol.iterator](){return this.entries()}*entries(){const{map:e}=this;for(const[n,t]of e.entries())for(const e of t)yield[n,e]}*values(){const{map:e}=this;for(const n of e.values())yield*n.values()}keys(){return this.map.keys()}}function F(e){return e instanceof A}var L=t(30126);class j{constructor(e,n,t){this.cb=e,this.waitTime=n,this.maxWaitTime=t,this.args=[],this.defer=(0,L.g)()}execute(){try{const e=this.cb(...this.args);this.defer.resolve(e)}catch(e){this.defer.reject(e)}this.defer=(0,L.g)()}trigger(...e){return this.args=e,this.timeout&&clearTimeout(this.timeout),this.timeout=setTimeout((()=>{this.execute(),this.maxTimeout&&clearTimeout(this.maxTimeout)}),this.waitTime),this.maxTimeout||(this.maxTimeout=setTimeout((()=>{this.execute(),this.timeout&&clearTimeout(this.timeout)}),this.maxWaitTime)),this.defer.promise}cancel(){this.timeout&&clearTimeout(this.timeout),this.maxTimeout&&clearTimeout(this.maxTimeout)}}},95766:(e,n)=>{"use strict";n.byteLength=function(e){var n=c(e),t=n[0],r=n[1];return 3*(t+r)/4-r},n.toByteArray=function(e){var n,t,i=c(e),s=i[0],a=i[1],l=new o(function(e,n,t){return 3*(n+t)/4-t}(0,s,a)),d=0,u=a>0?s-4:s;for(t=0;t<u;t+=4)n=r[e.charCodeAt(t)]<<18|r[e.charCodeAt(t+1)]<<12|r[e.charCodeAt(t+2)]<<6|r[e.charCodeAt(t+3)],l[d++]=n>>16&255,l[d++]=n>>8&255,l[d++]=255&n;return 2===a&&(n=r[e.charCodeAt(t)]<<2|r[e.charCodeAt(t+1)]>>4,l[d++]=255&n),1===a&&(n=r[e.charCodeAt(t)]<<10|r[e.charCodeAt(t+1)]<<4|r[e.charCodeAt(t+2)]>>2,l[d++]=n>>8&255,l[d++]=255&n),l},n.fromByteArray=function(e){for(var n,r=e.length,o=r%3,i=[],s=16383,a=0,c=r-o;a<c;a+=s)i.push(l(e,a,a+s>c?c:a+s));return 1===o?(n=e[r-1],i.push(t[n>>2]+t[n<<4&63]+"==")):2===o&&(n=(e[r-2]<<8)+e[r-1],i.push(t[n>>10]+t[n>>4&63]+t[n<<2&63]+"=")),i.join("")};for(var t=[],r=[],o="undefined"!=typeof Uint8Array?Uint8Array:Array,i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",s=0,a=i.length;s<a;++s)t[s]=i[s],r[i.charCodeAt(s)]=s;function c(e){var n=e.length;if(n%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var t=e.indexOf("=");return-1===t&&(t=n),[t,t===n?0:4-t%4]}function l(e,n,r){for(var o,i,s=[],a=n;a<r;a+=3)o=(e[a]<<16&16711680)+(e[a+1]<<8&65280)+(255&e[a+2]),s.push(t[(i=o)>>18&63]+t[i>>12&63]+t[i>>6&63]+t[63&i]);return s.join("")}r["-".charCodeAt(0)]=62,r["_".charCodeAt(0)]=63},65881:e=>{var n=1e3,t=60*n,r=60*t,o=24*r;function i(e,n,t,r){var o=n>=1.5*t;return Math.round(e/t)+" "+r+(o?"s":"")}e.exports=function(e,s){s=s||{};var a,c,l=typeof e;if("string"===l&&e.length>0)return function(e){if(!((e=String(e)).length>100)){var i=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e);if(i){var s=parseFloat(i[1]);switch((i[2]||"ms").toLowerCase()){case"years":case"year":case"yrs":case"yr":case"y":return 315576e5*s;case"weeks":case"week":case"w":return 6048e5*s;case"days":case"day":case"d":return s*o;case"hours":case"hour":case"hrs":case"hr":case"h":return s*r;case"minutes":case"minute":case"mins":case"min":case"m":return s*t;case"seconds":case"second":case"secs":case"sec":case"s":return s*n;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return s;default:return}}}}(e);if("number"===l&&isFinite(e))return s.long?(a=e,(c=Math.abs(a))>=o?i(a,c,o,"day"):c>=r?i(a,c,r,"hour"):c>=t?i(a,c,t,"minute"):c>=n?i(a,c,n,"second"):a+" ms"):function(e){var i=Math.abs(e);return i>=o?Math.round(e/o)+"d":i>=r?Math.round(e/r)+"h":i>=t?Math.round(e/t)+"m":i>=n?Math.round(e/n)+"s":e+"ms"}(e);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(e))}},25130:(e,n,t)=>{var r=t(34406);n.formatArgs=function(n){if(n[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+n[0]+(this.useColors?"%c ":" ")+"+"+e.exports.humanize(this.diff),!this.useColors)return;const t="color: "+this.color;n.splice(1,0,t,"color: inherit");let r=0,o=0;n[0].replace(/%[a-zA-Z%]/g,(e=>{"%%"!==e&&(r++,"%c"===e&&(o=r))})),n.splice(o,0,t)},n.save=function(e){try{e?n.storage.setItem("debug",e):n.storage.removeItem("debug")}catch(e){}},n.load=function(){let e;try{e=n.storage.getItem("debug")}catch(e){}return!e&&void 0!==r&&"env"in r&&(e=r.env.DEBUG),e},n.useColors=function(){return!("undefined"==typeof window||!window.process||"renderer"!==window.process.type&&!window.process.__nwjs)||("undefined"==typeof navigator||!navigator.userAgent||!navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))&&("undefined"!=typeof document&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||"undefined"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))},n.storage=function(){try{return localStorage}catch(e){}}(),n.destroy=(()=>{let e=!1;return()=>{e||(e=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))}})(),n.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"],n.log=console.debug||console.log||(()=>{}),e.exports=t(87123)(n);const{formatters:o}=e.exports;o.j=function(e){try{return JSON.stringify(e)}catch(e){return"[UnexpectedJSONParseError]: "+e.message}}},87123:(e,n,t)=>{e.exports=function(e){function n(e){let t,o,i,s=null;function a(...e){if(!a.enabled)return;const r=a,o=Number(new Date),i=o-(t||o);r.diff=i,r.prev=t,r.curr=o,t=o,e[0]=n.coerce(e[0]),"string"!=typeof e[0]&&e.unshift("%O");let s=0;e[0]=e[0].replace(/%([a-zA-Z%])/g,((t,o)=>{if("%%"===t)return"%";s++;const i=n.formatters[o];if("function"==typeof i){const n=e[s];t=i.call(r,n),e.splice(s,1),s--}return t})),n.formatArgs.call(r,e),(r.log||n.log).apply(r,e)}return a.namespace=e,a.useColors=n.useColors(),a.color=n.selectColor(e),a.extend=r,a.destroy=n.destroy,Object.defineProperty(a,"enabled",{enumerable:!0,configurable:!1,get:()=>null!==s?s:(o!==n.namespaces&&(o=n.namespaces,i=n.enabled(e)),i),set:e=>{s=e}}),"function"==typeof n.init&&n.init(a),a}function r(e,t){const r=n(this.namespace+(void 0===t?":":t)+e);return r.log=this.log,r}function o(e){return e.toString().substring(2,e.toString().length-2).replace(/\.\*\?$/,"*")}return n.debug=n,n.default=n,n.coerce=function(e){return e instanceof Error?e.stack||e.message:e},n.disable=function(){const e=[...n.names.map(o),...n.skips.map(o).map((e=>"-"+e))].join(",");return n.enable(""),e},n.enable=function(e){let t;n.save(e),n.namespaces=e,n.names=[],n.skips=[];const r=("string"==typeof e?e:"").split(/[\s,]+/),o=r.length;for(t=0;t<o;t++)r[t]&&("-"===(e=r[t].replace(/\*/g,".*?"))[0]?n.skips.push(new RegExp("^"+e.slice(1)+"$")):n.names.push(new RegExp("^"+e+"$")))},n.enabled=function(e){if("*"===e[e.length-1])return!0;let t,r;for(t=0,r=n.skips.length;t<r;t++)if(n.skips[t].test(e))return!1;for(t=0,r=n.names.length;t<r;t++)if(n.names[t].test(e))return!0;return!1},n.humanize=t(65881),n.destroy=function(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")},Object.keys(e).forEach((t=>{n[t]=e[t]})),n.names=[],n.skips=[],n.formatters={},n.selectColor=function(e){let t=0;for(let n=0;n<e.length;n++)t=(t<<5)-t+e.charCodeAt(n),t|=0;return n.colors[Math.abs(t)%n.colors.length]},n.enable(n.load()),n}},62333:(e,n)=>{n.read=function(e,n,t,r,o){var i,s,a=8*o-r-1,c=(1<<a)-1,l=c>>1,d=-7,u=t?o-1:0,p=t?-1:1,h=e[n+u];for(u+=p,i=h&(1<<-d)-1,h>>=-d,d+=a;d>0;i=256*i+e[n+u],u+=p,d-=8);for(s=i&(1<<-d)-1,i>>=-d,d+=r;d>0;s=256*s+e[n+u],u+=p,d-=8);if(0===i)i=1-l;else{if(i===c)return s?NaN:1/0*(h?-1:1);s+=Math.pow(2,r),i-=l}return(h?-1:1)*s*Math.pow(2,i-r)},n.write=function(e,n,t,r,o,i){var s,a,c,l=8*i-o-1,d=(1<<l)-1,u=d>>1,p=23===o?Math.pow(2,-24)-Math.pow(2,-77):0,h=r?0:i-1,f=r?1:-1,m=n<0||0===n&&1/n<0?1:0;for(n=Math.abs(n),isNaN(n)||n===1/0?(a=isNaN(n)?1:0,s=d):(s=Math.floor(Math.log(n)/Math.LN2),n*(c=Math.pow(2,-s))<1&&(s--,c*=2),(n+=s+u>=1?p/c:p*Math.pow(2,1-u))*c>=2&&(s++,c/=2),s+u>=d?(a=0,s=d):s+u>=1?(a=(n*c-1)*Math.pow(2,o),s+=u):(a=n*Math.pow(2,u-1)*Math.pow(2,o),s=0));o>=8;e[t+h]=255&a,h+=f,a/=256,o-=8);for(s=s<<o|a,l+=o;l>0;e[t+h]=255&s,h+=f,s/=256,l-=8);e[t+h-f]|=128*m}},50340:(e,n)=>{function t(e){for(var n=arguments.length,t=Array(n>1?n-1:0),r=1;r<n;r++)t[r-1]=arguments[r];throw Error("[Immer] minified error nr: "+e+(t.length?" "+t.map((function(e){return"'"+e+"'"})).join(","):"")+". Find the full error at: https://bit.ly/3cXEKWf")}function r(e){return!!e&&!!e[K]}function o(e){var n;return!!e&&(function(e){if(!e||"object"!=typeof e)return!1;var n=Object.getPrototypeOf(e);if(null===n)return!0;var t=Object.hasOwnProperty.call(n,"constructor")&&n.constructor;return t===Object||"function"==typeof t&&Function.toString.call(t)===X}(e)||Array.isArray(e)||!!e[G]||!!(null===(n=e.constructor)||void 0===n?void 0:n[G])||u(e)||p(e))}function i(e,n,t){void 0===t&&(t=!1),0===s(e)?(t?Object.keys:J)(e).forEach((function(r){t&&"symbol"==typeof r||n(r,e[r],e)})):e.forEach((function(t,r){return n(r,t,e)}))}function s(e){var n=e[K];return n?n.t>3?n.t-4:n.t:Array.isArray(e)?1:u(e)?2:p(e)?3:0}function a(e,n){return 2===s(e)?e.has(n):Object.prototype.hasOwnProperty.call(e,n)}function c(e,n){return 2===s(e)?e.get(n):e[n]}function l(e,n,t){var r=s(e);2===r?e.set(n,t):3===r?e.add(t):e[n]=t}function d(e,n){return e===n?0!==e||1/e==1/n:e!=e&&n!=n}function u(e){return q&&e instanceof Map}function p(e){return V&&e instanceof Set}function h(e){return e.i||e.u}function f(e){if(Array.isArray(e))return Array.prototype.slice.call(e);var n=Q(e);delete n[K];for(var t=J(n),r=0;r<t.length;r++){var o=t[r],i=n[o];!1===i.writable&&(i.writable=!0,i.configurable=!0),(i.get||i.set)&&(n[o]={configurable:!0,writable:!0,enumerable:i.enumerable,value:e[o]})}return Object.create(Object.getPrototypeOf(e),n)}function m(e,n){return void 0===n&&(n=!1),y(e)||r(e)||!o(e)||(s(e)>1&&(e.set=e.add=e.clear=e.delete=g),Object.freeze(e),n&&i(e,(function(e,n){return m(n,!0)}),!0)),e}function g(){t(2)}function y(e){return null==e||"object"!=typeof e||Object.isFrozen(e)}function _(e){var n=Z[e];return n||t(18,e),n}function b(e,n){Z[e]||(Z[e]=n)}function v(){return W}function w(e,n){n&&(_("Patches"),e.o=[],e.v=[],e.s=n)}function E(e){S(e),e.p.forEach(C),e.p=null}function S(e){e===W&&(W=e.l)}function T(e){return W={p:[],l:W,h:e,_:!0,m:0}}function C(e){var n=e[K];0===n.t||1===n.t?n.j():n.O=!0}function k(e,n){n.m=n.p.length;var r=n.p[0],i=void 0!==e&&e!==r;return n.h.S||_("ES5").P(n,e,i),i?(r[K].M&&(E(n),t(4)),o(e)&&(e=I(n,e),n.l||O(n,e)),n.o&&_("Patches").g(r[K].u,e,n.o,n.v)):e=I(n,r,[]),E(n),n.o&&n.s(n.o,n.v),e!==$?e:void 0}function I(e,n,t){if(y(n))return n;var r=n[K];if(!r)return i(n,(function(o,i){return R(e,r,n,o,i,t)}),!0),n;if(r.A!==e)return n;if(!r.M)return O(e,r.u,!0),r.u;if(!r.R){r.R=!0,r.A.m--;var o=4===r.t||5===r.t?r.i=f(r.k):r.i,s=o,a=!1;3===r.t&&(s=new Set(o),o.clear(),a=!0),i(s,(function(n,i){return R(e,r,o,n,i,t,a)})),O(e,o,!1),t&&e.o&&_("Patches").F(r,t,e.o,e.v)}return r.i}function R(e,n,t,i,s,c,d){if(r(s)){var u=I(e,s,c&&n&&3!==n.t&&!a(n.N,i)?c.concat(i):void 0);if(l(t,i,u),!r(u))return;e._=!1}else d&&t.add(s);if(o(s)&&!y(s)){if(!e.h.D&&e.m<1)return;I(e,s),n&&n.A.l||O(e,s)}}function O(e,n,t){void 0===t&&(t=!1),!e.l&&e.h.D&&e._&&m(n,t)}function P(e,n){var t=e[K];return(t?h(t):e)[n]}function D(e,n){if(n in e)for(var t=Object.getPrototypeOf(e);t;){var r=Object.getOwnPropertyDescriptor(t,n);if(r)return r;t=Object.getPrototypeOf(t)}}function M(e){e.M||(e.M=!0,e.l&&M(e.l))}function x(e){e.i||(e.i=f(e.u))}function N(e,n,t){var r=u(n)?_("MapSet").K(n,t):p(n)?_("MapSet").$(n,t):e.S?function(e,n){var t=Array.isArray(e),r={t:t?1:0,A:n?n.A:v(),M:!1,R:!1,N:{},l:n,u:e,k:null,i:null,j:null,C:!1},o=r,i=ee;t&&(o=[r],i=ne);var s=Proxy.revocable(o,i),a=s.revoke,c=s.proxy;return r.k=c,r.j=a,c}(n,t):_("ES5").I(n,t);return(t?t.A:v()).p.push(r),r}function A(e){return r(e)||t(22,e),function e(n){if(!o(n))return n;var t,r=n[K],a=s(n);if(r){if(!r.M&&(r.t<4||!_("ES5").J(r)))return r.u;r.R=!0,t=F(n,a),r.R=!1}else t=F(n,a);return i(t,(function(n,o){r&&c(r.u,n)===o||l(t,n,e(o))})),3===a?new Set(t):t}(e)}function F(e,n){switch(n){case 2:return new Map(e);case 3:return Array.from(e)}return f(e)}function L(){function e(e,n){var t=s[e];return t?t.enumerable=n:s[e]=t={configurable:!0,enumerable:n,get:function(){return ee.get(this[K],e)},set:function(n){ee.set(this[K],e,n)}},t}function n(e){for(var n=e.length-1;n>=0;n--){var r=e[n][K];if(!r.M)switch(r.t){case 5:o(r)&&M(r);break;case 4:t(r)&&M(r)}}}function t(e){for(var n=e.u,t=e.k,r=J(t),o=r.length-1;o>=0;o--){var i=r[o];if(i!==K){var s=n[i];if(void 0===s&&!a(n,i))return!0;var c=t[i],l=c&&c[K];if(l?l.u!==s:!d(c,s))return!0}}var u=!!n[K];return r.length!==J(n).length+(u?0:1)}function o(e){var n=e.k;if(n.length!==e.u.length)return!0;var t=Object.getOwnPropertyDescriptor(n,n.length-1);if(t&&!t.get)return!0;for(var r=0;r<n.length;r++)if(!n.hasOwnProperty(r))return!0;return!1}var s={};b("ES5",{I:function(n,t){var r=Array.isArray(n),o=function(n,t){if(n){for(var r=Array(t.length),o=0;o<t.length;o++)Object.defineProperty(r,""+o,e(o,!0));return r}var i=Q(t);delete i[K];for(var s=J(i),a=0;a<s.length;a++){var c=s[a];i[c]=e(c,n||!!i[c].enumerable)}return Object.create(Object.getPrototypeOf(t),i)}(r,n),i={t:r?5:4,A:t?t.A:v(),M:!1,R:!1,N:{},l:t,u:n,k:o,i:null,O:!1,C:!1};return Object.defineProperty(o,K,{value:i,writable:!0}),o},P:function(e,t,s){s?r(t)&&t[K].A===e&&n(e.p):(e.o&&function e(n){if(n&&"object"==typeof n){var t=n[K];if(t){var r=t.u,s=t.k,c=t.N,l=t.t;if(4===l)i(s,(function(n){n!==K&&(void 0!==r[n]||a(r,n)?c[n]||e(s[n]):(c[n]=!0,M(t)))})),i(r,(function(e){void 0!==s[e]||a(s,e)||(c[e]=!1,M(t))}));else if(5===l){if(o(t)&&(M(t),c.length=!0),s.length<r.length)for(var d=s.length;d<r.length;d++)c[d]=!1;else for(var u=r.length;u<s.length;u++)c[u]=!0;for(var p=Math.min(s.length,r.length),h=0;h<p;h++)s.hasOwnProperty(h)||(c[h]=!0),void 0===c[h]&&e(s[h])}}}}(e.p[0]),n(e.p))},J:function(e){return 4===e.t?t(e):o(e)}})}function j(){function e(n){if(!o(n))return n;if(Array.isArray(n))return n.map(e);if(u(n))return new Map(Array.from(n.entries()).map((function(n){return[n[0],e(n[1])]})));if(p(n))return new Set(Array.from(n).map(e));var t=Object.create(Object.getPrototypeOf(n));for(var r in n)t[r]=e(n[r]);return a(n,G)&&(t[G]=n[G]),t}function n(n){return r(n)?e(n):n}var l="add";b("Patches",{W:function(n,r){return r.forEach((function(r){for(var o=r.path,i=r.op,a=n,d=0;d<o.length-1;d++){var u=s(a),p=""+o[d];0!==u&&1!==u||"__proto__"!==p&&"constructor"!==p||t(24),"function"==typeof a&&"prototype"===p&&t(24),"object"!=typeof(a=c(a,p))&&t(15,o.join("/"))}var h=s(a),f=e(r.value),m=o[o.length-1];switch(i){case"replace":switch(h){case 2:return a.set(m,f);case 3:t(16);default:return a[m]=f}case l:switch(h){case 1:return"-"===m?a.push(f):a.splice(m,0,f);case 2:return a.set(m,f);case 3:return a.add(f);default:return a[m]=f}case"remove":switch(h){case 1:return a.splice(m,1);case 2:return a.delete(m);case 3:return a.delete(r.value);default:return delete a[m]}default:t(17,i)}})),n},F:function(e,t,r,o){switch(e.t){case 0:case 4:case 2:return function(e,t,r,o){var s=e.u,d=e.i;i(e.N,(function(e,i){var u=c(s,e),p=c(d,e),h=i?a(s,e)?"replace":l:"remove";if(u!==p||"replace"!==h){var f=t.concat(e);r.push("remove"===h?{op:h,path:f}:{op:h,path:f,value:p}),o.push(h===l?{op:"remove",path:f}:"remove"===h?{op:l,path:f,value:n(u)}:{op:"replace",path:f,value:n(u)})}}))}(e,t,r,o);case 5:case 1:return function(e,t,r,o){var i=e.u,s=e.N,a=e.i;if(a.length<i.length){var c=[a,i];i=c[0],a=c[1];var d=[o,r];r=d[0],o=d[1]}for(var u=0;u<i.length;u++)if(s[u]&&a[u]!==i[u]){var p=t.concat([u]);r.push({op:"replace",path:p,value:n(a[u])}),o.push({op:"replace",path:p,value:n(i[u])})}for(var h=i.length;h<a.length;h++){var f=t.concat([h]);r.push({op:l,path:f,value:n(a[h])})}i.length<a.length&&o.push({op:"replace",path:t.concat(["length"]),value:i.length})}(e,t,r,o);case 3:return function(e,n,t,r){var o=e.u,i=e.i,s=0;o.forEach((function(e){if(!i.has(e)){var o=n.concat([s]);t.push({op:"remove",path:o,value:e}),r.unshift({op:l,path:o,value:e})}s++})),s=0,i.forEach((function(e){if(!o.has(e)){var i=n.concat([s]);t.push({op:l,path:i,value:e}),r.unshift({op:"remove",path:i,value:e})}s++}))}(e,t,r,o)}},g:function(e,n,t,r){t.push({op:"replace",path:[],value:n===$?void 0:n}),r.push({op:"replace",path:[],value:e})}})}function B(){function e(e,n){function t(){this.constructor=e}a(e,n),e.prototype=(t.prototype=n.prototype,new t)}function n(e){e.i||(e.N=new Map,e.i=new Map(e.u))}function r(e){e.i||(e.i=new Set,e.u.forEach((function(n){if(o(n)){var t=N(e.A.h,n,e);e.p.set(n,t),e.i.add(t)}else e.i.add(n)})))}function s(e){e.O&&t(3,JSON.stringify(h(e)))}var a=function(e,n){return(a=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)},c=function(){function t(e,n){return this[K]={t:2,l:n,A:n?n.A:v(),M:!1,R:!1,i:void 0,N:void 0,u:e,k:this,C:!1,O:!1},this}e(t,Map);var r=t.prototype;return Object.defineProperty(r,"size",{get:function(){return h(this[K]).size}}),r.has=function(e){return h(this[K]).has(e)},r.set=function(e,t){var r=this[K];return s(r),h(r).has(e)&&h(r).get(e)===t||(n(r),M(r),r.N.set(e,!0),r.i.set(e,t),r.N.set(e,!0)),this},r.delete=function(e){if(!this.has(e))return!1;var t=this[K];return s(t),n(t),M(t),t.u.has(e)?t.N.set(e,!1):t.N.delete(e),t.i.delete(e),!0},r.clear=function(){var e=this[K];s(e),h(e).size&&(n(e),M(e),e.N=new Map,i(e.u,(function(n){e.N.set(n,!1)})),e.i.clear())},r.forEach=function(e,n){var t=this;h(this[K]).forEach((function(r,o){e.call(n,t.get(o),o,t)}))},r.get=function(e){var t=this[K];s(t);var r=h(t).get(e);if(t.R||!o(r))return r;if(r!==t.u.get(e))return r;var i=N(t.A.h,r,t);return n(t),t.i.set(e,i),i},r.keys=function(){return h(this[K]).keys()},r.values=function(){var e,n=this,t=this.keys();return(e={})[Y]=function(){return n.values()},e.next=function(){var e=t.next();return e.done?e:{done:!1,value:n.get(e.value)}},e},r.entries=function(){var e,n=this,t=this.keys();return(e={})[Y]=function(){return n.entries()},e.next=function(){var e=t.next();if(e.done)return e;var r=n.get(e.value);return{done:!1,value:[e.value,r]}},e},r[Y]=function(){return this.entries()},t}(),l=function(){function n(e,n){return this[K]={t:3,l:n,A:n?n.A:v(),M:!1,R:!1,i:void 0,u:e,k:this,p:new Map,O:!1,C:!1},this}e(n,Set);var t=n.prototype;return Object.defineProperty(t,"size",{get:function(){return h(this[K]).size}}),t.has=function(e){var n=this[K];return s(n),n.i?!!n.i.has(e)||!(!n.p.has(e)||!n.i.has(n.p.get(e))):n.u.has(e)},t.add=function(e){var n=this[K];return s(n),this.has(e)||(r(n),M(n),n.i.add(e)),this},t.delete=function(e){if(!this.has(e))return!1;var n=this[K];return s(n),r(n),M(n),n.i.delete(e)||!!n.p.has(e)&&n.i.delete(n.p.get(e))},t.clear=function(){var e=this[K];s(e),h(e).size&&(r(e),M(e),e.i.clear())},t.values=function(){var e=this[K];return s(e),r(e),e.i.values()},t.entries=function(){var e=this[K];return s(e),r(e),e.i.entries()},t.keys=function(){return this.values()},t[Y]=function(){return this.values()},t.forEach=function(e,n){for(var t=this.values(),r=t.next();!r.done;)e.call(n,r.value,r.value,this),r=t.next()},n}();b("MapSet",{K:function(e,n){return new c(e,n)},$:function(e,n){return new l(e,n)}})}var U;Object.defineProperty(n,"__esModule",{value:!0});var W,H="undefined"!=typeof Symbol&&"symbol"==typeof Symbol("x"),q="undefined"!=typeof Map,V="undefined"!=typeof Set,z="undefined"!=typeof Proxy&&void 0!==Proxy.revocable&&"undefined"!=typeof Reflect,$=H?Symbol.for("immer-nothing"):((U={})["immer-nothing"]=!0,U),G=H?Symbol.for("immer-draftable"):"__$immer_draftable",K=H?Symbol.for("immer-state"):"__$immer_state",Y="undefined"!=typeof Symbol&&Symbol.iterator||"@@iterator",X=""+Object.prototype.constructor,J="undefined"!=typeof Reflect&&Reflect.ownKeys?Reflect.ownKeys:void 0!==Object.getOwnPropertySymbols?function(e){return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))}:Object.getOwnPropertyNames,Q=Object.getOwnPropertyDescriptors||function(e){var n={};return J(e).forEach((function(t){n[t]=Object.getOwnPropertyDescriptor(e,t)})),n},Z={},ee={get:function(e,n){if(n===K)return e;var t=h(e);if(!a(t,n))return function(e,n,t){var r,o=D(n,t);return o?"value"in o?o.value:null===(r=o.get)||void 0===r?void 0:r.call(e.k):void 0}(e,t,n);var r=t[n];return e.R||!o(r)?r:r===P(e.u,n)?(x(e),e.i[n]=N(e.A.h,r,e)):r},has:function(e,n){return n in h(e)},ownKeys:function(e){return Reflect.ownKeys(h(e))},set:function(e,n,t){var r=D(h(e),n);if(null==r?void 0:r.set)return r.set.call(e.k,t),!0;if(!e.M){var o=P(h(e),n),i=null==o?void 0:o[K];if(i&&i.u===t)return e.i[n]=t,e.N[n]=!1,!0;if(d(t,o)&&(void 0!==t||a(e.u,n)))return!0;x(e),M(e)}return e.i[n]===t&&(void 0!==t||n in e.i)||Number.isNaN(t)&&Number.isNaN(e.i[n])||(e.i[n]=t,e.N[n]=!0),!0},deleteProperty:function(e,n){return void 0!==P(e.u,n)||n in e.u?(e.N[n]=!1,x(e),M(e)):delete e.N[n],e.i&&delete e.i[n],!0},getOwnPropertyDescriptor:function(e,n){var t=h(e),r=Reflect.getOwnPropertyDescriptor(t,n);return r?{writable:!0,configurable:1!==e.t||"length"!==n,enumerable:r.enumerable,value:t[n]}:r},defineProperty:function(){t(11)},getPrototypeOf:function(e){return Object.getPrototypeOf(e.u)},setPrototypeOf:function(){t(12)}},ne={};i(ee,(function(e,n){ne[e]=function(){return arguments[0]=arguments[0][0],n.apply(this,arguments)}})),ne.deleteProperty=function(e,n){return ne.set.call(this,e,n,void 0)},ne.set=function(e,n,t){return ee.set.call(this,e[0],n,t,e[0])};var te=function(){function e(e){var n=this;this.S=z,this.D=!0,this.produce=function(e,r,i){if("function"==typeof e&&"function"!=typeof r){var s=r;r=e;var a=n;return function(e){var n=this;void 0===e&&(e=s);for(var t=arguments.length,o=Array(t>1?t-1:0),i=1;i<t;i++)o[i-1]=arguments[i];return a.produce(e,(function(e){var t;return(t=r).call.apply(t,[n,e].concat(o))}))}}var c;if("function"!=typeof r&&t(6),void 0!==i&&"function"!=typeof i&&t(7),o(e)){var l=T(n),d=N(n,e,void 0),u=!0;try{c=r(d),u=!1}finally{u?E(l):S(l)}return"undefined"!=typeof Promise&&c instanceof Promise?c.then((function(e){return w(l,i),k(e,l)}),(function(e){throw E(l),e})):(w(l,i),k(c,l))}if(!e||"object"!=typeof e){if(void 0===(c=r(e))&&(c=e),c===$&&(c=void 0),n.D&&m(c,!0),i){var p=[],h=[];_("Patches").g(e,c,p,h),i(p,h)}return c}t(21,e)},this.produceWithPatches=function(e,t){if("function"==typeof e)return function(t){for(var r=arguments.length,o=Array(r>1?r-1:0),i=1;i<r;i++)o[i-1]=arguments[i];return n.produceWithPatches(t,(function(n){return e.apply(void 0,[n].concat(o))}))};var r,o,i=n.produce(e,t,(function(e,n){r=e,o=n}));return"undefined"!=typeof Promise&&i instanceof Promise?i.then((function(e){return[e,r,o]})):[i,r,o]},"boolean"==typeof(null==e?void 0:e.useProxies)&&this.setUseProxies(e.useProxies),"boolean"==typeof(null==e?void 0:e.autoFreeze)&&this.setAutoFreeze(e.autoFreeze)}var n=e.prototype;return n.createDraft=function(e){o(e)||t(8),r(e)&&(e=A(e));var n=T(this),i=N(this,e,void 0);return i[K].C=!0,S(n),i},n.finishDraft=function(e,n){var t=(e&&e[K]).A;return w(t,n),k(void 0,t)},n.setAutoFreeze=function(e){this.D=e},n.setUseProxies=function(e){e&&!z&&t(20),this.S=e},n.applyPatches=function(e,n){var t;for(t=n.length-1;t>=0;t--){var o=n[t];if(0===o.path.length&&"replace"===o.op){e=o.value;break}}t>-1&&(n=n.slice(t+1));var i=_("Patches").W;return r(e)?i(e,n):this.produce(e,(function(e){return i(e,n)}))},e}(),re=new te,oe=re.produce,ie=re.produceWithPatches.bind(re),se=re.setAutoFreeze.bind(re),ae=re.setUseProxies.bind(re),ce=re.applyPatches.bind(re),le=re.createDraft.bind(re),de=re.finishDraft.bind(re);n.Immer=te,n.applyPatches=ce,n.castDraft=function(e){return e},n.castImmutable=function(e){return e},n.createDraft=le,n.current=A,n.default=oe,n.enableAllPlugins=function(){L(),B(),j()},n.enableES5=L,n.enableMapSet=B,n.enablePatches=j,n.finishDraft=de,n.freeze=m,n.immerable=G,n.isDraft=r,n.isDraftable=o,n.nothing=$,n.original=function(e){return r(e)||t(23,e),e[K].u},n.produce=oe,n.produceWithPatches=ie,n.setAutoFreeze=se,n.setUseProxies=ae},30412:(e,n,t)=>{"use strict";e.exports=t(50340)},34406:e=>{var n,t,r=e.exports={};function o(){throw new Error("setTimeout has not been defined")}function i(){throw new Error("clearTimeout has not been defined")}function s(e){if(n===setTimeout)return setTimeout(e,0);if((n===o||!n)&&setTimeout)return n=setTimeout,setTimeout(e,0);try{return n(e,0)}catch(t){try{return n.call(null,e,0)}catch(t){return n.call(this,e,0)}}}!function(){try{n="function"==typeof setTimeout?setTimeout:o}catch(e){n=o}try{t="function"==typeof clearTimeout?clearTimeout:i}catch(e){t=i}}();var a,c=[],l=!1,d=-1;function u(){l&&a&&(l=!1,a.length?c=a.concat(c):d=-1,c.length&&p())}function p(){if(!l){var e=s(u);l=!0;for(var n=c.length;n;){for(a=c,c=[];++d<n;)a&&a[d].run();d=-1,n=c.length}a=null,l=!1,function(e){if(t===clearTimeout)return clearTimeout(e);if((t===i||!t)&&clearTimeout)return t=clearTimeout,clearTimeout(e);try{return t(e)}catch(n){try{return t.call(null,e)}catch(n){return t.call(this,e)}}}(e)}}function h(e,n){this.fun=e,this.array=n}function f(){}r.nextTick=function(e){var n=new Array(arguments.length-1);if(arguments.length>1)for(var t=1;t<arguments.length;t++)n[t-1]=arguments[t];c.push(new h(e,n)),1!==c.length||l||s(p)},h.prototype.run=function(){this.fun.apply(null,this.array)},r.title="browser",r.browser=!0,r.env={},r.argv=[],r.version="",r.versions={},r.on=f,r.addListener=f,r.once=f,r.off=f,r.removeListener=f,r.removeAllListeners=f,r.emit=f,r.prependListener=f,r.prependOnceListener=f,r.listeners=function(e){return[]},r.binding=function(e){throw new Error("process.binding is not supported")},r.cwd=function(){return"/"},r.chdir=function(e){throw new Error("process.chdir is not supported")},r.umask=function(){return 0}},30126:(e,n,t)=>{"use strict";function r(){let e,n;return{promise:new Promise(((t,r)=>{e=t,n=r})),resolve:e,reject:n}}t.d(n,{g:()=>r})},48074:(e,n,t)=>{"use strict";t.r(n),t.d(n,{deferred:()=>r.g,retry:()=>a,sleep:()=>o,timeout:()=>l,waitFor:()=>c});var r=t(30126);function o(e){return new Promise((n=>setTimeout(n,e)))}const i={retries:3,delay:0,timeout:0},s=!!Error.captureStackTrace;async function a(e,n){const{retries:t,delay:r,timeout:a}={...i,...n};let c,l,d=!1,u=`timed out after ${a}ms`;if(s){const e={stack:""};Error.captureStackTrace(e),u+=`\n${e.stack}`}const p=new Promise(((e,n)=>{a>0&&(l=setTimeout((()=>{d=!0,c||(c=new Error(u)),n()}),a))})),h=t+1;let f=0;do{f++;try{const n=e();n instanceof Promise&&n.catch((e=>c=e||c));const t=await Promise.race([n,p]);return clearTimeout(l),t}catch(e){c=e||c}if(r>0)try{await Promise.race([o(r),p])}catch{}}while(!d&&f<h);throw clearTimeout(l),c||new Error(`failed after ${f} tries`)}function c(e,n){return a(e,{delay:10,timeout:1e3,retries:1/0,...n})}function l(e,n,t=`timed out after ${n}ms`){return new Promise(((r,o)=>{const i=setTimeout((()=>o(new Error("function"==typeof t?t():t))),n);e.then((e=>{clearTimeout(i),r(e)}),(e=>{clearTimeout(i),o(e)}))}))}},3654:(e,n,t)=>{"use strict";t.d(n,{Z:()=>r});const r="module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 206);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"react\");\n\n/***/ }),\n\n/***/ 1:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return CHROME_WEBSTORE_EXTENSION_ID; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return INTERNAL_EXTENSION_ID; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return LOCAL_EXTENSION_ID; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"G\", function() { return __DEBUG__; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"H\", function() { return __PERFORMANCE_PROFILE__; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"y\", function() { return TREE_OPERATION_ADD; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"z\", function() { return TREE_OPERATION_REMOVE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"B\", function() { return TREE_OPERATION_REORDER_CHILDREN; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"E\", function() { return TREE_OPERATION_UPDATE_TREE_BASE_DURATION; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"D\", function() { return TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"A\", function() { return TREE_OPERATION_REMOVE_ROOT; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"C\", function() { return TREE_OPERATION_SET_SUBTREE_MODE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"r\", function() { return PROFILING_FLAG_BASIC_SUPPORT; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"s\", function() { return PROFILING_FLAG_TIMELINE_SUPPORT; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"i\", function() { return LOCAL_STORAGE_DEFAULT_TAB_KEY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return LOCAL_STORAGE_COMPONENT_FILTER_PREFERENCES_KEY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"u\", function() { return SESSION_STORAGE_LAST_SELECTION_KEY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"k\", function() { return LOCAL_STORAGE_OPEN_IN_EDITOR_URL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"l\", function() { return LOCAL_STORAGE_PARSE_HOOK_NAMES_KEY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"v\", function() { return SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"w\", function() { return SESSION_STORAGE_RELOAD_AND_PROFILE_KEY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"n\", function() { return LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"g\", function() { return LOCAL_STORAGE_BROWSER_THEME; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"m\", function() { return LOCAL_STORAGE_SHOULD_APPEND_COMPONENT_STACK_KEY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"o\", function() { return LOCAL_STORAGE_SHOW_INLINE_WARNINGS_AND_ERRORS_KEY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"p\", function() { return LOCAL_STORAGE_TRACE_UPDATES_ENABLED_KEY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"j\", function() { return LOCAL_STORAGE_HIDE_CONSOLE_LOGS_IN_STRICT_MODE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"q\", function() { return PROFILER_EXPORT_VERSION; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return CHANGE_LOG_URL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"F\", function() { return UNSUPPORTED_VERSION_URL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"t\", function() { return REACT_DEVTOOLS_WORKPLACE_URL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"x\", function() { return THEME_STYLES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return COMFORTABLE_LINE_HEIGHT; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return COMPACT_LINE_HEIGHT; });\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst CHROME_WEBSTORE_EXTENSION_ID = 'fmkadmapgofadopljbjfkapdkoienihi';\nconst INTERNAL_EXTENSION_ID = 'dnjnjgbfilfphmojnmhliehogmojhclc';\nconst LOCAL_EXTENSION_ID = 'ikiahnapldjmdmpkmfhjdjilojjhgcbf'; // Flip this flag to true to enable verbose console debug logging.\n\nconst __DEBUG__ = false; // Flip this flag to true to enable performance.mark() and performance.measure() timings.\n\nconst __PERFORMANCE_PROFILE__ = false;\nconst TREE_OPERATION_ADD = 1;\nconst TREE_OPERATION_REMOVE = 2;\nconst TREE_OPERATION_REORDER_CHILDREN = 3;\nconst TREE_OPERATION_UPDATE_TREE_BASE_DURATION = 4;\nconst TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS = 5;\nconst TREE_OPERATION_REMOVE_ROOT = 6;\nconst TREE_OPERATION_SET_SUBTREE_MODE = 7;\nconst PROFILING_FLAG_BASIC_SUPPORT = 0b01;\nconst PROFILING_FLAG_TIMELINE_SUPPORT = 0b10;\nconst LOCAL_STORAGE_DEFAULT_TAB_KEY = 'React::DevTools::defaultTab';\nconst LOCAL_STORAGE_COMPONENT_FILTER_PREFERENCES_KEY = 'React::DevTools::componentFilters';\nconst SESSION_STORAGE_LAST_SELECTION_KEY = 'React::DevTools::lastSelection';\nconst LOCAL_STORAGE_OPEN_IN_EDITOR_URL = 'React::DevTools::openInEditorUrl';\nconst LOCAL_STORAGE_PARSE_HOOK_NAMES_KEY = 'React::DevTools::parseHookNames';\nconst SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY = 'React::DevTools::recordChangeDescriptions';\nconst SESSION_STORAGE_RELOAD_AND_PROFILE_KEY = 'React::DevTools::reloadAndProfile';\nconst LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS = 'React::DevTools::breakOnConsoleErrors';\nconst LOCAL_STORAGE_BROWSER_THEME = 'React::DevTools::theme';\nconst LOCAL_STORAGE_SHOULD_APPEND_COMPONENT_STACK_KEY = 'React::DevTools::appendComponentStack';\nconst LOCAL_STORAGE_SHOW_INLINE_WARNINGS_AND_ERRORS_KEY = 'React::DevTools::showInlineWarningsAndErrors';\nconst LOCAL_STORAGE_TRACE_UPDATES_ENABLED_KEY = 'React::DevTools::traceUpdatesEnabled';\nconst LOCAL_STORAGE_HIDE_CONSOLE_LOGS_IN_STRICT_MODE = 'React::DevTools::hideConsoleLogsInStrictMode';\nconst PROFILER_EXPORT_VERSION = 5;\nconst CHANGE_LOG_URL = 'https://github.com/facebook/react/blob/main/packages/react-devtools/CHANGELOG.md';\nconst UNSUPPORTED_VERSION_URL = 'https://reactjs.org/blog/2019/08/15/new-react-devtools.html#how-do-i-get-the-old-version-back';\nconst REACT_DEVTOOLS_WORKPLACE_URL = 'https://fburl.com/react-devtools-workplace-group';\nconst THEME_STYLES = {\n  light: {\n    '--color-attribute-name': '#ef6632',\n    '--color-attribute-name-not-editable': '#23272f',\n    '--color-attribute-name-inverted': 'rgba(255, 255, 255, 0.7)',\n    '--color-attribute-value': '#1a1aa6',\n    '--color-attribute-value-inverted': '#ffffff',\n    '--color-attribute-editable-value': '#1a1aa6',\n    '--color-background': '#ffffff',\n    '--color-background-hover': 'rgba(0, 136, 250, 0.1)',\n    '--color-background-inactive': '#e5e5e5',\n    '--color-background-invalid': '#fff0f0',\n    '--color-background-selected': '#0088fa',\n    '--color-button-background': '#ffffff',\n    '--color-button-background-focus': '#ededed',\n    '--color-button': '#5f6673',\n    '--color-button-disabled': '#cfd1d5',\n    '--color-button-active': '#0088fa',\n    '--color-button-focus': '#23272f',\n    '--color-button-hover': '#23272f',\n    '--color-border': '#eeeeee',\n    '--color-commit-did-not-render-fill': '#cfd1d5',\n    '--color-commit-did-not-render-fill-text': '#000000',\n    '--color-commit-did-not-render-pattern': '#cfd1d5',\n    '--color-commit-did-not-render-pattern-text': '#333333',\n    '--color-commit-gradient-0': '#37afa9',\n    '--color-commit-gradient-1': '#63b19e',\n    '--color-commit-gradient-2': '#80b393',\n    '--color-commit-gradient-3': '#97b488',\n    '--color-commit-gradient-4': '#abb67d',\n    '--color-commit-gradient-5': '#beb771',\n    '--color-commit-gradient-6': '#cfb965',\n    '--color-commit-gradient-7': '#dfba57',\n    '--color-commit-gradient-8': '#efbb49',\n    '--color-commit-gradient-9': '#febc38',\n    '--color-commit-gradient-text': '#000000',\n    '--color-component-name': '#6a51b2',\n    '--color-component-name-inverted': '#ffffff',\n    '--color-component-badge-background': 'rgba(0, 0, 0, 0.1)',\n    '--color-component-badge-background-inverted': 'rgba(255, 255, 255, 0.25)',\n    '--color-component-badge-count': '#777d88',\n    '--color-component-badge-count-inverted': 'rgba(255, 255, 255, 0.7)',\n    '--color-console-error-badge-text': '#ffffff',\n    '--color-console-error-background': '#fff0f0',\n    '--color-console-error-border': '#ffd6d6',\n    '--color-console-error-icon': '#eb3941',\n    '--color-console-error-text': '#fe2e31',\n    '--color-console-warning-badge-text': '#000000',\n    '--color-console-warning-background': '#fffbe5',\n    '--color-console-warning-border': '#fff5c1',\n    '--color-console-warning-icon': '#f4bd00',\n    '--color-console-warning-text': '#64460c',\n    '--color-context-background': 'rgba(0,0,0,.9)',\n    '--color-context-background-hover': 'rgba(255, 255, 255, 0.1)',\n    '--color-context-background-selected': '#178fb9',\n    '--color-context-border': '#3d424a',\n    '--color-context-text': '#ffffff',\n    '--color-context-text-selected': '#ffffff',\n    '--color-dim': '#777d88',\n    '--color-dimmer': '#cfd1d5',\n    '--color-dimmest': '#eff0f1',\n    '--color-error-background': 'hsl(0, 100%, 97%)',\n    '--color-error-border': 'hsl(0, 100%, 92%)',\n    '--color-error-text': '#ff0000',\n    '--color-expand-collapse-toggle': '#777d88',\n    '--color-link': '#0000ff',\n    '--color-modal-background': 'rgba(255, 255, 255, 0.75)',\n    '--color-bridge-version-npm-background': '#eff0f1',\n    '--color-bridge-version-npm-text': '#000000',\n    '--color-bridge-version-number': '#0088fa',\n    '--color-primitive-hook-badge-background': '#e5e5e5',\n    '--color-primitive-hook-badge-text': '#5f6673',\n    '--color-record-active': '#fc3a4b',\n    '--color-record-hover': '#3578e5',\n    '--color-record-inactive': '#0088fa',\n    '--color-resize-bar': '#eeeeee',\n    '--color-resize-bar-active': '#dcdcdc',\n    '--color-resize-bar-border': '#d1d1d1',\n    '--color-resize-bar-dot': '#333333',\n    '--color-timeline-internal-module': '#d1d1d1',\n    '--color-timeline-internal-module-hover': '#c9c9c9',\n    '--color-timeline-internal-module-text': '#444',\n    '--color-timeline-native-event': '#ccc',\n    '--color-timeline-native-event-hover': '#aaa',\n    '--color-timeline-network-primary': '#fcf3dc',\n    '--color-timeline-network-primary-hover': '#f0e7d1',\n    '--color-timeline-network-secondary': '#efc457',\n    '--color-timeline-network-secondary-hover': '#e3ba52',\n    '--color-timeline-priority-background': '#f6f6f6',\n    '--color-timeline-priority-border': '#eeeeee',\n    '--color-timeline-user-timing': '#c9cacd',\n    '--color-timeline-user-timing-hover': '#93959a',\n    '--color-timeline-react-idle': '#d3e5f6',\n    '--color-timeline-react-idle-hover': '#c3d9ef',\n    '--color-timeline-react-render': '#9fc3f3',\n    '--color-timeline-react-render-hover': '#83afe9',\n    '--color-timeline-react-render-text': '#11365e',\n    '--color-timeline-react-commit': '#c88ff0',\n    '--color-timeline-react-commit-hover': '#b281d6',\n    '--color-timeline-react-commit-text': '#3e2c4a',\n    '--color-timeline-react-layout-effects': '#b281d6',\n    '--color-timeline-react-layout-effects-hover': '#9d71bd',\n    '--color-timeline-react-layout-effects-text': '#3e2c4a',\n    '--color-timeline-react-passive-effects': '#b281d6',\n    '--color-timeline-react-passive-effects-hover': '#9d71bd',\n    '--color-timeline-react-passive-effects-text': '#3e2c4a',\n    '--color-timeline-react-schedule': '#9fc3f3',\n    '--color-timeline-react-schedule-hover': '#2683E2',\n    '--color-timeline-react-suspense-rejected': '#f1cc14',\n    '--color-timeline-react-suspense-rejected-hover': '#ffdf37',\n    '--color-timeline-react-suspense-resolved': '#a6e59f',\n    '--color-timeline-react-suspense-resolved-hover': '#89d281',\n    '--color-timeline-react-suspense-unresolved': '#c9cacd',\n    '--color-timeline-react-suspense-unresolved-hover': '#93959a',\n    '--color-timeline-thrown-error': '#ee1638',\n    '--color-timeline-thrown-error-hover': '#da1030',\n    '--color-timeline-text-color': '#000000',\n    '--color-timeline-text-dim-color': '#ccc',\n    '--color-timeline-react-work-border': '#eeeeee',\n    '--color-search-match': 'yellow',\n    '--color-search-match-current': '#f7923b',\n    '--color-selected-tree-highlight-active': 'rgba(0, 136, 250, 0.1)',\n    '--color-selected-tree-highlight-inactive': 'rgba(0, 0, 0, 0.05)',\n    '--color-scroll-caret': 'rgba(150, 150, 150, 0.5)',\n    '--color-tab-selected-border': '#0088fa',\n    '--color-text': '#000000',\n    '--color-text-invalid': '#ff0000',\n    '--color-text-selected': '#ffffff',\n    '--color-toggle-background-invalid': '#fc3a4b',\n    '--color-toggle-background-on': '#0088fa',\n    '--color-toggle-background-off': '#cfd1d5',\n    '--color-toggle-text': '#ffffff',\n    '--color-warning-background': '#fb3655',\n    '--color-warning-background-hover': '#f82042',\n    '--color-warning-text-color': '#ffffff',\n    '--color-warning-text-color-inverted': '#fd4d69',\n    // The styles below should be kept in sync with 'root.css'\n    // They are repeated there because they're used by e.g. tooltips or context menus\n    // which get rendered outside of the DOM subtree (where normal theme/styles are written).\n    '--color-scroll-thumb': '#c2c2c2',\n    '--color-scroll-track': '#fafafa',\n    '--color-tooltip-background': 'rgba(0, 0, 0, 0.9)',\n    '--color-tooltip-text': '#ffffff'\n  },\n  dark: {\n    '--color-attribute-name': '#9d87d2',\n    '--color-attribute-name-not-editable': '#ededed',\n    '--color-attribute-name-inverted': '#282828',\n    '--color-attribute-value': '#cedae0',\n    '--color-attribute-value-inverted': '#ffffff',\n    '--color-attribute-editable-value': 'yellow',\n    '--color-background': '#282c34',\n    '--color-background-hover': 'rgba(255, 255, 255, 0.1)',\n    '--color-background-inactive': '#3d424a',\n    '--color-background-invalid': '#5c0000',\n    '--color-background-selected': '#178fb9',\n    '--color-button-background': '#282c34',\n    '--color-button-background-focus': '#3d424a',\n    '--color-button': '#afb3b9',\n    '--color-button-active': '#61dafb',\n    '--color-button-disabled': '#4f5766',\n    '--color-button-focus': '#a2e9fc',\n    '--color-button-hover': '#ededed',\n    '--color-border': '#3d424a',\n    '--color-commit-did-not-render-fill': '#777d88',\n    '--color-commit-did-not-render-fill-text': '#000000',\n    '--color-commit-did-not-render-pattern': '#666c77',\n    '--color-commit-did-not-render-pattern-text': '#ffffff',\n    '--color-commit-gradient-0': '#37afa9',\n    '--color-commit-gradient-1': '#63b19e',\n    '--color-commit-gradient-2': '#80b393',\n    '--color-commit-gradient-3': '#97b488',\n    '--color-commit-gradient-4': '#abb67d',\n    '--color-commit-gradient-5': '#beb771',\n    '--color-commit-gradient-6': '#cfb965',\n    '--color-commit-gradient-7': '#dfba57',\n    '--color-commit-gradient-8': '#efbb49',\n    '--color-commit-gradient-9': '#febc38',\n    '--color-commit-gradient-text': '#000000',\n    '--color-component-name': '#61dafb',\n    '--color-component-name-inverted': '#282828',\n    '--color-component-badge-background': 'rgba(255, 255, 255, 0.25)',\n    '--color-component-badge-background-inverted': 'rgba(0, 0, 0, 0.25)',\n    '--color-component-badge-count': '#8f949d',\n    '--color-component-badge-count-inverted': 'rgba(255, 255, 255, 0.7)',\n    '--color-console-error-badge-text': '#000000',\n    '--color-console-error-background': '#290000',\n    '--color-console-error-border': '#5c0000',\n    '--color-console-error-icon': '#eb3941',\n    '--color-console-error-text': '#fc7f7f',\n    '--color-console-warning-badge-text': '#000000',\n    '--color-console-warning-background': '#332b00',\n    '--color-console-warning-border': '#665500',\n    '--color-console-warning-icon': '#f4bd00',\n    '--color-console-warning-text': '#f5f2ed',\n    '--color-context-background': 'rgba(255,255,255,.95)',\n    '--color-context-background-hover': 'rgba(0, 136, 250, 0.1)',\n    '--color-context-background-selected': '#0088fa',\n    '--color-context-border': '#eeeeee',\n    '--color-context-text': '#000000',\n    '--color-context-text-selected': '#ffffff',\n    '--color-dim': '#8f949d',\n    '--color-dimmer': '#777d88',\n    '--color-dimmest': '#4f5766',\n    '--color-error-background': '#200',\n    '--color-error-border': '#900',\n    '--color-error-text': '#f55',\n    '--color-expand-collapse-toggle': '#8f949d',\n    '--color-link': '#61dafb',\n    '--color-modal-background': 'rgba(0, 0, 0, 0.75)',\n    '--color-bridge-version-npm-background': 'rgba(0, 0, 0, 0.25)',\n    '--color-bridge-version-npm-text': '#ffffff',\n    '--color-bridge-version-number': 'yellow',\n    '--color-primitive-hook-badge-background': 'rgba(0, 0, 0, 0.25)',\n    '--color-primitive-hook-badge-text': 'rgba(255, 255, 255, 0.7)',\n    '--color-record-active': '#fc3a4b',\n    '--color-record-hover': '#a2e9fc',\n    '--color-record-inactive': '#61dafb',\n    '--color-resize-bar': '#282c34',\n    '--color-resize-bar-active': '#31363f',\n    '--color-resize-bar-border': '#3d424a',\n    '--color-resize-bar-dot': '#cfd1d5',\n    '--color-timeline-internal-module': '#303542',\n    '--color-timeline-internal-module-hover': '#363b4a',\n    '--color-timeline-internal-module-text': '#7f8899',\n    '--color-timeline-native-event': '#b2b2b2',\n    '--color-timeline-native-event-hover': '#949494',\n    '--color-timeline-network-primary': '#fcf3dc',\n    '--color-timeline-network-primary-hover': '#e3dbc5',\n    '--color-timeline-network-secondary': '#efc457',\n    '--color-timeline-network-secondary-hover': '#d6af4d',\n    '--color-timeline-priority-background': '#1d2129',\n    '--color-timeline-priority-border': '#282c34',\n    '--color-timeline-user-timing': '#c9cacd',\n    '--color-timeline-user-timing-hover': '#93959a',\n    '--color-timeline-react-idle': '#3d485b',\n    '--color-timeline-react-idle-hover': '#465269',\n    '--color-timeline-react-render': '#2683E2',\n    '--color-timeline-react-render-hover': '#1a76d4',\n    '--color-timeline-react-render-text': '#11365e',\n    '--color-timeline-react-commit': '#731fad',\n    '--color-timeline-react-commit-hover': '#611b94',\n    '--color-timeline-react-commit-text': '#e5c1ff',\n    '--color-timeline-react-layout-effects': '#611b94',\n    '--color-timeline-react-layout-effects-hover': '#51167a',\n    '--color-timeline-react-layout-effects-text': '#e5c1ff',\n    '--color-timeline-react-passive-effects': '#611b94',\n    '--color-timeline-react-passive-effects-hover': '#51167a',\n    '--color-timeline-react-passive-effects-text': '#e5c1ff',\n    '--color-timeline-react-schedule': '#2683E2',\n    '--color-timeline-react-schedule-hover': '#1a76d4',\n    '--color-timeline-react-suspense-rejected': '#f1cc14',\n    '--color-timeline-react-suspense-rejected-hover': '#e4c00f',\n    '--color-timeline-react-suspense-resolved': '#a6e59f',\n    '--color-timeline-react-suspense-resolved-hover': '#89d281',\n    '--color-timeline-react-suspense-unresolved': '#c9cacd',\n    '--color-timeline-react-suspense-unresolved-hover': '#93959a',\n    '--color-timeline-thrown-error': '#fb3655',\n    '--color-timeline-thrown-error-hover': '#f82042',\n    '--color-timeline-text-color': '#282c34',\n    '--color-timeline-text-dim-color': '#555b66',\n    '--color-timeline-react-work-border': '#3d424a',\n    '--color-search-match': 'yellow',\n    '--color-search-match-current': '#f7923b',\n    '--color-selected-tree-highlight-active': 'rgba(23, 143, 185, 0.15)',\n    '--color-selected-tree-highlight-inactive': 'rgba(255, 255, 255, 0.05)',\n    '--color-scroll-caret': '#4f5766',\n    '--color-shadow': 'rgba(0, 0, 0, 0.5)',\n    '--color-tab-selected-border': '#178fb9',\n    '--color-text': '#ffffff',\n    '--color-text-invalid': '#ff8080',\n    '--color-text-selected': '#ffffff',\n    '--color-toggle-background-invalid': '#fc3a4b',\n    '--color-toggle-background-on': '#178fb9',\n    '--color-toggle-background-off': '#777d88',\n    '--color-toggle-text': '#ffffff',\n    '--color-warning-background': '#ee1638',\n    '--color-warning-background-hover': '#da1030',\n    '--color-warning-text-color': '#ffffff',\n    '--color-warning-text-color-inverted': '#ee1638',\n    // The styles below should be kept in sync with 'root.css'\n    // They are repeated there because they're used by e.g. tooltips or context menus\n    // which get rendered outside of the DOM subtree (where normal theme/styles are written).\n    '--color-scroll-thumb': '#afb3b9',\n    '--color-scroll-track': '#313640',\n    '--color-tooltip-background': 'rgba(255, 255, 255, 0.95)',\n    '--color-tooltip-text': '#000000'\n  },\n  compact: {\n    '--font-size-monospace-small': '9px',\n    '--font-size-monospace-normal': '11px',\n    '--font-size-monospace-large': '15px',\n    '--font-size-sans-small': '10px',\n    '--font-size-sans-normal': '12px',\n    '--font-size-sans-large': '14px',\n    '--line-height-data': '18px'\n  },\n  comfortable: {\n    '--font-size-monospace-small': '10px',\n    '--font-size-monospace-normal': '13px',\n    '--font-size-monospace-large': '17px',\n    '--font-size-sans-small': '12px',\n    '--font-size-sans-normal': '14px',\n    '--font-size-sans-large': '16px',\n    '--line-height-data': '22px'\n  }\n}; // HACK\n//\n// Sometimes the inline target is rendered before root styles are applied,\n// which would result in e.g. NaN itemSize being passed to react-window list.\n\nconst COMFORTABLE_LINE_HEIGHT = parseInt(THEME_STYLES.comfortable['--line-height-data'], 10);\nconst COMPACT_LINE_HEIGHT = parseInt(THEME_STYLES.compact['--line-height-data'], 10);\n\n\n/***/ }),\n\n/***/ 10:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return localStorageGetItem; });\n/* unused harmony export localStorageRemoveItem */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return localStorageSetItem; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return sessionStorageGetItem; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return sessionStorageRemoveItem; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return sessionStorageSetItem; });\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction localStorageGetItem(key) {\n  try {\n    return localStorage.getItem(key);\n  } catch (error) {\n    return null;\n  }\n}\nfunction localStorageRemoveItem(key) {\n  try {\n    localStorage.removeItem(key);\n  } catch (error) {}\n}\nfunction localStorageSetItem(key, value) {\n  try {\n    return localStorage.setItem(key, value);\n  } catch (error) {}\n}\nfunction sessionStorageGetItem(key) {\n  try {\n    return sessionStorage.getItem(key);\n  } catch (error) {\n    return null;\n  }\n}\nfunction sessionStorageRemoveItem(key) {\n  try {\n    sessionStorage.removeItem(key);\n  } catch (error) {}\n}\nfunction sessionStorageSetItem(key, value) {\n  try {\n    return sessionStorage.setItem(key, value);\n  } catch (error) {}\n}\n\n/***/ }),\n\n/***/ 11:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return meta; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return dehydrate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return fillInPath; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return hydrate; });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nconst meta = {\n  inspectable: Symbol('inspectable'),\n  inspected: Symbol('inspected'),\n  name: Symbol('name'),\n  preview_long: Symbol('preview_long'),\n  preview_short: Symbol('preview_short'),\n  readonly: Symbol('readonly'),\n  size: Symbol('size'),\n  type: Symbol('type'),\n  unserializable: Symbol('unserializable')\n};\n// This threshold determines the depth at which the bridge \"dehydrates\" nested data.\n// Dehydration means that we don't serialize the data for e.g. postMessage or stringify,\n// unless the frontend explicitly requests it (e.g. a user clicks to expand a props object).\n//\n// Reducing this threshold will improve the speed of initial component inspection,\n// but may decrease the responsiveness of expanding objects/arrays to inspect further.\nconst LEVEL_THRESHOLD = 2;\n/**\n * Generate the dehydrated metadata for complex object instances\n */\n\nfunction createDehydrated(type, inspectable, data, cleaned, path) {\n  cleaned.push(path);\n  const dehydrated = {\n    inspectable,\n    type,\n    preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ \"d\"])(data, true),\n    preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ \"d\"])(data, false),\n    name: !data.constructor || data.constructor.name === 'Object' ? '' : data.constructor.name\n  };\n\n  if (type === 'array' || type === 'typed_array') {\n    dehydrated.size = data.length;\n  } else if (type === 'object') {\n    dehydrated.size = Object.keys(data).length;\n  }\n\n  if (type === 'iterator' || type === 'typed_array') {\n    dehydrated.readonly = true;\n  }\n\n  return dehydrated;\n}\n/**\n * Strip out complex data (instances, functions, and data nested > LEVEL_THRESHOLD levels deep).\n * The paths of the stripped out objects are appended to the `cleaned` list.\n * On the other side of the barrier, the cleaned list is used to \"re-hydrate\" the cleaned representation into\n * an object with symbols as attributes, so that a sanitized object can be distinguished from a normal object.\n *\n * Input: {\"some\": {\"attr\": fn()}, \"other\": AnInstance}\n * Output: {\n *   \"some\": {\n *     \"attr\": {\"name\": the fn.name, type: \"function\"}\n *   },\n *   \"other\": {\n *     \"name\": \"AnInstance\",\n *     \"type\": \"object\",\n *   },\n * }\n * and cleaned = [[\"some\", \"attr\"], [\"other\"]]\n */\n\n\nfunction dehydrate(data, cleaned, unserializable, path, isPathAllowed, level = 0) {\n  const type = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* getDataType */ \"h\"])(data);\n  let isPathAllowedCheck;\n\n  switch (type) {\n    case 'html_element':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ \"d\"])(data, false),\n        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ \"d\"])(data, true),\n        name: data.tagName,\n        type\n      };\n\n    case 'function':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ \"d\"])(data, false),\n        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ \"d\"])(data, true),\n        name: typeof data.name === 'function' || !data.name ? 'function' : data.name,\n        type\n      };\n\n    case 'string':\n      isPathAllowedCheck = isPathAllowed(path);\n\n      if (isPathAllowedCheck) {\n        return data;\n      } else {\n        return data.length <= 500 ? data : data.slice(0, 500) + '...';\n      }\n\n    case 'bigint':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ \"d\"])(data, false),\n        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ \"d\"])(data, true),\n        name: data.toString(),\n        type\n      };\n\n    case 'symbol':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ \"d\"])(data, false),\n        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ \"d\"])(data, true),\n        name: data.toString(),\n        type\n      };\n    // React Elements aren't very inspector-friendly,\n    // and often contain private fields or circular references.\n\n    case 'react_element':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ \"d\"])(data, false),\n        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ \"d\"])(data, true),\n        name: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* getDisplayNameForReactElement */ \"l\"])(data) || 'Unknown',\n        type\n      };\n    // ArrayBuffers error if you try to inspect them.\n\n    case 'array_buffer':\n    case 'data_view':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ \"d\"])(data, false),\n        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ \"d\"])(data, true),\n        name: type === 'data_view' ? 'DataView' : 'ArrayBuffer',\n        size: data.byteLength,\n        type\n      };\n\n    case 'array':\n      isPathAllowedCheck = isPathAllowed(path);\n\n      if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {\n        return createDehydrated(type, true, data, cleaned, path);\n      }\n\n      return data.map((item, i) => dehydrate(item, cleaned, unserializable, path.concat([i]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1));\n\n    case 'html_all_collection':\n    case 'typed_array':\n    case 'iterator':\n      isPathAllowedCheck = isPathAllowed(path);\n\n      if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {\n        return createDehydrated(type, true, data, cleaned, path);\n      } else {\n        const unserializableValue = {\n          unserializable: true,\n          type: type,\n          readonly: true,\n          size: type === 'typed_array' ? data.length : undefined,\n          preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ \"d\"])(data, false),\n          preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ \"d\"])(data, true),\n          name: !data.constructor || data.constructor.name === 'Object' ? '' : data.constructor.name\n        }; // TRICKY\n        // Don't use [...spread] syntax for this purpose.\n        // This project uses @babel/plugin-transform-spread in \"loose\" mode which only works with Array values.\n        // Other types (e.g. typed arrays, Sets) will not spread correctly.\n\n        Array.from(data).forEach((item, i) => // $FlowFixMe[prop-missing] Unserializable doesn't have an index signature\n        unserializableValue[i] = dehydrate(item, cleaned, unserializable, path.concat([i]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1));\n        unserializable.push(path);\n        return unserializableValue;\n      }\n\n    case 'opaque_iterator':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ \"d\"])(data, false),\n        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ \"d\"])(data, true),\n        name: data[Symbol.toStringTag],\n        type\n      };\n\n    case 'date':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ \"d\"])(data, false),\n        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ \"d\"])(data, true),\n        name: data.toString(),\n        type\n      };\n\n    case 'regexp':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ \"d\"])(data, false),\n        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ \"d\"])(data, true),\n        name: data.toString(),\n        type\n      };\n\n    case 'object':\n      isPathAllowedCheck = isPathAllowed(path);\n\n      if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {\n        return createDehydrated(type, true, data, cleaned, path);\n      } else {\n        const object = {};\n        Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* getAllEnumerableKeys */ \"e\"])(data).forEach(key => {\n          const name = key.toString();\n          object[name] = dehydrate(data[key], cleaned, unserializable, path.concat([name]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);\n        });\n        return object;\n      }\n\n    case 'infinity':\n    case 'nan':\n    case 'undefined':\n      // Some values are lossy when sent through a WebSocket.\n      // We dehydrate+rehydrate them to preserve their type.\n      cleaned.push(path);\n      return {\n        type\n      };\n\n    default:\n      return data;\n  }\n}\nfunction fillInPath(object, data, path, value) {\n  const target = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* getInObject */ \"n\"])(object, path);\n\n  if (target != null) {\n    if (!target[meta.unserializable]) {\n      delete target[meta.inspectable];\n      delete target[meta.inspected];\n      delete target[meta.name];\n      delete target[meta.preview_long];\n      delete target[meta.preview_short];\n      delete target[meta.readonly];\n      delete target[meta.size];\n      delete target[meta.type];\n    }\n  }\n\n  if (value !== null && data.unserializable.length > 0) {\n    const unserializablePath = data.unserializable[0];\n    let isMatch = unserializablePath.length === path.length;\n\n    for (let i = 0; i < path.length; i++) {\n      if (path[i] !== unserializablePath[i]) {\n        isMatch = false;\n        break;\n      }\n    }\n\n    if (isMatch) {\n      upgradeUnserializable(value, value);\n    }\n  }\n\n  Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* setInObject */ \"w\"])(object, path, value);\n}\nfunction hydrate(object, cleaned, unserializable) {\n  cleaned.forEach(path => {\n    const length = path.length;\n    const last = path[length - 1];\n    const parent = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* getInObject */ \"n\"])(object, path.slice(0, length - 1));\n\n    if (!parent || !parent.hasOwnProperty(last)) {\n      return;\n    }\n\n    const value = parent[last];\n\n    if (!value) {\n      return;\n    } else if (value.type === 'infinity') {\n      parent[last] = Infinity;\n    } else if (value.type === 'nan') {\n      parent[last] = NaN;\n    } else if (value.type === 'undefined') {\n      parent[last] = undefined;\n    } else {\n      // Replace the string keys with Symbols so they're non-enumerable.\n      const replaced = {};\n      replaced[meta.inspectable] = !!value.inspectable;\n      replaced[meta.inspected] = false;\n      replaced[meta.name] = value.name;\n      replaced[meta.preview_long] = value.preview_long;\n      replaced[meta.preview_short] = value.preview_short;\n      replaced[meta.size] = value.size;\n      replaced[meta.readonly] = !!value.readonly;\n      replaced[meta.type] = value.type;\n      parent[last] = replaced;\n    }\n  });\n  unserializable.forEach(path => {\n    const length = path.length;\n    const last = path[length - 1];\n    const parent = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* getInObject */ \"n\"])(object, path.slice(0, length - 1));\n\n    if (!parent || !parent.hasOwnProperty(last)) {\n      return;\n    }\n\n    const node = parent[last];\n    const replacement = { ...node\n    };\n    upgradeUnserializable(replacement, node);\n    parent[last] = replacement;\n  });\n  return object;\n}\n\nfunction upgradeUnserializable(destination, source) {\n  Object.defineProperties(destination, {\n    [meta.inspected]: {\n      configurable: true,\n      enumerable: false,\n      value: !!source.inspected\n    },\n    [meta.name]: {\n      configurable: true,\n      enumerable: false,\n      value: source.name\n    },\n    [meta.preview_long]: {\n      configurable: true,\n      enumerable: false,\n      value: source.preview_long\n    },\n    [meta.preview_short]: {\n      configurable: true,\n      enumerable: false,\n      value: source.preview_short\n    },\n    [meta.size]: {\n      configurable: true,\n      enumerable: false,\n      value: source.size\n    },\n    [meta.readonly]: {\n      configurable: true,\n      enumerable: false,\n      value: !!source.readonly\n    },\n    [meta.type]: {\n      configurable: true,\n      enumerable: false,\n      value: source.type\n    },\n    [meta.unserializable]: {\n      configurable: true,\n      enumerable: false,\n      value: !!source.unserializable\n    }\n  });\n  delete destination.inspected;\n  delete destination.name;\n  delete destination.preview_long;\n  delete destination.preview_short;\n  delete destination.size;\n  delete destination.readonly;\n  delete destination.type;\n  delete destination.unserializable;\n}\n\n/***/ }),\n\n/***/ 12:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"a\", function() { return /* binding */ cleanForBridge; });\n__webpack_require__.d(__webpack_exports__, \"b\", function() { return /* binding */ copyToClipboard; });\n__webpack_require__.d(__webpack_exports__, \"c\", function() { return /* binding */ copyWithDelete; });\n__webpack_require__.d(__webpack_exports__, \"d\", function() { return /* binding */ copyWithRename; });\n__webpack_require__.d(__webpack_exports__, \"e\", function() { return /* binding */ copyWithSet; });\n__webpack_require__.d(__webpack_exports__, \"h\", function() { return /* binding */ getEffectDurations; });\n__webpack_require__.d(__webpack_exports__, \"g\", function() { return /* binding */ formatWithStyles; });\n__webpack_require__.d(__webpack_exports__, \"f\", function() { return /* binding */ format; });\n__webpack_require__.d(__webpack_exports__, \"k\", function() { return /* binding */ isSynchronousXHRSupported; });\n__webpack_require__.d(__webpack_exports__, \"i\", function() { return /* binding */ gt; });\n__webpack_require__.d(__webpack_exports__, \"j\", function() { return /* binding */ gte; });\n\n// UNUSED EXPORTS: serializeToString\n\n// EXTERNAL MODULE: /Users/xch/dev/react/node_modules/clipboard-js/clipboard.js\nvar clipboard = __webpack_require__(17);\n\n// CONCATENATED MODULE: /Users/xch/dev/react/node_modules/compare-versions/lib/esm/index.js\n/**\n * Compare [semver](https://semver.org/) version strings to find greater, equal or lesser.\n * This library supports the full semver specification, including comparing versions with different number of digits like `1.0.0`, `1.0`, `1`, and pre-release versions like `1.0.0-alpha`.\n * @param v1 - First version to compare\n * @param v2 - Second version to compare\n * @returns Numeric value compatible with the [Array.sort(fn) interface](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters).\n */\nconst compareVersions = (v1, v2) => {\n  // validate input and split into segments\n  const n1 = validateAndParse(v1);\n  const n2 = validateAndParse(v2); // pop off the patch\n\n  const p1 = n1.pop();\n  const p2 = n2.pop(); // validate numbers\n\n  const r = compareSegments(n1, n2);\n  if (r !== 0) return r; // validate pre-release\n\n  if (p1 && p2) {\n    return compareSegments(p1.split('.'), p2.split('.'));\n  } else if (p1 || p2) {\n    return p1 ? -1 : 1;\n  }\n\n  return 0;\n};\n/**\n * Validate [semver](https://semver.org/) version strings.\n *\n * @param version Version number to validate\n * @returns `true` if the version number is a valid semver version number, `false` otherwise.\n *\n * @example\n * ```\n * validate('1.0.0-rc.1'); // return true\n * validate('1.0-rc.1'); // return false\n * validate('foo'); // return false\n * ```\n */\n\nconst validate = version => typeof version === 'string' && /^[v\\d]/.test(version) && semver.test(version);\n/**\n * Compare [semver](https://semver.org/) version strings using the specified operator.\n *\n * @param v1 First version to compare\n * @param v2 Second version to compare\n * @param operator Allowed arithmetic operator to use\n * @returns `true` if the comparison between the firstVersion and the secondVersion satisfies the operator, `false` otherwise.\n *\n * @example\n * ```\n * compare('10.1.8', '10.0.4', '>'); // return true\n * compare('10.0.1', '10.0.1', '='); // return true\n * compare('10.1.1', '10.2.2', '<'); // return true\n * compare('10.1.1', '10.2.2', '<='); // return true\n * compare('10.1.1', '10.2.2', '>='); // return false\n * ```\n */\n\nconst compare = (v1, v2, operator) => {\n  // validate input operator\n  assertValidOperator(operator); // since result of compareVersions can only be -1 or 0 or 1\n  // a simple map can be used to replace switch\n\n  const res = compareVersions(v1, v2);\n  return operatorResMap[operator].includes(res);\n};\n/**\n * Match [npm semver](https://docs.npmjs.com/cli/v6/using-npm/semver) version range.\n *\n * @param version Version number to match\n * @param range Range pattern for version\n * @returns `true` if the version number is within the range, `false` otherwise.\n *\n * @example\n * ```\n * satisfies('1.1.0', '^1.0.0'); // return true\n * satisfies('1.1.0', '~1.0.0'); // return false\n * ```\n */\n\nconst satisfies = (version, range) => {\n  // if no range operator then \"=\"\n  const m = range.match(/^([<>=~^]+)/);\n  const op = m ? m[1] : '='; // if gt/lt/eq then operator compare\n\n  if (op !== '^' && op !== '~') return compare(version, range, op); // else range of either \"~\" or \"^\" is assumed\n\n  const [v1, v2, v3,, vp] = validateAndParse(version);\n  const [r1, r2, r3,, rp] = validateAndParse(range);\n  const v = [v1, v2, v3];\n  const r = [r1, r2 !== null && r2 !== void 0 ? r2 : 'x', r3 !== null && r3 !== void 0 ? r3 : 'x']; // validate pre-release\n\n  if (rp) {\n    if (!vp) return false;\n    if (compareSegments(v, r) !== 0) return false;\n    if (compareSegments(vp.split('.'), rp.split('.')) === -1) return false;\n  } // first non-zero number\n\n\n  const nonZero = r.findIndex(v => v !== '0') + 1; // pointer to where segments can be >=\n\n  const i = op === '~' ? 2 : nonZero > 1 ? nonZero : 1; // before pointer must be equal\n\n  if (compareSegments(v.slice(0, i), r.slice(0, i)) !== 0) return false; // after pointer must be >=\n\n  if (compareSegments(v.slice(i), r.slice(i)) === -1) return false;\n  return true;\n};\nconst semver = /^[v^~<>=]*?(\\d+)(?:\\.([x*]|\\d+)(?:\\.([x*]|\\d+)(?:\\.([x*]|\\d+))?(?:-([\\da-z\\-]+(?:\\.[\\da-z\\-]+)*))?(?:\\+[\\da-z\\-]+(?:\\.[\\da-z\\-]+)*)?)?)?$/i;\n\nconst validateAndParse = version => {\n  if (typeof version !== 'string') {\n    throw new TypeError('Invalid argument expected string');\n  }\n\n  const match = version.match(semver);\n\n  if (!match) {\n    throw new Error(`Invalid argument not valid semver ('${version}' received)`);\n  }\n\n  match.shift();\n  return match;\n};\n\nconst isWildcard = s => s === '*' || s === 'x' || s === 'X';\n\nconst tryParse = v => {\n  const n = parseInt(v, 10);\n  return isNaN(n) ? v : n;\n};\n\nconst forceType = (a, b) => typeof a !== typeof b ? [String(a), String(b)] : [a, b];\n\nconst compareStrings = (a, b) => {\n  if (isWildcard(a) || isWildcard(b)) return 0;\n  const [ap, bp] = forceType(tryParse(a), tryParse(b));\n  if (ap > bp) return 1;\n  if (ap < bp) return -1;\n  return 0;\n};\n\nconst compareSegments = (a, b) => {\n  for (let i = 0; i < Math.max(a.length, b.length); i++) {\n    const r = compareStrings(a[i] || '0', b[i] || '0');\n    if (r !== 0) return r;\n  }\n\n  return 0;\n};\n\nconst operatorResMap = {\n  '>': [1],\n  '>=': [0, 1],\n  '=': [0],\n  '<=': [-1, 0],\n  '<': [-1]\n};\nconst allowedOperators = Object.keys(operatorResMap);\n\nconst assertValidOperator = op => {\n  if (typeof op !== 'string') {\n    throw new TypeError(`Invalid operator type, expected string but got ${typeof op}`);\n  }\n\n  if (allowedOperators.indexOf(op) === -1) {\n    throw new Error(`Invalid operator, expected one of ${allowedOperators.join('|')}`);\n  }\n};\n// EXTERNAL MODULE: ../react-devtools-shared/src/hydration.js\nvar hydration = __webpack_require__(11);\n\n// EXTERNAL MODULE: ../shared/isArray.js\nvar isArray = __webpack_require__(35);\n\n// CONCATENATED MODULE: ../react-devtools-shared/src/backend/utils.js\n/**\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\n\nfunction cleanForBridge(data, isPathAllowed, path = []) {\n  if (data !== null) {\n    const cleanedPaths = [];\n    const unserializablePaths = [];\n    const cleanedData = Object(hydration[\"a\" /* dehydrate */])(data, cleanedPaths, unserializablePaths, path, isPathAllowed);\n    return {\n      data: cleanedData,\n      cleaned: cleanedPaths,\n      unserializable: unserializablePaths\n    };\n  } else {\n    return null;\n  }\n}\nfunction copyToClipboard(value) {\n  const safeToCopy = serializeToString(value);\n  const text = safeToCopy === undefined ? 'undefined' : safeToCopy;\n  const {\n    clipboardCopyText\n  } = window.__REACT_DEVTOOLS_GLOBAL_HOOK__; // On Firefox navigator.clipboard.writeText has to be called from\n  // the content script js code (because it requires the clipboardWrite\n  // permission to be allowed out of a \"user handling\" callback),\n  // clipboardCopyText is an helper injected into the page from.\n  // injectGlobalHook.\n\n  if (typeof clipboardCopyText === 'function') {\n    clipboardCopyText(text).catch(err => {});\n  } else {\n    Object(clipboard[\"copy\"])(text);\n  }\n}\nfunction copyWithDelete(obj, path, index = 0) {\n  const key = path[index];\n  const updated = Object(isArray[\"a\" /* default */])(obj) ? obj.slice() : { ...obj\n  };\n\n  if (index + 1 === path.length) {\n    if (Object(isArray[\"a\" /* default */])(updated)) {\n      updated.splice(key, 1);\n    } else {\n      delete updated[key];\n    }\n  } else {\n    // $FlowFixMe number or string is fine here\n    updated[key] = copyWithDelete(obj[key], path, index + 1);\n  }\n\n  return updated;\n} // This function expects paths to be the same except for the final value.\n// e.g. ['path', 'to', 'foo'] and ['path', 'to', 'bar']\n\nfunction copyWithRename(obj, oldPath, newPath, index = 0) {\n  const oldKey = oldPath[index];\n  const updated = Object(isArray[\"a\" /* default */])(obj) ? obj.slice() : { ...obj\n  };\n\n  if (index + 1 === oldPath.length) {\n    const newKey = newPath[index]; // $FlowFixMe number or string is fine here\n\n    updated[newKey] = updated[oldKey];\n\n    if (Object(isArray[\"a\" /* default */])(updated)) {\n      updated.splice(oldKey, 1);\n    } else {\n      delete updated[oldKey];\n    }\n  } else {\n    // $FlowFixMe number or string is fine here\n    updated[oldKey] = copyWithRename(obj[oldKey], oldPath, newPath, index + 1);\n  }\n\n  return updated;\n}\nfunction copyWithSet(obj, path, value, index = 0) {\n  if (index >= path.length) {\n    return value;\n  }\n\n  const key = path[index];\n  const updated = Object(isArray[\"a\" /* default */])(obj) ? obj.slice() : { ...obj\n  }; // $FlowFixMe number or string is fine here\n\n  updated[key] = copyWithSet(obj[key], path, value, index + 1);\n  return updated;\n}\nfunction getEffectDurations(root) {\n  // Profiling durations are only available for certain builds.\n  // If available, they'll be stored on the HostRoot.\n  let effectDuration = null;\n  let passiveEffectDuration = null;\n  const hostRoot = root.current;\n\n  if (hostRoot != null) {\n    const stateNode = hostRoot.stateNode;\n\n    if (stateNode != null) {\n      effectDuration = stateNode.effectDuration != null ? stateNode.effectDuration : null;\n      passiveEffectDuration = stateNode.passiveEffectDuration != null ? stateNode.passiveEffectDuration : null;\n    }\n  }\n\n  return {\n    effectDuration,\n    passiveEffectDuration\n  };\n}\nfunction serializeToString(data) {\n  const cache = new Set(); // Use a custom replacer function to protect against circular references.\n\n  return JSON.stringify(data, (key, value) => {\n    if (typeof value === 'object' && value !== null) {\n      if (cache.has(value)) {\n        return;\n      }\n\n      cache.add(value);\n    }\n\n    if (typeof value === 'bigint') {\n      return value.toString() + 'n';\n    }\n\n    return value;\n  });\n} // Formats an array of args with a style for console methods, using\n// the following algorithm:\n//     1. The first param is a string that contains %c\n//          - Bail out and return the args without modifying the styles.\n//            We don't want to affect styles that the developer deliberately set.\n//     2. The first param is a string that doesn't contain %c but contains\n//        string formatting\n//          - [`%c${args[0]}`, style, ...args.slice(1)]\n//          - Note: we assume that the string formatting that the developer uses\n//            is correct.\n//     3. The first param is a string that doesn't contain string formatting\n//        OR is not a string\n//          - Create a formatting string where:\n//                 boolean, string, symbol -> %s\n//                 number -> %f OR %i depending on if it's an int or float\n//                 default -> %o\n\nfunction formatWithStyles(inputArgs, style) {\n  if (inputArgs === undefined || inputArgs === null || inputArgs.length === 0 || // Matches any of %c but not %%c\n  typeof inputArgs[0] === 'string' && inputArgs[0].match(/([^%]|^)(%c)/g) || style === undefined) {\n    return inputArgs;\n  } // Matches any of %(o|O|d|i|s|f), but not %%(o|O|d|i|s|f)\n\n\n  const REGEXP = /([^%]|^)((%%)*)(%([oOdisf]))/g;\n\n  if (typeof inputArgs[0] === 'string' && inputArgs[0].match(REGEXP)) {\n    return [`%c${inputArgs[0]}`, style, ...inputArgs.slice(1)];\n  } else {\n    const firstArg = inputArgs.reduce((formatStr, elem, i) => {\n      if (i > 0) {\n        formatStr += ' ';\n      }\n\n      switch (typeof elem) {\n        case 'string':\n        case 'boolean':\n        case 'symbol':\n          return formatStr += '%s';\n\n        case 'number':\n          const formatting = Number.isInteger(elem) ? '%i' : '%f';\n          return formatStr += formatting;\n\n        default:\n          return formatStr += '%o';\n      }\n    }, '%c');\n    return [firstArg, style, ...inputArgs];\n  }\n} // based on https://github.com/tmpfs/format-util/blob/0e62d430efb0a1c51448709abd3e2406c14d8401/format.js#L1\n// based on https://developer.mozilla.org/en-US/docs/Web/API/console#Using_string_substitutions\n// Implements s, d, i and f placeholders\n// NOTE: KEEP IN SYNC with src/hook.js\n\nfunction format(maybeMessage, ...inputArgs) {\n  const args = inputArgs.slice();\n  let formatted = String(maybeMessage); // If the first argument is a string, check for substitutions.\n\n  if (typeof maybeMessage === 'string') {\n    if (args.length) {\n      const REGEXP = /(%?)(%([jds]))/g;\n      formatted = formatted.replace(REGEXP, (match, escaped, ptn, flag) => {\n        let arg = args.shift();\n\n        switch (flag) {\n          case 's':\n            arg += '';\n            break;\n\n          case 'd':\n          case 'i':\n            arg = parseInt(arg, 10).toString();\n            break;\n\n          case 'f':\n            arg = parseFloat(arg).toString();\n            break;\n        }\n\n        if (!escaped) {\n          return arg;\n        }\n\n        args.unshift(arg);\n        return match;\n      });\n    }\n  } // Arguments that remain after formatting.\n\n\n  if (args.length) {\n    for (let i = 0; i < args.length; i++) {\n      formatted += ' ' + String(args[i]);\n    }\n  } // Update escaped %% values.\n\n\n  formatted = formatted.replace(/%{2,2}/g, '%');\n  return String(formatted);\n}\nfunction isSynchronousXHRSupported() {\n  return !!(window.document && window.document.featurePolicy && window.document.featurePolicy.allowsFeature('sync-xhr'));\n}\nfunction gt(a = '', b = '') {\n  return compareVersions(a, b) === 1;\n}\nfunction gte(a = '', b = '') {\n  return compareVersions(a, b) > -1;\n}\n\n/***/ }),\n\n/***/ 13:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return consoleManagedByDevToolsDuringStrictMode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return enableLogger; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return enableNamedHooksFeature; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return enableProfilerChangedHookIndices; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return enableStyleXFeatures; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"g\", function() { return isInternalFacebookBuild; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return enableProfilerComponentTree; });\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n/************************************************************************\n * This file is forked between different DevTools implementations.\n * It should never be imported directly!\n * It should always be imported from \"react-devtools-feature-flags\".\n ************************************************************************/\nconst consoleManagedByDevToolsDuringStrictMode = true;\nconst enableLogger = false;\nconst enableNamedHooksFeature = true;\nconst enableProfilerChangedHookIndices = true;\nconst enableStyleXFeatures = false;\nconst isInternalFacebookBuild = false;\nconst enableProfilerComponentTree = true;\n\n/***/ }),\n\n/***/ 16:\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"react-is\");\n\n/***/ }),\n\n/***/ 17:\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(setImmediate) {//  Import support https://stackoverflow.com/questions/13673346/supporting-both-commonjs-and-amd\n(function (name, definition) {\n  if (true) {\n    module.exports = definition();\n  } else {}\n})(\"clipboard\", function () {\n  if (typeof document === 'undefined' || !document.addEventListener) {\n    return null;\n  }\n\n  var clipboard = {};\n\n  clipboard.copy = function () {\n    var _intercept = false;\n    var _data = null; // Map from data type (e.g. \"text/html\") to value.\n\n    var _bogusSelection = false;\n\n    function cleanup() {\n      _intercept = false;\n      _data = null;\n\n      if (_bogusSelection) {\n        window.getSelection().removeAllRanges();\n      }\n\n      _bogusSelection = false;\n    }\n\n    document.addEventListener(\"copy\", function (e) {\n      if (_intercept) {\n        for (var key in _data) {\n          e.clipboardData.setData(key, _data[key]);\n        }\n\n        e.preventDefault();\n      }\n    }); // Workaround for Safari: https://bugs.webkit.org/show_bug.cgi?id=156529\n\n    function bogusSelect() {\n      var sel = document.getSelection(); // If \"nothing\" is selected...\n\n      if (!document.queryCommandEnabled(\"copy\") && sel.isCollapsed) {\n        // ... temporarily select the entire body.\n        //\n        // We select the entire body because:\n        // - it's guaranteed to exist,\n        // - it works (unlike, say, document.head, or phantom element that is\n        //   not inserted into the DOM),\n        // - it doesn't seem to flicker (due to the synchronous copy event), and\n        // - it avoids modifying the DOM (can trigger mutation observers).\n        //\n        // Because we can't do proper feature detection (we already checked\n        // document.queryCommandEnabled(\"copy\") , which actually gives a false\n        // negative for Blink when nothing is selected) and UA sniffing is not\n        // reliable (a lot of UA strings contain \"Safari\"), this will also\n        // happen for some browsers other than Safari. :-()\n        var range = document.createRange();\n        range.selectNodeContents(document.body);\n        sel.removeAllRanges();\n        sel.addRange(range);\n        _bogusSelection = true;\n      }\n    }\n\n    ;\n    return function (data) {\n      return new Promise(function (resolve, reject) {\n        _intercept = true;\n\n        if (typeof data === \"string\") {\n          _data = {\n            \"text/plain\": data\n          };\n        } else if (data instanceof Node) {\n          _data = {\n            \"text/html\": new XMLSerializer().serializeToString(data)\n          };\n        } else if (data instanceof Object) {\n          _data = data;\n        } else {\n          reject(\"Invalid data type. Must be string, DOM node, or an object mapping MIME types to strings.\");\n        }\n\n        function triggerCopy(tryBogusSelect) {\n          try {\n            if (document.execCommand(\"copy\")) {\n              // document.execCommand is synchronous: http://www.w3.org/TR/2015/WD-clipboard-apis-20150421/#integration-with-rich-text-editing-apis\n              // So we can call resolve() back here.\n              cleanup();\n              resolve();\n            } else {\n              if (!tryBogusSelect) {\n                bogusSelect();\n                triggerCopy(true);\n              } else {\n                cleanup();\n                throw new Error(\"Unable to copy. Perhaps it's not available in your browser?\");\n              }\n            }\n          } catch (e) {\n            cleanup();\n            reject(e);\n          }\n        }\n\n        triggerCopy(false);\n      });\n    };\n  }();\n\n  clipboard.paste = function () {\n    var _intercept = false;\n\n    var _resolve;\n\n    var _dataType;\n\n    document.addEventListener(\"paste\", function (e) {\n      if (_intercept) {\n        _intercept = false;\n        e.preventDefault();\n        var resolve = _resolve;\n        _resolve = null;\n        resolve(e.clipboardData.getData(_dataType));\n      }\n    });\n    return function (dataType) {\n      return new Promise(function (resolve, reject) {\n        _intercept = true;\n        _resolve = resolve;\n        _dataType = dataType || \"text/plain\";\n\n        try {\n          if (!document.execCommand(\"paste\")) {\n            _intercept = false;\n            reject(new Error(\"Unable to paste. Pasting only works in Internet Explorer at the moment.\"));\n          }\n        } catch (e) {\n          _intercept = false;\n          reject(new Error(e));\n        }\n      });\n    };\n  }(); // Handle IE behaviour.\n\n\n  if (typeof ClipboardEvent === \"undefined\" && typeof window.clipboardData !== \"undefined\" && typeof window.clipboardData.setData !== \"undefined\") {\n    /*! promise-polyfill 2.0.1 */\n    (function (a) {\n      function b(a, b) {\n        return function () {\n          a.apply(b, arguments);\n        };\n      }\n\n      function c(a) {\n        if (\"object\" != typeof this) throw new TypeError(\"Promises must be constructed via new\");\n        if (\"function\" != typeof a) throw new TypeError(\"not a function\");\n        this._state = null, this._value = null, this._deferreds = [], i(a, b(e, this), b(f, this));\n      }\n\n      function d(a) {\n        var b = this;\n        return null === this._state ? void this._deferreds.push(a) : void j(function () {\n          var c = b._state ? a.onFulfilled : a.onRejected;\n          if (null === c) return void (b._state ? a.resolve : a.reject)(b._value);\n          var d;\n\n          try {\n            d = c(b._value);\n          } catch (e) {\n            return void a.reject(e);\n          }\n\n          a.resolve(d);\n        });\n      }\n\n      function e(a) {\n        try {\n          if (a === this) throw new TypeError(\"A promise cannot be resolved with itself.\");\n\n          if (a && (\"object\" == typeof a || \"function\" == typeof a)) {\n            var c = a.then;\n            if (\"function\" == typeof c) return void i(b(c, a), b(e, this), b(f, this));\n          }\n\n          this._state = !0, this._value = a, g.call(this);\n        } catch (d) {\n          f.call(this, d);\n        }\n      }\n\n      function f(a) {\n        this._state = !1, this._value = a, g.call(this);\n      }\n\n      function g() {\n        for (var a = 0, b = this._deferreds.length; b > a; a++) d.call(this, this._deferreds[a]);\n\n        this._deferreds = null;\n      }\n\n      function h(a, b, c, d) {\n        this.onFulfilled = \"function\" == typeof a ? a : null, this.onRejected = \"function\" == typeof b ? b : null, this.resolve = c, this.reject = d;\n      }\n\n      function i(a, b, c) {\n        var d = !1;\n\n        try {\n          a(function (a) {\n            d || (d = !0, b(a));\n          }, function (a) {\n            d || (d = !0, c(a));\n          });\n        } catch (e) {\n          if (d) return;\n          d = !0, c(e);\n        }\n      }\n\n      var j = c.immediateFn || \"function\" == typeof setImmediate && setImmediate || function (a) {\n        setTimeout(a, 1);\n      },\n          k = Array.isArray || function (a) {\n        return \"[object Array]\" === Object.prototype.toString.call(a);\n      };\n\n      c.prototype[\"catch\"] = function (a) {\n        return this.then(null, a);\n      }, c.prototype.then = function (a, b) {\n        var e = this;\n        return new c(function (c, f) {\n          d.call(e, new h(a, b, c, f));\n        });\n      }, c.all = function () {\n        var a = Array.prototype.slice.call(1 === arguments.length && k(arguments[0]) ? arguments[0] : arguments);\n        return new c(function (b, c) {\n          function d(f, g) {\n            try {\n              if (g && (\"object\" == typeof g || \"function\" == typeof g)) {\n                var h = g.then;\n                if (\"function\" == typeof h) return void h.call(g, function (a) {\n                  d(f, a);\n                }, c);\n              }\n\n              a[f] = g, 0 === --e && b(a);\n            } catch (i) {\n              c(i);\n            }\n          }\n\n          if (0 === a.length) return b([]);\n\n          for (var e = a.length, f = 0; f < a.length; f++) d(f, a[f]);\n        });\n      }, c.resolve = function (a) {\n        return a && \"object\" == typeof a && a.constructor === c ? a : new c(function (b) {\n          b(a);\n        });\n      }, c.reject = function (a) {\n        return new c(function (b, c) {\n          c(a);\n        });\n      }, c.race = function (a) {\n        return new c(function (b, c) {\n          for (var d = 0, e = a.length; e > d; d++) a[d].then(b, c);\n        });\n      },  true && module.exports ? module.exports = c : a.Promise || (a.Promise = c);\n    })(this);\n\n    clipboard.copy = function (data) {\n      return new Promise(function (resolve, reject) {\n        // IE supports string and URL types: https://msdn.microsoft.com/en-us/library/ms536744(v=vs.85).aspx\n        // We only support the string type for now.\n        if (typeof data !== \"string\" && !(\"text/plain\" in data)) {\n          throw new Error(\"You must provide a text/plain type.\");\n        }\n\n        var strData = typeof data === \"string\" ? data : data[\"text/plain\"];\n        var copySucceeded = window.clipboardData.setData(\"Text\", strData);\n\n        if (copySucceeded) {\n          resolve();\n        } else {\n          reject(new Error(\"Copying was rejected.\"));\n        }\n      });\n    };\n\n    clipboard.paste = function () {\n      return new Promise(function (resolve, reject) {\n        var strData = window.clipboardData.getData(\"Text\");\n\n        if (strData) {\n          resolve(strData);\n        } else {\n          // The user rejected the paste request.\n          reject(new Error(\"Pasting was rejected.\"));\n        }\n      });\n    };\n  }\n\n  return clipboard;\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(80).setImmediate))\n\n/***/ }),\n\n/***/ 2:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return ElementTypeClass; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return ElementTypeContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return ElementTypeFunction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"g\", function() { return ElementTypeForwardRef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"i\", function() { return ElementTypeHostComponent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"j\", function() { return ElementTypeMemo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"k\", function() { return ElementTypeOtherOrUnknown; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"l\", function() { return ElementTypeProfiler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"m\", function() { return ElementTypeRoot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"n\", function() { return ElementTypeSuspense; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"o\", function() { return ElementTypeSuspenseList; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"p\", function() { return ElementTypeTracingMarker; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return ComponentFilterElementType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return ComponentFilterDisplayName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return ComponentFilterLocation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return ComponentFilterHOC; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"q\", function() { return StrictMode; });\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// WARNING\n// The values below are referenced by ComponentFilters (which are saved via localStorage).\n// Do not change them or it will break previously saved user customizations.\n// If new element types are added, use new numbers rather than re-ordering existing ones.\n//\n// Changing these types is also a backwards breaking change for the standalone shell,\n// since the frontend and backend must share the same values-\n// and the backend is embedded in certain environments (like React Native).\nconst ElementTypeClass = 1;\nconst ElementTypeContext = 2;\nconst ElementTypeFunction = 5;\nconst ElementTypeForwardRef = 6;\nconst ElementTypeHostComponent = 7;\nconst ElementTypeMemo = 8;\nconst ElementTypeOtherOrUnknown = 9;\nconst ElementTypeProfiler = 10;\nconst ElementTypeRoot = 11;\nconst ElementTypeSuspense = 12;\nconst ElementTypeSuspenseList = 13;\nconst ElementTypeTracingMarker = 14; // Different types of elements displayed in the Elements tree.\n// These types may be used to visually distinguish types,\n// or to enable/disable certain functionality.\n\n// WARNING\n// The values below are referenced by ComponentFilters (which are saved via localStorage).\n// Do not change them or it will break previously saved user customizations.\n// If new filter types are added, use new numbers rather than re-ordering existing ones.\nconst ComponentFilterElementType = 1;\nconst ComponentFilterDisplayName = 2;\nconst ComponentFilterLocation = 3;\nconst ComponentFilterHOC = 4;\nconst StrictMode = 1;\n\n/***/ }),\n\n/***/ 20:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst isArray = Array.isArray;\n/* harmony default export */ __webpack_exports__[\"a\"] = (isArray);\n\n/***/ }),\n\n/***/ 206:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"activate\", function() { return /* binding */ activate; });\n__webpack_require__.d(__webpack_exports__, \"createBridge\", function() { return /* binding */ createBridge; });\n__webpack_require__.d(__webpack_exports__, \"initialize\", function() { return /* binding */ backend_initialize; });\n\n// EXTERNAL MODULE: ../react-devtools-shared/src/events.js\nvar events = __webpack_require__(41);\n\n// EXTERNAL MODULE: /Users/xch/dev/react/node_modules/lodash.throttle/index.js\nvar lodash_throttle = __webpack_require__(53);\nvar lodash_throttle_default = /*#__PURE__*/__webpack_require__.n(lodash_throttle);\n\n// EXTERNAL MODULE: ../react-devtools-shared/src/constants.js\nvar constants = __webpack_require__(1);\n\n// EXTERNAL MODULE: ../react-devtools-shared/src/storage.js\nvar storage = __webpack_require__(10);\n\n// EXTERNAL MODULE: /Users/xch/dev/react/node_modules/memoize-one/esm/index.js\nvar esm = __webpack_require__(43);\n\n// CONCATENATED MODULE: ../react-devtools-shared/src/backend/views/utils.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// Get the window object for the document that a node belongs to,\n// or return null if it cannot be found (node not attached to DOM,\n// etc).\nfunction getOwnerWindow(node) {\n  if (!node.ownerDocument) {\n    return null;\n  }\n\n  return node.ownerDocument.defaultView;\n} // Get the iframe containing a node, or return null if it cannot\n// be found (node not within iframe, etc).\n\nfunction getOwnerIframe(node) {\n  const nodeWindow = getOwnerWindow(node);\n\n  if (nodeWindow) {\n    return nodeWindow.frameElement;\n  }\n\n  return null;\n} // Get a bounding client rect for a node, with an\n// offset added to compensate for its border.\n\nfunction getBoundingClientRectWithBorderOffset(node) {\n  const dimensions = getElementDimensions(node);\n  return mergeRectOffsets([node.getBoundingClientRect(), {\n    top: dimensions.borderTop,\n    left: dimensions.borderLeft,\n    bottom: dimensions.borderBottom,\n    right: dimensions.borderRight,\n    // This width and height won't get used by mergeRectOffsets (since this\n    // is not the first rect in the array), but we set them so that this\n    // object type checks as a ClientRect.\n    width: 0,\n    height: 0\n  }]);\n} // Add together the top, left, bottom, and right properties of\n// each ClientRect, but keep the width and height of the first one.\n\nfunction mergeRectOffsets(rects) {\n  return rects.reduce((previousRect, rect) => {\n    if (previousRect == null) {\n      return rect;\n    }\n\n    return {\n      top: previousRect.top + rect.top,\n      left: previousRect.left + rect.left,\n      width: previousRect.width,\n      height: previousRect.height,\n      bottom: previousRect.bottom + rect.bottom,\n      right: previousRect.right + rect.right\n    };\n  });\n} // Calculate a boundingClientRect for a node relative to boundaryWindow,\n// taking into account any offsets caused by intermediate iframes.\n\nfunction getNestedBoundingClientRect(node, boundaryWindow) {\n  const ownerIframe = getOwnerIframe(node);\n\n  if (ownerIframe && ownerIframe !== boundaryWindow) {\n    const rects = [node.getBoundingClientRect()];\n    let currentIframe = ownerIframe;\n    let onlyOneMore = false;\n\n    while (currentIframe) {\n      const rect = getBoundingClientRectWithBorderOffset(currentIframe);\n      rects.push(rect);\n      currentIframe = getOwnerIframe(currentIframe);\n\n      if (onlyOneMore) {\n        break;\n      } // We don't want to calculate iframe offsets upwards beyond\n      // the iframe containing the boundaryWindow, but we\n      // need to calculate the offset relative to the boundaryWindow.\n\n\n      if (currentIframe && getOwnerWindow(currentIframe) === boundaryWindow) {\n        onlyOneMore = true;\n      }\n    }\n\n    return mergeRectOffsets(rects);\n  } else {\n    return node.getBoundingClientRect();\n  }\n}\nfunction getElementDimensions(domElement) {\n  const calculatedStyle = window.getComputedStyle(domElement);\n  return {\n    borderLeft: parseInt(calculatedStyle.borderLeftWidth, 10),\n    borderRight: parseInt(calculatedStyle.borderRightWidth, 10),\n    borderTop: parseInt(calculatedStyle.borderTopWidth, 10),\n    borderBottom: parseInt(calculatedStyle.borderBottomWidth, 10),\n    marginLeft: parseInt(calculatedStyle.marginLeft, 10),\n    marginRight: parseInt(calculatedStyle.marginRight, 10),\n    marginTop: parseInt(calculatedStyle.marginTop, 10),\n    marginBottom: parseInt(calculatedStyle.marginBottom, 10),\n    paddingLeft: parseInt(calculatedStyle.paddingLeft, 10),\n    paddingRight: parseInt(calculatedStyle.paddingRight, 10),\n    paddingTop: parseInt(calculatedStyle.paddingTop, 10),\n    paddingBottom: parseInt(calculatedStyle.paddingBottom, 10)\n  };\n}\n// CONCATENATED MODULE: ../react-devtools-shared/src/backend/views/Highlighter/Overlay.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nconst Overlay_assign = Object.assign; // Note that the Overlay components are not affected by the active Theme,\n// because they highlight elements in the main Chrome window (outside of devtools).\n// The colors below were chosen to roughly match those used by Chrome devtools.\n\nclass OverlayRect {\n  constructor(doc, container) {\n    this.node = doc.createElement('div');\n    this.border = doc.createElement('div');\n    this.padding = doc.createElement('div');\n    this.content = doc.createElement('div');\n    this.border.style.borderColor = overlayStyles.border;\n    this.padding.style.borderColor = overlayStyles.padding;\n    this.content.style.backgroundColor = overlayStyles.background;\n    Overlay_assign(this.node.style, {\n      borderColor: overlayStyles.margin,\n      pointerEvents: 'none',\n      position: 'fixed'\n    });\n    this.node.style.zIndex = '10000000';\n    this.node.appendChild(this.border);\n    this.border.appendChild(this.padding);\n    this.padding.appendChild(this.content);\n    container.appendChild(this.node);\n  }\n\n  remove() {\n    if (this.node.parentNode) {\n      this.node.parentNode.removeChild(this.node);\n    }\n  }\n\n  update(box, dims) {\n    boxWrap(dims, 'margin', this.node);\n    boxWrap(dims, 'border', this.border);\n    boxWrap(dims, 'padding', this.padding);\n    Overlay_assign(this.content.style, {\n      height: box.height - dims.borderTop - dims.borderBottom - dims.paddingTop - dims.paddingBottom + 'px',\n      width: box.width - dims.borderLeft - dims.borderRight - dims.paddingLeft - dims.paddingRight + 'px'\n    });\n    Overlay_assign(this.node.style, {\n      top: box.top - dims.marginTop + 'px',\n      left: box.left - dims.marginLeft + 'px'\n    });\n  }\n\n}\n\nclass OverlayTip {\n  constructor(doc, container) {\n    this.tip = doc.createElement('div');\n    Overlay_assign(this.tip.style, {\n      display: 'flex',\n      flexFlow: 'row nowrap',\n      backgroundColor: '#333740',\n      borderRadius: '2px',\n      fontFamily: '\"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace',\n      fontWeight: 'bold',\n      padding: '3px 5px',\n      pointerEvents: 'none',\n      position: 'fixed',\n      fontSize: '12px',\n      whiteSpace: 'nowrap'\n    });\n    this.nameSpan = doc.createElement('span');\n    this.tip.appendChild(this.nameSpan);\n    Overlay_assign(this.nameSpan.style, {\n      color: '#ee78e6',\n      borderRight: '1px solid #aaaaaa',\n      paddingRight: '0.5rem',\n      marginRight: '0.5rem'\n    });\n    this.dimSpan = doc.createElement('span');\n    this.tip.appendChild(this.dimSpan);\n    Overlay_assign(this.dimSpan.style, {\n      color: '#d7d7d7'\n    });\n    this.tip.style.zIndex = '10000000';\n    container.appendChild(this.tip);\n  }\n\n  remove() {\n    if (this.tip.parentNode) {\n      this.tip.parentNode.removeChild(this.tip);\n    }\n  }\n\n  updateText(name, width, height) {\n    this.nameSpan.textContent = name;\n    this.dimSpan.textContent = Math.round(width) + 'px  ' + Math.round(height) + 'px';\n  }\n\n  updatePosition(dims, bounds) {\n    const tipRect = this.tip.getBoundingClientRect();\n    const tipPos = findTipPos(dims, bounds, {\n      width: tipRect.width,\n      height: tipRect.height\n    });\n    Overlay_assign(this.tip.style, tipPos.style);\n  }\n\n}\n\nclass Overlay_Overlay {\n  constructor(agent) {\n    // Find the root window, because overlays are positioned relative to it.\n    const currentWindow = window.__REACT_DEVTOOLS_TARGET_WINDOW__ || window;\n    this.window = currentWindow; // When opened in shells/dev, the tooltip should be bound by the app iframe, not by the topmost window.\n\n    const tipBoundsWindow = window.__REACT_DEVTOOLS_TARGET_WINDOW__ || window;\n    this.tipBoundsWindow = tipBoundsWindow;\n    const doc = currentWindow.document;\n    this.container = doc.createElement('div');\n    this.container.style.zIndex = '10000000';\n    this.tip = new OverlayTip(doc, this.container);\n    this.rects = [];\n    this.agent = agent;\n    doc.body.appendChild(this.container);\n  }\n\n  remove() {\n    this.tip.remove();\n    this.rects.forEach(rect => {\n      rect.remove();\n    });\n    this.rects.length = 0;\n\n    if (this.container.parentNode) {\n      this.container.parentNode.removeChild(this.container);\n    }\n  }\n\n  inspect(nodes, name) {\n    // We can't get the size of text nodes or comment nodes. React as of v15\n    // heavily uses comment nodes to delimit text.\n    const elements = nodes.filter(node => node.nodeType === Node.ELEMENT_NODE);\n\n    while (this.rects.length > elements.length) {\n      const rect = this.rects.pop();\n      rect.remove();\n    }\n\n    if (elements.length === 0) {\n      return;\n    }\n\n    while (this.rects.length < elements.length) {\n      this.rects.push(new OverlayRect(this.window.document, this.container));\n    }\n\n    const outerBox = {\n      top: Number.POSITIVE_INFINITY,\n      right: Number.NEGATIVE_INFINITY,\n      bottom: Number.NEGATIVE_INFINITY,\n      left: Number.POSITIVE_INFINITY\n    };\n    elements.forEach((element, index) => {\n      const box = getNestedBoundingClientRect(element, this.window);\n      const dims = getElementDimensions(element);\n      outerBox.top = Math.min(outerBox.top, box.top - dims.marginTop);\n      outerBox.right = Math.max(outerBox.right, box.left + box.width + dims.marginRight);\n      outerBox.bottom = Math.max(outerBox.bottom, box.top + box.height + dims.marginBottom);\n      outerBox.left = Math.min(outerBox.left, box.left - dims.marginLeft);\n      const rect = this.rects[index];\n      rect.update(box, dims);\n    });\n\n    if (!name) {\n      name = elements[0].nodeName.toLowerCase();\n      const node = elements[0];\n      const rendererInterface = this.agent.getBestMatchingRendererInterface(node);\n\n      if (rendererInterface) {\n        const id = rendererInterface.getFiberIDForNative(node, true);\n\n        if (id) {\n          const ownerName = rendererInterface.getDisplayNameForFiberID(id, true);\n\n          if (ownerName) {\n            name += ' (in ' + ownerName + ')';\n          }\n        }\n      }\n    }\n\n    this.tip.updateText(name, outerBox.right - outerBox.left, outerBox.bottom - outerBox.top);\n    const tipBounds = getNestedBoundingClientRect(this.tipBoundsWindow.document.documentElement, this.window);\n    this.tip.updatePosition({\n      top: outerBox.top,\n      left: outerBox.left,\n      height: outerBox.bottom - outerBox.top,\n      width: outerBox.right - outerBox.left\n    }, {\n      top: tipBounds.top + this.tipBoundsWindow.scrollY,\n      left: tipBounds.left + this.tipBoundsWindow.scrollX,\n      height: this.tipBoundsWindow.innerHeight,\n      width: this.tipBoundsWindow.innerWidth\n    });\n  }\n\n}\n\nfunction findTipPos(dims, bounds, tipSize) {\n  const tipHeight = Math.max(tipSize.height, 20);\n  const tipWidth = Math.max(tipSize.width, 60);\n  const margin = 5;\n  let top;\n\n  if (dims.top + dims.height + tipHeight <= bounds.top + bounds.height) {\n    if (dims.top + dims.height < bounds.top + 0) {\n      top = bounds.top + margin;\n    } else {\n      top = dims.top + dims.height + margin;\n    }\n  } else if (dims.top - tipHeight <= bounds.top + bounds.height) {\n    if (dims.top - tipHeight - margin < bounds.top + margin) {\n      top = bounds.top + margin;\n    } else {\n      top = dims.top - tipHeight - margin;\n    }\n  } else {\n    top = bounds.top + bounds.height - tipHeight - margin;\n  }\n\n  let left = dims.left + margin;\n\n  if (dims.left < bounds.left) {\n    left = bounds.left + margin;\n  }\n\n  if (dims.left + tipWidth > bounds.left + bounds.width) {\n    left = bounds.left + bounds.width - tipWidth - margin;\n  }\n\n  top += 'px';\n  left += 'px';\n  return {\n    style: {\n      top,\n      left\n    }\n  };\n}\n\nfunction boxWrap(dims, what, node) {\n  Overlay_assign(node.style, {\n    borderTopWidth: dims[what + 'Top'] + 'px',\n    borderLeftWidth: dims[what + 'Left'] + 'px',\n    borderRightWidth: dims[what + 'Right'] + 'px',\n    borderBottomWidth: dims[what + 'Bottom'] + 'px',\n    borderStyle: 'solid'\n  });\n}\n\nconst overlayStyles = {\n  background: 'rgba(120, 170, 210, 0.7)',\n  padding: 'rgba(77, 200, 0, 0.3)',\n  margin: 'rgba(255, 155, 0, 0.3)',\n  border: 'rgba(255, 200, 50, 0.3)'\n};\n// CONCATENATED MODULE: ../react-devtools-shared/src/backend/views/Highlighter/Highlighter.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nconst SHOW_DURATION = 2000;\nlet timeoutID = null;\nlet overlay = null;\nfunction hideOverlay(agent) {\n  if (window.document == null) {\n    agent.emit('hideNativeHighlight');\n    return;\n  }\n\n  timeoutID = null;\n\n  if (overlay !== null) {\n    overlay.remove();\n    overlay = null;\n  }\n}\nfunction showOverlay(elements, componentName, agent, hideAfterTimeout) {\n  if (window.document == null) {\n    if (elements != null && elements[0] != null) {\n      agent.emit('showNativeHighlight', elements[0]);\n    }\n\n    return;\n  }\n\n  if (timeoutID !== null) {\n    clearTimeout(timeoutID);\n  }\n\n  if (elements == null) {\n    return;\n  }\n\n  if (overlay === null) {\n    overlay = new Overlay_Overlay(agent);\n  }\n\n  overlay.inspect(elements, componentName);\n\n  if (hideAfterTimeout) {\n    timeoutID = setTimeout(() => hideOverlay(agent), SHOW_DURATION);\n  }\n}\n// CONCATENATED MODULE: ../react-devtools-shared/src/backend/views/Highlighter/index.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\n\n// This plug-in provides in-page highlighting of the selected element.\n// It is used by the browser extension and the standalone DevTools shell (when connected to a browser).\n// It is not currently the mechanism used to highlight React Native views.\n// That is done by the React Native Inspector component.\nlet iframesListeningTo = new Set();\nfunction setupHighlighter(bridge, agent) {\n  bridge.addListener('clearNativeElementHighlight', clearNativeElementHighlight);\n  bridge.addListener('highlightNativeElement', highlightNativeElement);\n  bridge.addListener('shutdown', stopInspectingNative);\n  bridge.addListener('startInspectingNative', startInspectingNative);\n  bridge.addListener('stopInspectingNative', stopInspectingNative);\n\n  function startInspectingNative() {\n    registerListenersOnWindow(window);\n  }\n\n  function registerListenersOnWindow(window) {\n    // This plug-in may run in non-DOM environments (e.g. React Native).\n    if (window && typeof window.addEventListener === 'function') {\n      window.addEventListener('click', onClick, true);\n      window.addEventListener('mousedown', onMouseEvent, true);\n      window.addEventListener('mouseover', onMouseEvent, true);\n      window.addEventListener('mouseup', onMouseEvent, true);\n      window.addEventListener('pointerdown', onPointerDown, true);\n      window.addEventListener('pointerover', onPointerOver, true);\n      window.addEventListener('pointerup', onPointerUp, true);\n    } else {\n      agent.emit('startInspectingNative');\n    }\n  }\n\n  function stopInspectingNative() {\n    hideOverlay(agent);\n    removeListenersOnWindow(window);\n    iframesListeningTo.forEach(function (frame) {\n      try {\n        removeListenersOnWindow(frame.contentWindow);\n      } catch (error) {// This can error when the iframe is on a cross-origin.\n      }\n    });\n    iframesListeningTo = new Set();\n  }\n\n  function removeListenersOnWindow(window) {\n    // This plug-in may run in non-DOM environments (e.g. React Native).\n    if (window && typeof window.removeEventListener === 'function') {\n      window.removeEventListener('click', onClick, true);\n      window.removeEventListener('mousedown', onMouseEvent, true);\n      window.removeEventListener('mouseover', onMouseEvent, true);\n      window.removeEventListener('mouseup', onMouseEvent, true);\n      window.removeEventListener('pointerdown', onPointerDown, true);\n      window.removeEventListener('pointerover', onPointerOver, true);\n      window.removeEventListener('pointerup', onPointerUp, true);\n    } else {\n      agent.emit('stopInspectingNative');\n    }\n  }\n\n  function clearNativeElementHighlight() {\n    hideOverlay(agent);\n  }\n\n  function highlightNativeElement({\n    displayName,\n    hideAfterTimeout,\n    id,\n    openNativeElementsPanel,\n    rendererID,\n    scrollIntoView\n  }) {\n    const renderer = agent.rendererInterfaces[rendererID];\n\n    if (renderer == null) {\n      console.warn(`Invalid renderer id \"${rendererID}\" for element \"${id}\"`);\n    }\n\n    let nodes = null;\n\n    if (renderer != null) {\n      nodes = renderer.findNativeNodesForFiberID(id);\n    }\n\n    if (nodes != null && nodes[0] != null) {\n      const node = nodes[0]; // $FlowFixMe[method-unbinding]\n\n      if (scrollIntoView && typeof node.scrollIntoView === 'function') {\n        // If the node isn't visible show it before highlighting it.\n        // We may want to reconsider this; it might be a little disruptive.\n        node.scrollIntoView({\n          block: 'nearest',\n          inline: 'nearest'\n        });\n      }\n\n      showOverlay(nodes, displayName, agent, hideAfterTimeout);\n\n      if (openNativeElementsPanel) {\n        window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$0 = node;\n        bridge.send('syncSelectionToNativeElementsPanel');\n      }\n    } else {\n      hideOverlay(agent);\n    }\n  }\n\n  function onClick(event) {\n    event.preventDefault();\n    event.stopPropagation();\n    stopInspectingNative();\n    bridge.send('stopInspectingNative', true);\n  }\n\n  function onMouseEvent(event) {\n    event.preventDefault();\n    event.stopPropagation();\n  }\n\n  function onPointerDown(event) {\n    event.preventDefault();\n    event.stopPropagation();\n    selectFiberForNode(event.target);\n  }\n\n  function onPointerOver(event) {\n    event.preventDefault();\n    event.stopPropagation();\n    const target = event.target;\n\n    if (target.tagName === 'IFRAME') {\n      const iframe = target;\n\n      try {\n        if (!iframesListeningTo.has(iframe)) {\n          const window = iframe.contentWindow;\n          registerListenersOnWindow(window);\n          iframesListeningTo.add(iframe);\n        }\n      } catch (error) {// This can error when the iframe is on a cross-origin.\n      }\n    } // Don't pass the name explicitly.\n    // It will be inferred from DOM tag and Fiber owner.\n\n\n    showOverlay([target], null, agent, false);\n    selectFiberForNode(target);\n  }\n\n  function onPointerUp(event) {\n    event.preventDefault();\n    event.stopPropagation();\n  }\n\n  const selectFiberForNode = lodash_throttle_default()(Object(esm[\"a\" /* default */])(node => {\n    const id = agent.getIDForNode(node);\n\n    if (id !== null) {\n      bridge.send('selectFiber', id);\n    }\n  }), 200, // Don't change the selection in the very first 200ms\n  // because those are usually unintentional as you lift the cursor.\n  {\n    leading: false\n  });\n}\n// CONCATENATED MODULE: ../react-devtools-shared/src/backend/views/TraceUpdates/canvas.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst OUTLINE_COLOR = '#f0f0f0'; // Note these colors are in sync with DevTools Profiler chart colors.\n\nconst COLORS = ['#37afa9', '#63b19e', '#80b393', '#97b488', '#abb67d', '#beb771', '#cfb965', '#dfba57', '#efbb49', '#febc38'];\nlet canvas = null;\nfunction draw(nodeToData, agent) {\n  if (window.document == null) {\n    const nodesToDraw = [];\n    iterateNodes(nodeToData, (_, color, node) => {\n      nodesToDraw.push({\n        node,\n        color\n      });\n    });\n    agent.emit('drawTraceUpdates', nodesToDraw);\n    return;\n  }\n\n  if (canvas === null) {\n    initialize();\n  }\n\n  const canvasFlow = canvas;\n  canvasFlow.width = window.innerWidth;\n  canvasFlow.height = window.innerHeight;\n  const context = canvasFlow.getContext('2d');\n  context.clearRect(0, 0, canvasFlow.width, canvasFlow.height);\n  iterateNodes(nodeToData, (rect, color) => {\n    if (rect !== null) {\n      drawBorder(context, rect, color);\n    }\n  });\n}\n\nfunction iterateNodes(nodeToData, execute) {\n  nodeToData.forEach(({\n    count,\n    rect\n  }, node) => {\n    const colorIndex = Math.min(COLORS.length - 1, count - 1);\n    const color = COLORS[colorIndex];\n    execute(rect, color, node);\n  });\n}\n\nfunction drawBorder(context, rect, color) {\n  const {\n    height,\n    left,\n    top,\n    width\n  } = rect; // outline\n\n  context.lineWidth = 1;\n  context.strokeStyle = OUTLINE_COLOR;\n  context.strokeRect(left - 1, top - 1, width + 2, height + 2); // inset\n\n  context.lineWidth = 1;\n  context.strokeStyle = OUTLINE_COLOR;\n  context.strokeRect(left + 1, top + 1, width - 1, height - 1);\n  context.strokeStyle = color;\n  context.setLineDash([0]); // border\n\n  context.lineWidth = 1;\n  context.strokeRect(left, top, width - 1, height - 1);\n  context.setLineDash([0]);\n}\n\nfunction destroy(agent) {\n  if (window.document == null) {\n    agent.emit('disableTraceUpdates');\n    return;\n  }\n\n  if (canvas !== null) {\n    if (canvas.parentNode != null) {\n      canvas.parentNode.removeChild(canvas);\n    }\n\n    canvas = null;\n  }\n}\n\nfunction initialize() {\n  canvas = window.document.createElement('canvas');\n  canvas.style.cssText = `\n    xx-background-color: red;\n    xx-opacity: 0.5;\n    bottom: 0;\n    left: 0;\n    pointer-events: none;\n    position: fixed;\n    right: 0;\n    top: 0;\n    z-index: 1000000000;\n  `;\n  const root = window.document.documentElement;\n  root.insertBefore(canvas, root.firstChild);\n}\n// CONCATENATED MODULE: ../react-devtools-shared/src/backend/views/TraceUpdates/index.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\n// How long the rect should be shown for?\nconst DISPLAY_DURATION = 250; // What's the longest we are willing to show the overlay for?\n// This can be important if we're getting a flurry of events (e.g. scroll update).\n\nconst MAX_DISPLAY_DURATION = 3000; // How long should a rect be considered valid for?\n\nconst REMEASUREMENT_AFTER_DURATION = 250; // Some environments (e.g. React Native / Hermes) don't support the performance API yet.\n\nconst getCurrentTime = // $FlowFixMe[method-unbinding]\ntypeof performance === 'object' && typeof performance.now === 'function' ? () => performance.now() : () => Date.now();\nconst nodeToData = new Map();\nlet TraceUpdates_agent = null;\nlet drawAnimationFrameID = null;\nlet isEnabled = false;\nlet redrawTimeoutID = null;\nfunction TraceUpdates_initialize(injectedAgent) {\n  TraceUpdates_agent = injectedAgent;\n  TraceUpdates_agent.addListener('traceUpdates', traceUpdates);\n}\nfunction toggleEnabled(value) {\n  isEnabled = value;\n\n  if (!isEnabled) {\n    nodeToData.clear();\n\n    if (drawAnimationFrameID !== null) {\n      cancelAnimationFrame(drawAnimationFrameID);\n      drawAnimationFrameID = null;\n    }\n\n    if (redrawTimeoutID !== null) {\n      clearTimeout(redrawTimeoutID);\n      redrawTimeoutID = null;\n    }\n\n    destroy(TraceUpdates_agent);\n  }\n}\n\nfunction traceUpdates(nodes) {\n  if (!isEnabled) {\n    return;\n  }\n\n  nodes.forEach(node => {\n    const data = nodeToData.get(node);\n    const now = getCurrentTime();\n    let lastMeasuredAt = data != null ? data.lastMeasuredAt : 0;\n    let rect = data != null ? data.rect : null;\n\n    if (rect === null || lastMeasuredAt + REMEASUREMENT_AFTER_DURATION < now) {\n      lastMeasuredAt = now;\n      rect = measureNode(node);\n    }\n\n    nodeToData.set(node, {\n      count: data != null ? data.count + 1 : 1,\n      expirationTime: data != null ? Math.min(now + MAX_DISPLAY_DURATION, data.expirationTime + DISPLAY_DURATION) : now + DISPLAY_DURATION,\n      lastMeasuredAt,\n      rect\n    });\n  });\n\n  if (redrawTimeoutID !== null) {\n    clearTimeout(redrawTimeoutID);\n    redrawTimeoutID = null;\n  }\n\n  if (drawAnimationFrameID === null) {\n    drawAnimationFrameID = requestAnimationFrame(prepareToDraw);\n  }\n}\n\nfunction prepareToDraw() {\n  drawAnimationFrameID = null;\n  redrawTimeoutID = null;\n  const now = getCurrentTime();\n  let earliestExpiration = Number.MAX_VALUE; // Remove any items that have already expired.\n\n  nodeToData.forEach((data, node) => {\n    if (data.expirationTime < now) {\n      nodeToData.delete(node);\n    } else {\n      earliestExpiration = Math.min(earliestExpiration, data.expirationTime);\n    }\n  });\n  draw(nodeToData, TraceUpdates_agent);\n\n  if (earliestExpiration !== Number.MAX_VALUE) {\n    redrawTimeoutID = setTimeout(prepareToDraw, earliestExpiration - now);\n  }\n}\n\nfunction measureNode(node) {\n  if (!node || typeof node.getBoundingClientRect !== 'function') {\n    return null;\n  }\n\n  const currentWindow = window.__REACT_DEVTOOLS_TARGET_WINDOW__ || window;\n  return getNestedBoundingClientRect(node, currentWindow);\n}\n// EXTERNAL MODULE: ../react-devtools-shared/src/backend/console.js\nvar backend_console = __webpack_require__(44);\n\n// EXTERNAL MODULE: ../react-devtools-shared/src/bridge.js\nvar src_bridge = __webpack_require__(34);\n\n// EXTERNAL MODULE: ../react-devtools-shared/src/backend/utils.js + 1 modules\nvar utils = __webpack_require__(12);\n\n// CONCATENATED MODULE: ../react-devtools-shared/src/backend/agent.js\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\n\n\n\n\n\n\n\nconst debug = (methodName, ...args) => {\n  if (constants[\"G\" /* __DEBUG__ */]) {\n    console.log(`%cAgent %c${methodName}`, 'color: purple; font-weight: bold;', 'font-weight: bold;', ...args);\n  }\n};\n\nclass agent_Agent extends events[\"a\" /* default */] {\n  constructor(bridge) {\n    super();\n\n    _defineProperty(this, \"_isProfiling\", false);\n\n    _defineProperty(this, \"_recordChangeDescriptions\", false);\n\n    _defineProperty(this, \"_rendererInterfaces\", {});\n\n    _defineProperty(this, \"_persistedSelection\", null);\n\n    _defineProperty(this, \"_persistedSelectionMatch\", null);\n\n    _defineProperty(this, \"_traceUpdatesEnabled\", false);\n\n    _defineProperty(this, \"clearErrorsAndWarnings\", ({\n      rendererID\n    }) => {\n      const renderer = this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(`Invalid renderer id \"${rendererID}\"`);\n      } else {\n        renderer.clearErrorsAndWarnings();\n      }\n    });\n\n    _defineProperty(this, \"clearErrorsForFiberID\", ({\n      id,\n      rendererID\n    }) => {\n      const renderer = this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(`Invalid renderer id \"${rendererID}\"`);\n      } else {\n        renderer.clearErrorsForFiberID(id);\n      }\n    });\n\n    _defineProperty(this, \"clearWarningsForFiberID\", ({\n      id,\n      rendererID\n    }) => {\n      const renderer = this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(`Invalid renderer id \"${rendererID}\"`);\n      } else {\n        renderer.clearWarningsForFiberID(id);\n      }\n    });\n\n    _defineProperty(this, \"copyElementPath\", ({\n      id,\n      path,\n      rendererID\n    }) => {\n      const renderer = this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(`Invalid renderer id \"${rendererID}\" for element \"${id}\"`);\n      } else {\n        renderer.copyElementPath(id, path);\n      }\n    });\n\n    _defineProperty(this, \"deletePath\", ({\n      hookID,\n      id,\n      path,\n      rendererID,\n      type\n    }) => {\n      const renderer = this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(`Invalid renderer id \"${rendererID}\" for element \"${id}\"`);\n      } else {\n        renderer.deletePath(type, id, hookID, path);\n      }\n    });\n\n    _defineProperty(this, \"getBackendVersion\", () => {\n      const version = \"4.27.2-7f747b80e\";\n\n      if (version) {\n        this._bridge.send('backendVersion', version);\n      }\n    });\n\n    _defineProperty(this, \"getBridgeProtocol\", () => {\n      this._bridge.send('bridgeProtocol', src_bridge[\"b\" /* currentBridgeProtocol */]);\n    });\n\n    _defineProperty(this, \"getProfilingData\", ({\n      rendererID\n    }) => {\n      const renderer = this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(`Invalid renderer id \"${rendererID}\"`);\n      }\n\n      this._bridge.send('profilingData', renderer.getProfilingData());\n    });\n\n    _defineProperty(this, \"getProfilingStatus\", () => {\n      this._bridge.send('profilingStatus', this._isProfiling);\n    });\n\n    _defineProperty(this, \"getOwnersList\", ({\n      id,\n      rendererID\n    }) => {\n      const renderer = this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(`Invalid renderer id \"${rendererID}\" for element \"${id}\"`);\n      } else {\n        const owners = renderer.getOwnersList(id);\n\n        this._bridge.send('ownersList', {\n          id,\n          owners\n        });\n      }\n    });\n\n    _defineProperty(this, \"inspectElement\", ({\n      forceFullData,\n      id,\n      path,\n      rendererID,\n      requestID\n    }) => {\n      const renderer = this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(`Invalid renderer id \"${rendererID}\" for element \"${id}\"`);\n      } else {\n        this._bridge.send('inspectedElement', renderer.inspectElement(requestID, id, path, forceFullData)); // When user selects an element, stop trying to restore the selection,\n        // and instead remember the current selection for the next reload.\n\n\n        if (this._persistedSelectionMatch === null || this._persistedSelectionMatch.id !== id) {\n          this._persistedSelection = null;\n          this._persistedSelectionMatch = null;\n          renderer.setTrackedPath(null);\n\n          this._throttledPersistSelection(rendererID, id);\n        } // TODO: If there was a way to change the selected DOM element\n        // in native Elements tab without forcing a switch to it, we'd do it here.\n        // For now, it doesn't seem like there is a way to do that:\n        // https://github.com/bvaughn/react-devtools-experimental/issues/102\n        // (Setting $0 doesn't work, and calling inspect() switches the tab.)\n\n      }\n    });\n\n    _defineProperty(this, \"logElementToConsole\", ({\n      id,\n      rendererID\n    }) => {\n      const renderer = this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(`Invalid renderer id \"${rendererID}\" for element \"${id}\"`);\n      } else {\n        renderer.logElementToConsole(id);\n      }\n    });\n\n    _defineProperty(this, \"overrideError\", ({\n      id,\n      rendererID,\n      forceError\n    }) => {\n      const renderer = this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(`Invalid renderer id \"${rendererID}\" for element \"${id}\"`);\n      } else {\n        renderer.overrideError(id, forceError);\n      }\n    });\n\n    _defineProperty(this, \"overrideSuspense\", ({\n      id,\n      rendererID,\n      forceFallback\n    }) => {\n      const renderer = this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(`Invalid renderer id \"${rendererID}\" for element \"${id}\"`);\n      } else {\n        renderer.overrideSuspense(id, forceFallback);\n      }\n    });\n\n    _defineProperty(this, \"overrideValueAtPath\", ({\n      hookID,\n      id,\n      path,\n      rendererID,\n      type,\n      value\n    }) => {\n      const renderer = this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(`Invalid renderer id \"${rendererID}\" for element \"${id}\"`);\n      } else {\n        renderer.overrideValueAtPath(type, id, hookID, path, value);\n      }\n    });\n\n    _defineProperty(this, \"overrideContext\", ({\n      id,\n      path,\n      rendererID,\n      wasForwarded,\n      value\n    }) => {\n      // Don't forward a message that's already been forwarded by the front-end Bridge.\n      // We only need to process the override command once!\n      if (!wasForwarded) {\n        this.overrideValueAtPath({\n          id,\n          path,\n          rendererID,\n          type: 'context',\n          value\n        });\n      }\n    });\n\n    _defineProperty(this, \"overrideHookState\", ({\n      id,\n      hookID,\n      path,\n      rendererID,\n      wasForwarded,\n      value\n    }) => {\n      // Don't forward a message that's already been forwarded by the front-end Bridge.\n      // We only need to process the override command once!\n      if (!wasForwarded) {\n        this.overrideValueAtPath({\n          id,\n          path,\n          rendererID,\n          type: 'hooks',\n          value\n        });\n      }\n    });\n\n    _defineProperty(this, \"overrideProps\", ({\n      id,\n      path,\n      rendererID,\n      wasForwarded,\n      value\n    }) => {\n      // Don't forward a message that's already been forwarded by the front-end Bridge.\n      // We only need to process the override command once!\n      if (!wasForwarded) {\n        this.overrideValueAtPath({\n          id,\n          path,\n          rendererID,\n          type: 'props',\n          value\n        });\n      }\n    });\n\n    _defineProperty(this, \"overrideState\", ({\n      id,\n      path,\n      rendererID,\n      wasForwarded,\n      value\n    }) => {\n      // Don't forward a message that's already been forwarded by the front-end Bridge.\n      // We only need to process the override command once!\n      if (!wasForwarded) {\n        this.overrideValueAtPath({\n          id,\n          path,\n          rendererID,\n          type: 'state',\n          value\n        });\n      }\n    });\n\n    _defineProperty(this, \"reloadAndProfile\", recordChangeDescriptions => {\n      Object(storage[\"e\" /* sessionStorageSetItem */])(constants[\"w\" /* SESSION_STORAGE_RELOAD_AND_PROFILE_KEY */], 'true');\n      Object(storage[\"e\" /* sessionStorageSetItem */])(constants[\"v\" /* SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY */], recordChangeDescriptions ? 'true' : 'false'); // This code path should only be hit if the shell has explicitly told the Store that it supports profiling.\n      // In that case, the shell must also listen for this specific message to know when it needs to reload the app.\n      // The agent can't do this in a way that is renderer agnostic.\n\n      this._bridge.send('reloadAppForProfiling');\n    });\n\n    _defineProperty(this, \"renamePath\", ({\n      hookID,\n      id,\n      newPath,\n      oldPath,\n      rendererID,\n      type\n    }) => {\n      const renderer = this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(`Invalid renderer id \"${rendererID}\" for element \"${id}\"`);\n      } else {\n        renderer.renamePath(type, id, hookID, oldPath, newPath);\n      }\n    });\n\n    _defineProperty(this, \"setTraceUpdatesEnabled\", traceUpdatesEnabled => {\n      this._traceUpdatesEnabled = traceUpdatesEnabled;\n      toggleEnabled(traceUpdatesEnabled);\n\n      for (const rendererID in this._rendererInterfaces) {\n        const renderer = this._rendererInterfaces[rendererID];\n        renderer.setTraceUpdatesEnabled(traceUpdatesEnabled);\n      }\n    });\n\n    _defineProperty(this, \"syncSelectionFromNativeElementsPanel\", () => {\n      const target = window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$0;\n\n      if (target == null) {\n        return;\n      }\n\n      this.selectNode(target);\n    });\n\n    _defineProperty(this, \"shutdown\", () => {\n      // Clean up the overlay if visible, and associated events.\n      this.emit('shutdown');\n    });\n\n    _defineProperty(this, \"startProfiling\", recordChangeDescriptions => {\n      this._recordChangeDescriptions = recordChangeDescriptions;\n      this._isProfiling = true;\n\n      for (const rendererID in this._rendererInterfaces) {\n        const renderer = this._rendererInterfaces[rendererID];\n        renderer.startProfiling(recordChangeDescriptions);\n      }\n\n      this._bridge.send('profilingStatus', this._isProfiling);\n    });\n\n    _defineProperty(this, \"stopProfiling\", () => {\n      this._isProfiling = false;\n      this._recordChangeDescriptions = false;\n\n      for (const rendererID in this._rendererInterfaces) {\n        const renderer = this._rendererInterfaces[rendererID];\n        renderer.stopProfiling();\n      }\n\n      this._bridge.send('profilingStatus', this._isProfiling);\n    });\n\n    _defineProperty(this, \"stopInspectingNative\", selected => {\n      this._bridge.send('stopInspectingNative', selected);\n    });\n\n    _defineProperty(this, \"storeAsGlobal\", ({\n      count,\n      id,\n      path,\n      rendererID\n    }) => {\n      const renderer = this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(`Invalid renderer id \"${rendererID}\" for element \"${id}\"`);\n      } else {\n        renderer.storeAsGlobal(id, path, count);\n      }\n    });\n\n    _defineProperty(this, \"updateConsolePatchSettings\", ({\n      appendComponentStack,\n      breakOnConsoleErrors,\n      showInlineWarningsAndErrors,\n      hideConsoleLogsInStrictMode,\n      browserTheme\n    }) => {\n      // If the frontend preferences have changed,\n      // or in the case of React Native- if the backend is just finding out the preferences-\n      // then reinstall the console overrides.\n      // It's safe to call `patchConsole` multiple times.\n      Object(backend_console[\"a\" /* patch */])({\n        appendComponentStack,\n        breakOnConsoleErrors,\n        showInlineWarningsAndErrors,\n        hideConsoleLogsInStrictMode,\n        browserTheme\n      });\n    });\n\n    _defineProperty(this, \"updateComponentFilters\", componentFilters => {\n      for (const rendererID in this._rendererInterfaces) {\n        const renderer = this._rendererInterfaces[rendererID];\n        renderer.updateComponentFilters(componentFilters);\n      }\n    });\n\n    _defineProperty(this, \"viewAttributeSource\", ({\n      id,\n      path,\n      rendererID\n    }) => {\n      const renderer = this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(`Invalid renderer id \"${rendererID}\" for element \"${id}\"`);\n      } else {\n        renderer.prepareViewAttributeSource(id, path);\n      }\n    });\n\n    _defineProperty(this, \"viewElementSource\", ({\n      id,\n      rendererID\n    }) => {\n      const renderer = this._rendererInterfaces[rendererID];\n\n      if (renderer == null) {\n        console.warn(`Invalid renderer id \"${rendererID}\" for element \"${id}\"`);\n      } else {\n        renderer.prepareViewElementSource(id);\n      }\n    });\n\n    _defineProperty(this, \"onTraceUpdates\", nodes => {\n      this.emit('traceUpdates', nodes);\n    });\n\n    _defineProperty(this, \"onFastRefreshScheduled\", () => {\n      if (constants[\"G\" /* __DEBUG__ */]) {\n        debug('onFastRefreshScheduled');\n      }\n\n      this._bridge.send('fastRefreshScheduled');\n    });\n\n    _defineProperty(this, \"onHookOperations\", operations => {\n      if (constants[\"G\" /* __DEBUG__ */]) {\n        debug('onHookOperations', `(${operations.length}) [${operations.join(', ')}]`);\n      } // TODO:\n      // The chrome.runtime does not currently support transferables; it forces JSON serialization.\n      // See bug https://bugs.chromium.org/p/chromium/issues/detail?id=927134\n      //\n      // Regarding transferables, the postMessage doc states:\n      // If the ownership of an object is transferred, it becomes unusable (neutered)\n      // in the context it was sent from and becomes available only to the worker it was sent to.\n      //\n      // Even though Chrome is eventually JSON serializing the array buffer,\n      // using the transferable approach also sometimes causes it to throw:\n      //   DOMException: Failed to execute 'postMessage' on 'Window': ArrayBuffer at index 0 is already neutered.\n      //\n      // See bug https://github.com/bvaughn/react-devtools-experimental/issues/25\n      //\n      // The Store has a fallback in place that parses the message as JSON if the type isn't an array.\n      // For now the simplest fix seems to be to not transfer the array.\n      // This will negatively impact performance on Firefox so it's unfortunate,\n      // but until we're able to fix the Chrome error mentioned above, it seems necessary.\n      //\n      // this._bridge.send('operations', operations, [operations.buffer]);\n\n\n      this._bridge.send('operations', operations);\n\n      if (this._persistedSelection !== null) {\n        const rendererID = operations[0];\n\n        if (this._persistedSelection.rendererID === rendererID) {\n          // Check if we can select a deeper match for the persisted selection.\n          const renderer = this._rendererInterfaces[rendererID];\n\n          if (renderer == null) {\n            console.warn(`Invalid renderer id \"${rendererID}\"`);\n          } else {\n            const prevMatch = this._persistedSelectionMatch;\n            const nextMatch = renderer.getBestMatchForTrackedPath();\n            this._persistedSelectionMatch = nextMatch;\n            const prevMatchID = prevMatch !== null ? prevMatch.id : null;\n            const nextMatchID = nextMatch !== null ? nextMatch.id : null;\n\n            if (prevMatchID !== nextMatchID) {\n              if (nextMatchID !== null) {\n                // We moved forward, unlocking a deeper node.\n                this._bridge.send('selectFiber', nextMatchID);\n              }\n            }\n\n            if (nextMatch !== null && nextMatch.isFullMatch) {\n              // We've just unlocked the innermost selected node.\n              // There's no point tracking it further.\n              this._persistedSelection = null;\n              this._persistedSelectionMatch = null;\n              renderer.setTrackedPath(null);\n            }\n          }\n        }\n      }\n    });\n\n    _defineProperty(this, \"_throttledPersistSelection\", lodash_throttle_default()((rendererID, id) => {\n      // This is throttled, so both renderer and selected ID\n      // might not be available by the time we read them.\n      // This is why we need the defensive checks here.\n      const renderer = this._rendererInterfaces[rendererID];\n      const path = renderer != null ? renderer.getPathForElement(id) : null;\n\n      if (path !== null) {\n        Object(storage[\"e\" /* sessionStorageSetItem */])(constants[\"u\" /* SESSION_STORAGE_LAST_SELECTION_KEY */], JSON.stringify({\n          rendererID,\n          path\n        }));\n      } else {\n        Object(storage[\"d\" /* sessionStorageRemoveItem */])(constants[\"u\" /* SESSION_STORAGE_LAST_SELECTION_KEY */]);\n      }\n    }, 1000));\n\n    if (Object(storage[\"c\" /* sessionStorageGetItem */])(constants[\"w\" /* SESSION_STORAGE_RELOAD_AND_PROFILE_KEY */]) === 'true') {\n      this._recordChangeDescriptions = Object(storage[\"c\" /* sessionStorageGetItem */])(constants[\"v\" /* SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY */]) === 'true';\n      this._isProfiling = true;\n      Object(storage[\"d\" /* sessionStorageRemoveItem */])(constants[\"v\" /* SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY */]);\n      Object(storage[\"d\" /* sessionStorageRemoveItem */])(constants[\"w\" /* SESSION_STORAGE_RELOAD_AND_PROFILE_KEY */]);\n    }\n\n    const persistedSelectionString = Object(storage[\"c\" /* sessionStorageGetItem */])(constants[\"u\" /* SESSION_STORAGE_LAST_SELECTION_KEY */]);\n\n    if (persistedSelectionString != null) {\n      this._persistedSelection = JSON.parse(persistedSelectionString);\n    }\n\n    this._bridge = bridge;\n    bridge.addListener('clearErrorsAndWarnings', this.clearErrorsAndWarnings);\n    bridge.addListener('clearErrorsForFiberID', this.clearErrorsForFiberID);\n    bridge.addListener('clearWarningsForFiberID', this.clearWarningsForFiberID);\n    bridge.addListener('copyElementPath', this.copyElementPath);\n    bridge.addListener('deletePath', this.deletePath);\n    bridge.addListener('getBackendVersion', this.getBackendVersion);\n    bridge.addListener('getBridgeProtocol', this.getBridgeProtocol);\n    bridge.addListener('getProfilingData', this.getProfilingData);\n    bridge.addListener('getProfilingStatus', this.getProfilingStatus);\n    bridge.addListener('getOwnersList', this.getOwnersList);\n    bridge.addListener('inspectElement', this.inspectElement);\n    bridge.addListener('logElementToConsole', this.logElementToConsole);\n    bridge.addListener('overrideError', this.overrideError);\n    bridge.addListener('overrideSuspense', this.overrideSuspense);\n    bridge.addListener('overrideValueAtPath', this.overrideValueAtPath);\n    bridge.addListener('reloadAndProfile', this.reloadAndProfile);\n    bridge.addListener('renamePath', this.renamePath);\n    bridge.addListener('setTraceUpdatesEnabled', this.setTraceUpdatesEnabled);\n    bridge.addListener('startProfiling', this.startProfiling);\n    bridge.addListener('stopProfiling', this.stopProfiling);\n    bridge.addListener('storeAsGlobal', this.storeAsGlobal);\n    bridge.addListener('syncSelectionFromNativeElementsPanel', this.syncSelectionFromNativeElementsPanel);\n    bridge.addListener('shutdown', this.shutdown);\n    bridge.addListener('updateConsolePatchSettings', this.updateConsolePatchSettings);\n    bridge.addListener('updateComponentFilters', this.updateComponentFilters);\n    bridge.addListener('viewAttributeSource', this.viewAttributeSource);\n    bridge.addListener('viewElementSource', this.viewElementSource); // Temporarily support older standalone front-ends sending commands to newer embedded backends.\n    // We do this because React Native embeds the React DevTools backend,\n    // but cannot control which version of the frontend users use.\n\n    bridge.addListener('overrideContext', this.overrideContext);\n    bridge.addListener('overrideHookState', this.overrideHookState);\n    bridge.addListener('overrideProps', this.overrideProps);\n    bridge.addListener('overrideState', this.overrideState);\n\n    if (this._isProfiling) {\n      bridge.send('profilingStatus', true);\n    } // Send the Bridge protocol and backend versions, after initialization, in case the frontend has already requested it.\n    // The Store may be instantiated beore the agent.\n\n\n    const _version = \"4.27.2-7f747b80e\";\n\n    if (_version) {\n      this._bridge.send('backendVersion', _version);\n    }\n\n    this._bridge.send('bridgeProtocol', src_bridge[\"b\" /* currentBridgeProtocol */]); // Notify the frontend if the backend supports the Storage API (e.g. localStorage).\n    // If not, features like reload-and-profile will not work correctly and must be disabled.\n\n\n    let isBackendStorageAPISupported = false;\n\n    try {\n      localStorage.getItem('test');\n      isBackendStorageAPISupported = true;\n    } catch (error) {}\n\n    bridge.send('isBackendStorageAPISupported', isBackendStorageAPISupported);\n    bridge.send('isSynchronousXHRSupported', Object(utils[\"k\" /* isSynchronousXHRSupported */])());\n    setupHighlighter(bridge, this);\n    TraceUpdates_initialize(this);\n  }\n\n  get rendererInterfaces() {\n    return this._rendererInterfaces;\n  }\n\n  getInstanceAndStyle({\n    id,\n    rendererID\n  }) {\n    const renderer = this._rendererInterfaces[rendererID];\n\n    if (renderer == null) {\n      console.warn(`Invalid renderer id \"${rendererID}\"`);\n      return null;\n    }\n\n    return renderer.getInstanceAndStyle(id);\n  }\n\n  getBestMatchingRendererInterface(node) {\n    let bestMatch = null;\n\n    for (const rendererID in this._rendererInterfaces) {\n      const renderer = this._rendererInterfaces[rendererID];\n      const fiber = renderer.getFiberForNative(node);\n\n      if (fiber !== null) {\n        // check if fiber.stateNode is matching the original hostInstance\n        if (fiber.stateNode === node) {\n          return renderer;\n        } else if (bestMatch === null) {\n          bestMatch = renderer;\n        }\n      }\n    } // if an exact match is not found, return the first valid renderer as fallback\n\n\n    return bestMatch;\n  }\n\n  getIDForNode(node) {\n    const rendererInterface = this.getBestMatchingRendererInterface(node);\n\n    if (rendererInterface != null) {\n      try {\n        return rendererInterface.getFiberIDForNative(node, true);\n      } catch (error) {// Some old React versions might throw if they can't find a match.\n        // If so we should ignore it...\n      }\n    }\n\n    return null;\n  }\n\n  selectNode(target) {\n    const id = this.getIDForNode(target);\n\n    if (id !== null) {\n      this._bridge.send('selectFiber', id);\n    }\n  }\n\n  setRendererInterface(rendererID, rendererInterface) {\n    this._rendererInterfaces[rendererID] = rendererInterface;\n\n    if (this._isProfiling) {\n      rendererInterface.startProfiling(this._recordChangeDescriptions);\n    }\n\n    rendererInterface.setTraceUpdatesEnabled(this._traceUpdatesEnabled); // When the renderer is attached, we need to tell it whether\n    // we remember the previous selection that we'd like to restore.\n    // It'll start tracking mounts for matches to the last selection path.\n\n    const selection = this._persistedSelection;\n\n    if (selection !== null && selection.rendererID === rendererID) {\n      rendererInterface.setTrackedPath(selection.path);\n    }\n  }\n\n  onUnsupportedRenderer(rendererID) {\n    this._bridge.send('unsupportedRendererVersion', rendererID);\n  }\n\n}\n// EXTERNAL MODULE: ../react-devtools-shared/src/backend/renderer.js + 10 modules\nvar backend_renderer = __webpack_require__(70);\n\n// EXTERNAL MODULE: ../react-devtools-shared/src/types.js\nvar types = __webpack_require__(2);\n\n// EXTERNAL MODULE: ../react-devtools-shared/src/utils.js + 1 modules\nvar src_utils = __webpack_require__(3);\n\n// CONCATENATED MODULE: ../react-devtools-shared/src/backend/legacy/utils.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction decorate(object, attr, fn) {\n  const old = object[attr]; // $FlowFixMe[missing-this-annot] webpack config needs to be updated to allow `this` type annotations\n\n  object[attr] = function (instance) {\n    return fn.call(this, old, arguments);\n  };\n\n  return old;\n}\nfunction decorateMany(source, fns) {\n  const olds = {};\n\n  for (const name in fns) {\n    olds[name] = decorate(source, name, fns[name]);\n  }\n\n  return olds;\n}\nfunction restoreMany(source, olds) {\n  for (const name in olds) {\n    source[name] = olds[name];\n  }\n} // $FlowFixMe[missing-this-annot] webpack config needs to be updated to allow `this` type annotations\n\nfunction forceUpdate(instance) {\n  if (typeof instance.forceUpdate === 'function') {\n    instance.forceUpdate();\n  } else if (instance.updater != null && typeof instance.updater.enqueueForceUpdate === 'function') {\n    instance.updater.enqueueForceUpdate(this, () => {}, 'forceUpdate');\n  }\n}\n// CONCATENATED MODULE: ../react-devtools-shared/src/backend/legacy/renderer.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\n\n\n\n\nfunction getData(internalInstance) {\n  let displayName = null;\n  let key = null; // != used deliberately here to catch undefined and null\n\n  if (internalInstance._currentElement != null) {\n    if (internalInstance._currentElement.key) {\n      key = String(internalInstance._currentElement.key);\n    }\n\n    const elementType = internalInstance._currentElement.type;\n\n    if (typeof elementType === 'string') {\n      displayName = elementType;\n    } else if (typeof elementType === 'function') {\n      displayName = Object(src_utils[\"k\" /* getDisplayName */])(elementType);\n    }\n  }\n\n  return {\n    displayName,\n    key\n  };\n}\n\nfunction getElementType(internalInstance) {\n  // != used deliberately here to catch undefined and null\n  if (internalInstance._currentElement != null) {\n    const elementType = internalInstance._currentElement.type;\n\n    if (typeof elementType === 'function') {\n      const publicInstance = internalInstance.getPublicInstance();\n\n      if (publicInstance !== null) {\n        return types[\"e\" /* ElementTypeClass */];\n      } else {\n        return types[\"h\" /* ElementTypeFunction */];\n      }\n    } else if (typeof elementType === 'string') {\n      return types[\"i\" /* ElementTypeHostComponent */];\n    }\n  }\n\n  return types[\"k\" /* ElementTypeOtherOrUnknown */];\n}\n\nfunction getChildren(internalInstance) {\n  const children = []; // If the parent is a native node without rendered children, but with\n  // multiple string children, then the `element` that gets passed in here is\n  // a plain value -- a string or number.\n\n  if (typeof internalInstance !== 'object') {// No children\n  } else if (internalInstance._currentElement === null || internalInstance._currentElement === false) {// No children\n  } else if (internalInstance._renderedComponent) {\n    const child = internalInstance._renderedComponent;\n\n    if (getElementType(child) !== types[\"k\" /* ElementTypeOtherOrUnknown */]) {\n      children.push(child);\n    }\n  } else if (internalInstance._renderedChildren) {\n    const renderedChildren = internalInstance._renderedChildren;\n\n    for (const name in renderedChildren) {\n      const child = renderedChildren[name];\n\n      if (getElementType(child) !== types[\"k\" /* ElementTypeOtherOrUnknown */]) {\n        children.push(child);\n      }\n    }\n  } // Note: we skip the case where children are just strings or numbers\n  // because the new DevTools skips over host text nodes anyway.\n\n\n  return children;\n}\n\nfunction renderer_attach(hook, rendererID, renderer, global) {\n  const idToInternalInstanceMap = new Map();\n  const internalInstanceToIDMap = new WeakMap();\n  const internalInstanceToRootIDMap = new WeakMap();\n  let getInternalIDForNative = null;\n  let findNativeNodeForInternalID;\n\n  let getFiberForNative = node => {\n    // Not implemented.\n    return null;\n  };\n\n  if (renderer.ComponentTree) {\n    getInternalIDForNative = (node, findNearestUnfilteredAncestor) => {\n      const internalInstance = renderer.ComponentTree.getClosestInstanceFromNode(node);\n      return internalInstanceToIDMap.get(internalInstance) || null;\n    };\n\n    findNativeNodeForInternalID = id => {\n      const internalInstance = idToInternalInstanceMap.get(id);\n      return renderer.ComponentTree.getNodeFromInstance(internalInstance);\n    };\n\n    getFiberForNative = node => {\n      return renderer.ComponentTree.getClosestInstanceFromNode(node);\n    };\n  } else if (renderer.Mount.getID && renderer.Mount.getNode) {\n    getInternalIDForNative = (node, findNearestUnfilteredAncestor) => {\n      // Not implemented.\n      return null;\n    };\n\n    findNativeNodeForInternalID = id => {\n      // Not implemented.\n      return null;\n    };\n  }\n\n  function getDisplayNameForFiberID(id) {\n    const internalInstance = idToInternalInstanceMap.get(id);\n    return internalInstance ? getData(internalInstance).displayName : null;\n  }\n\n  function getID(internalInstance) {\n    if (typeof internalInstance !== 'object' || internalInstance === null) {\n      throw new Error('Invalid internal instance: ' + internalInstance);\n    }\n\n    if (!internalInstanceToIDMap.has(internalInstance)) {\n      const id = Object(src_utils[\"r\" /* getUID */])();\n      internalInstanceToIDMap.set(internalInstance, id);\n      idToInternalInstanceMap.set(id, internalInstance);\n    }\n\n    return internalInstanceToIDMap.get(internalInstance);\n  }\n\n  function areEqualArrays(a, b) {\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    for (let i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  } // This is shared mutable state that lets us keep track of where we are.\n\n\n  let parentIDStack = [];\n  let oldReconcilerMethods = null;\n\n  if (renderer.Reconciler) {\n    // React 15\n    oldReconcilerMethods = decorateMany(renderer.Reconciler, {\n      mountComponent(fn, args) {\n        const internalInstance = args[0];\n        const hostContainerInfo = args[3];\n\n        if (getElementType(internalInstance) === types[\"k\" /* ElementTypeOtherOrUnknown */]) {\n          // $FlowFixMe[object-this-reference] found when upgrading Flow\n          return fn.apply(this, args);\n        }\n\n        if (hostContainerInfo._topLevelWrapper === undefined) {\n          // SSR\n          // $FlowFixMe[object-this-reference] found when upgrading Flow\n          return fn.apply(this, args);\n        }\n\n        const id = getID(internalInstance); // Push the operation.\n\n        const parentID = parentIDStack.length > 0 ? parentIDStack[parentIDStack.length - 1] : 0;\n        recordMount(internalInstance, id, parentID);\n        parentIDStack.push(id); // Remember the root.\n\n        internalInstanceToRootIDMap.set(internalInstance, getID(hostContainerInfo._topLevelWrapper));\n\n        try {\n          // $FlowFixMe[object-this-reference] found when upgrading Flow\n          const result = fn.apply(this, args);\n          parentIDStack.pop();\n          return result;\n        } catch (err) {\n          // $FlowFixMe[incompatible-type] found when upgrading Flow\n          parentIDStack = [];\n          throw err;\n        } finally {\n          if (parentIDStack.length === 0) {\n            const rootID = internalInstanceToRootIDMap.get(internalInstance);\n\n            if (rootID === undefined) {\n              throw new Error('Expected to find root ID.');\n            }\n\n            flushPendingEvents(rootID);\n          }\n        }\n      },\n\n      performUpdateIfNecessary(fn, args) {\n        const internalInstance = args[0];\n\n        if (getElementType(internalInstance) === types[\"k\" /* ElementTypeOtherOrUnknown */]) {\n          // $FlowFixMe[object-this-reference] found when upgrading Flow\n          return fn.apply(this, args);\n        }\n\n        const id = getID(internalInstance);\n        parentIDStack.push(id);\n        const prevChildren = getChildren(internalInstance);\n\n        try {\n          // $FlowFixMe[object-this-reference] found when upgrading Flow\n          const result = fn.apply(this, args);\n          const nextChildren = getChildren(internalInstance);\n\n          if (!areEqualArrays(prevChildren, nextChildren)) {\n            // Push the operation\n            recordReorder(internalInstance, id, nextChildren);\n          }\n\n          parentIDStack.pop();\n          return result;\n        } catch (err) {\n          // $FlowFixMe[incompatible-type] found when upgrading Flow\n          parentIDStack = [];\n          throw err;\n        } finally {\n          if (parentIDStack.length === 0) {\n            const rootID = internalInstanceToRootIDMap.get(internalInstance);\n\n            if (rootID === undefined) {\n              throw new Error('Expected to find root ID.');\n            }\n\n            flushPendingEvents(rootID);\n          }\n        }\n      },\n\n      receiveComponent(fn, args) {\n        const internalInstance = args[0];\n\n        if (getElementType(internalInstance) === types[\"k\" /* ElementTypeOtherOrUnknown */]) {\n          // $FlowFixMe[object-this-reference] found when upgrading Flow\n          return fn.apply(this, args);\n        }\n\n        const id = getID(internalInstance);\n        parentIDStack.push(id);\n        const prevChildren = getChildren(internalInstance);\n\n        try {\n          // $FlowFixMe[object-this-reference] found when upgrading Flow\n          const result = fn.apply(this, args);\n          const nextChildren = getChildren(internalInstance);\n\n          if (!areEqualArrays(prevChildren, nextChildren)) {\n            // Push the operation\n            recordReorder(internalInstance, id, nextChildren);\n          }\n\n          parentIDStack.pop();\n          return result;\n        } catch (err) {\n          // $FlowFixMe[incompatible-type] found when upgrading Flow\n          parentIDStack = [];\n          throw err;\n        } finally {\n          if (parentIDStack.length === 0) {\n            const rootID = internalInstanceToRootIDMap.get(internalInstance);\n\n            if (rootID === undefined) {\n              throw new Error('Expected to find root ID.');\n            }\n\n            flushPendingEvents(rootID);\n          }\n        }\n      },\n\n      unmountComponent(fn, args) {\n        const internalInstance = args[0];\n\n        if (getElementType(internalInstance) === types[\"k\" /* ElementTypeOtherOrUnknown */]) {\n          // $FlowFixMe[object-this-reference] found when upgrading Flow\n          return fn.apply(this, args);\n        }\n\n        const id = getID(internalInstance);\n        parentIDStack.push(id);\n\n        try {\n          // $FlowFixMe[object-this-reference] found when upgrading Flow\n          const result = fn.apply(this, args);\n          parentIDStack.pop(); // Push the operation.\n\n          recordUnmount(internalInstance, id);\n          return result;\n        } catch (err) {\n          // $FlowFixMe[incompatible-type] found when upgrading Flow\n          parentIDStack = [];\n          throw err;\n        } finally {\n          if (parentIDStack.length === 0) {\n            const rootID = internalInstanceToRootIDMap.get(internalInstance);\n\n            if (rootID === undefined) {\n              throw new Error('Expected to find root ID.');\n            }\n\n            flushPendingEvents(rootID);\n          }\n        }\n      }\n\n    });\n  }\n\n  function cleanup() {\n    if (oldReconcilerMethods !== null) {\n      if (renderer.Component) {\n        restoreMany(renderer.Component.Mixin, oldReconcilerMethods);\n      } else {\n        restoreMany(renderer.Reconciler, oldReconcilerMethods);\n      }\n    }\n\n    oldReconcilerMethods = null;\n  }\n\n  function recordMount(internalInstance, id, parentID) {\n    const isRoot = parentID === 0;\n\n    if (constants[\"G\" /* __DEBUG__ */]) {\n      console.log('%crecordMount()', 'color: green; font-weight: bold;', id, getData(internalInstance).displayName);\n    }\n\n    if (isRoot) {\n      // TODO Is this right? For all versions?\n      const hasOwnerMetadata = internalInstance._currentElement != null && internalInstance._currentElement._owner != null;\n      pushOperation(constants[\"y\" /* TREE_OPERATION_ADD */]);\n      pushOperation(id);\n      pushOperation(types[\"m\" /* ElementTypeRoot */]);\n      pushOperation(0); // StrictMode compliant?\n\n      pushOperation(0); // Profiling flag\n\n      pushOperation(0); // StrictMode supported?\n\n      pushOperation(hasOwnerMetadata ? 1 : 0);\n    } else {\n      const type = getElementType(internalInstance);\n      const {\n        displayName,\n        key\n      } = getData(internalInstance);\n      const ownerID = internalInstance._currentElement != null && internalInstance._currentElement._owner != null ? getID(internalInstance._currentElement._owner) : 0;\n      const displayNameStringID = getStringID(displayName);\n      const keyStringID = getStringID(key);\n      pushOperation(constants[\"y\" /* TREE_OPERATION_ADD */]);\n      pushOperation(id);\n      pushOperation(type);\n      pushOperation(parentID);\n      pushOperation(ownerID);\n      pushOperation(displayNameStringID);\n      pushOperation(keyStringID);\n    }\n  }\n\n  function recordReorder(internalInstance, id, nextChildren) {\n    pushOperation(constants[\"B\" /* TREE_OPERATION_REORDER_CHILDREN */]);\n    pushOperation(id);\n    const nextChildIDs = nextChildren.map(getID);\n    pushOperation(nextChildIDs.length);\n\n    for (let i = 0; i < nextChildIDs.length; i++) {\n      pushOperation(nextChildIDs[i]);\n    }\n  }\n\n  function recordUnmount(internalInstance, id) {\n    pendingUnmountedIDs.push(id);\n    idToInternalInstanceMap.delete(id);\n  }\n\n  function crawlAndRecordInitialMounts(id, parentID, rootID) {\n    if (constants[\"G\" /* __DEBUG__ */]) {\n      console.group('crawlAndRecordInitialMounts() id:', id);\n    }\n\n    const internalInstance = idToInternalInstanceMap.get(id);\n\n    if (internalInstance != null) {\n      internalInstanceToRootIDMap.set(internalInstance, rootID);\n      recordMount(internalInstance, id, parentID);\n      getChildren(internalInstance).forEach(child => crawlAndRecordInitialMounts(getID(child), id, rootID));\n    }\n\n    if (constants[\"G\" /* __DEBUG__ */]) {\n      console.groupEnd();\n    }\n  }\n\n  function flushInitialOperations() {\n    // Crawl roots though and register any nodes that mounted before we were injected.\n    const roots = renderer.Mount._instancesByReactRootID || renderer.Mount._instancesByContainerID;\n\n    for (const key in roots) {\n      const internalInstance = roots[key];\n      const id = getID(internalInstance);\n      crawlAndRecordInitialMounts(id, 0, id);\n      flushPendingEvents(id);\n    }\n  }\n\n  const pendingOperations = [];\n  const pendingStringTable = new Map();\n  let pendingUnmountedIDs = [];\n  let pendingStringTableLength = 0;\n  let pendingUnmountedRootID = null;\n\n  function flushPendingEvents(rootID) {\n    if (pendingOperations.length === 0 && pendingUnmountedIDs.length === 0 && pendingUnmountedRootID === null) {\n      return;\n    }\n\n    const numUnmountIDs = pendingUnmountedIDs.length + (pendingUnmountedRootID === null ? 0 : 1);\n    const operations = new Array( // Identify which renderer this update is coming from.\n    2 + // [rendererID, rootFiberID]\n    // How big is the string table?\n    1 + // [stringTableLength]\n    // Then goes the actual string table.\n    pendingStringTableLength + ( // All unmounts are batched in a single message.\n    // [TREE_OPERATION_REMOVE, removedIDLength, ...ids]\n    numUnmountIDs > 0 ? 2 + numUnmountIDs : 0) + // Mount operations\n    pendingOperations.length); // Identify which renderer this update is coming from.\n    // This enables roots to be mapped to renderers,\n    // Which in turn enables fiber properations, states, and hooks to be inspected.\n\n    let i = 0;\n    operations[i++] = rendererID;\n    operations[i++] = rootID; // Now fill in the string table.\n    // [stringTableLength, str1Length, ...str1, str2Length, ...str2, ...]\n\n    operations[i++] = pendingStringTableLength;\n    pendingStringTable.forEach((value, key) => {\n      operations[i++] = key.length;\n      const encodedKey = Object(src_utils[\"A\" /* utfEncodeString */])(key);\n\n      for (let j = 0; j < encodedKey.length; j++) {\n        operations[i + j] = encodedKey[j];\n      }\n\n      i += key.length;\n    });\n\n    if (numUnmountIDs > 0) {\n      // All unmounts except roots are batched in a single message.\n      operations[i++] = constants[\"z\" /* TREE_OPERATION_REMOVE */]; // The first number is how many unmounted IDs we're gonna send.\n\n      operations[i++] = numUnmountIDs; // Fill in the unmounts\n\n      for (let j = 0; j < pendingUnmountedIDs.length; j++) {\n        operations[i++] = pendingUnmountedIDs[j];\n      } // The root ID should always be unmounted last.\n\n\n      if (pendingUnmountedRootID !== null) {\n        operations[i] = pendingUnmountedRootID;\n        i++;\n      }\n    } // Fill in the rest of the operations.\n\n\n    for (let j = 0; j < pendingOperations.length; j++) {\n      operations[i + j] = pendingOperations[j];\n    }\n\n    i += pendingOperations.length;\n\n    if (constants[\"G\" /* __DEBUG__ */]) {\n      Object(src_utils[\"t\" /* printOperationsArray */])(operations);\n    } // If we've already connected to the frontend, just pass the operations through.\n\n\n    hook.emit('operations', operations);\n    pendingOperations.length = 0;\n    pendingUnmountedIDs = [];\n    pendingUnmountedRootID = null;\n    pendingStringTable.clear();\n    pendingStringTableLength = 0;\n  }\n\n  function pushOperation(op) {\n    if (false) {}\n\n    pendingOperations.push(op);\n  }\n\n  function getStringID(str) {\n    if (str === null) {\n      return 0;\n    }\n\n    const existingID = pendingStringTable.get(str);\n\n    if (existingID !== undefined) {\n      return existingID;\n    }\n\n    const stringID = pendingStringTable.size + 1;\n    pendingStringTable.set(str, stringID); // The string table total length needs to account\n    // both for the string length, and for the array item\n    // that contains the length itself. Hence + 1.\n\n    pendingStringTableLength += str.length + 1;\n    return stringID;\n  }\n\n  let currentlyInspectedElementID = null;\n  let currentlyInspectedPaths = {}; // Track the intersection of currently inspected paths,\n  // so that we can send their data along if the element is re-rendered.\n\n  function mergeInspectedPaths(path) {\n    let current = currentlyInspectedPaths;\n    path.forEach(key => {\n      if (!current[key]) {\n        current[key] = {};\n      }\n\n      current = current[key];\n    });\n  }\n\n  function createIsPathAllowed(key) {\n    // This function helps prevent previously-inspected paths from being dehydrated in updates.\n    // This is important to avoid a bad user experience where expanded toggles collapse on update.\n    return function isPathAllowed(path) {\n      let current = currentlyInspectedPaths[key];\n\n      if (!current) {\n        return false;\n      }\n\n      for (let i = 0; i < path.length; i++) {\n        current = current[path[i]];\n\n        if (!current) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n  } // Fast path props lookup for React Native style editor.\n\n\n  function getInstanceAndStyle(id) {\n    let instance = null;\n    let style = null;\n    const internalInstance = idToInternalInstanceMap.get(id);\n\n    if (internalInstance != null) {\n      instance = internalInstance._instance || null;\n      const element = internalInstance._currentElement;\n\n      if (element != null && element.props != null) {\n        style = element.props.style || null;\n      }\n    }\n\n    return {\n      instance,\n      style\n    };\n  }\n\n  function updateSelectedElement(id) {\n    const internalInstance = idToInternalInstanceMap.get(id);\n\n    if (internalInstance == null) {\n      console.warn(`Could not find instance with id \"${id}\"`);\n      return;\n    }\n\n    switch (getElementType(internalInstance)) {\n      case types[\"e\" /* ElementTypeClass */]:\n        global.$r = internalInstance._instance;\n        break;\n\n      case types[\"h\" /* ElementTypeFunction */]:\n        const element = internalInstance._currentElement;\n\n        if (element == null) {\n          console.warn(`Could not find element with id \"${id}\"`);\n          return;\n        }\n\n        global.$r = {\n          props: element.props,\n          type: element.type\n        };\n        break;\n\n      default:\n        global.$r = null;\n        break;\n    }\n  }\n\n  function storeAsGlobal(id, path, count) {\n    const inspectedElement = inspectElementRaw(id);\n\n    if (inspectedElement !== null) {\n      const value = Object(src_utils[\"n\" /* getInObject */])(inspectedElement, path);\n      const key = `$reactTemp${count}`;\n      window[key] = value;\n      console.log(key);\n      console.log(value);\n    }\n  }\n\n  function copyElementPath(id, path) {\n    const inspectedElement = inspectElementRaw(id);\n\n    if (inspectedElement !== null) {\n      Object(utils[\"b\" /* copyToClipboard */])(Object(src_utils[\"n\" /* getInObject */])(inspectedElement, path));\n    }\n  }\n\n  function inspectElement(requestID, id, path, forceFullData) {\n    if (forceFullData || currentlyInspectedElementID !== id) {\n      currentlyInspectedElementID = id;\n      currentlyInspectedPaths = {};\n    }\n\n    const inspectedElement = inspectElementRaw(id);\n\n    if (inspectedElement === null) {\n      return {\n        id,\n        responseID: requestID,\n        type: 'not-found'\n      };\n    }\n\n    if (path !== null) {\n      mergeInspectedPaths(path);\n    } // Any time an inspected element has an update,\n    // we should update the selected $r value as wel.\n    // Do this before dehydration (cleanForBridge).\n\n\n    updateSelectedElement(id);\n    inspectedElement.context = Object(utils[\"a\" /* cleanForBridge */])(inspectedElement.context, createIsPathAllowed('context'));\n    inspectedElement.props = Object(utils[\"a\" /* cleanForBridge */])(inspectedElement.props, createIsPathAllowed('props'));\n    inspectedElement.state = Object(utils[\"a\" /* cleanForBridge */])(inspectedElement.state, createIsPathAllowed('state'));\n    return {\n      id,\n      responseID: requestID,\n      type: 'full-data',\n      value: inspectedElement\n    };\n  }\n\n  function inspectElementRaw(id) {\n    const internalInstance = idToInternalInstanceMap.get(id);\n\n    if (internalInstance == null) {\n      return null;\n    }\n\n    const {\n      displayName,\n      key\n    } = getData(internalInstance);\n    const type = getElementType(internalInstance);\n    let context = null;\n    let owners = null;\n    let props = null;\n    let state = null;\n    let source = null;\n    const element = internalInstance._currentElement;\n\n    if (element !== null) {\n      props = element.props;\n      source = element._source != null ? element._source : null;\n      let owner = element._owner;\n\n      if (owner) {\n        owners = [];\n\n        while (owner != null) {\n          owners.push({\n            displayName: getData(owner).displayName || 'Unknown',\n            id: getID(owner),\n            key: element.key,\n            type: getElementType(owner)\n          });\n\n          if (owner._currentElement) {\n            owner = owner._currentElement._owner;\n          }\n        }\n      }\n    }\n\n    const publicInstance = internalInstance._instance;\n\n    if (publicInstance != null) {\n      context = publicInstance.context || null;\n      state = publicInstance.state || null;\n    } // Not implemented\n\n\n    const errors = [];\n    const warnings = [];\n    return {\n      id,\n      // Does the current renderer support editable hooks and function props?\n      canEditHooks: false,\n      canEditFunctionProps: false,\n      // Does the current renderer support advanced editing interface?\n      canEditHooksAndDeletePaths: false,\n      canEditHooksAndRenamePaths: false,\n      canEditFunctionPropsDeletePaths: false,\n      canEditFunctionPropsRenamePaths: false,\n      // Toggle error boundary did not exist in legacy versions\n      canToggleError: false,\n      isErrored: false,\n      targetErrorBoundaryID: null,\n      // Suspense did not exist in legacy versions\n      canToggleSuspense: false,\n      // Can view component source location.\n      canViewSource: type === types[\"e\" /* ElementTypeClass */] || type === types[\"h\" /* ElementTypeFunction */],\n      // Only legacy context exists in legacy versions.\n      hasLegacyContext: true,\n      displayName: displayName,\n      type: type,\n      key: key != null ? key : null,\n      // Inspectable properties.\n      context,\n      hooks: null,\n      props,\n      state,\n      errors,\n      warnings,\n      // List of owners\n      owners,\n      // Location of component in source code.\n      source,\n      rootType: null,\n      rendererPackageName: null,\n      rendererVersion: null,\n      plugins: {\n        stylex: null\n      }\n    };\n  }\n\n  function logElementToConsole(id) {\n    const result = inspectElementRaw(id);\n\n    if (result === null) {\n      console.warn(`Could not find element with id \"${id}\"`);\n      return;\n    }\n\n    const supportsGroup = typeof console.groupCollapsed === 'function';\n\n    if (supportsGroup) {\n      console.groupCollapsed(`[Click to expand] %c<${result.displayName || 'Component'} />`, // --dom-tag-name-color is the CSS variable Chrome styles HTML elements with in the console.\n      'color: var(--dom-tag-name-color); font-weight: normal;');\n    }\n\n    if (result.props !== null) {\n      console.log('Props:', result.props);\n    }\n\n    if (result.state !== null) {\n      console.log('State:', result.state);\n    }\n\n    if (result.context !== null) {\n      console.log('Context:', result.context);\n    }\n\n    const nativeNode = findNativeNodeForInternalID(id);\n\n    if (nativeNode !== null) {\n      console.log('Node:', nativeNode);\n    }\n\n    if (window.chrome || /firefox/i.test(navigator.userAgent)) {\n      console.log('Right-click any value to save it as a global variable for further inspection.');\n    }\n\n    if (supportsGroup) {\n      console.groupEnd();\n    }\n  }\n\n  function prepareViewAttributeSource(id, path) {\n    const inspectedElement = inspectElementRaw(id);\n\n    if (inspectedElement !== null) {\n      window.$attribute = Object(src_utils[\"n\" /* getInObject */])(inspectedElement, path);\n    }\n  }\n\n  function prepareViewElementSource(id) {\n    const internalInstance = idToInternalInstanceMap.get(id);\n\n    if (internalInstance == null) {\n      console.warn(`Could not find instance with id \"${id}\"`);\n      return;\n    }\n\n    const element = internalInstance._currentElement;\n\n    if (element == null) {\n      console.warn(`Could not find element with id \"${id}\"`);\n      return;\n    }\n\n    global.$type = element.type;\n  }\n\n  function deletePath(type, id, hookID, path) {\n    const internalInstance = idToInternalInstanceMap.get(id);\n\n    if (internalInstance != null) {\n      const publicInstance = internalInstance._instance;\n\n      if (publicInstance != null) {\n        switch (type) {\n          case 'context':\n            Object(src_utils[\"c\" /* deletePathInObject */])(publicInstance.context, path);\n            forceUpdate(publicInstance);\n            break;\n\n          case 'hooks':\n            throw new Error('Hooks not supported by this renderer');\n\n          case 'props':\n            const element = internalInstance._currentElement;\n            internalInstance._currentElement = { ...element,\n              props: Object(utils[\"c\" /* copyWithDelete */])(element.props, path)\n            };\n            forceUpdate(publicInstance);\n            break;\n\n          case 'state':\n            Object(src_utils[\"c\" /* deletePathInObject */])(publicInstance.state, path);\n            forceUpdate(publicInstance);\n            break;\n        }\n      }\n    }\n  }\n\n  function renamePath(type, id, hookID, oldPath, newPath) {\n    const internalInstance = idToInternalInstanceMap.get(id);\n\n    if (internalInstance != null) {\n      const publicInstance = internalInstance._instance;\n\n      if (publicInstance != null) {\n        switch (type) {\n          case 'context':\n            Object(src_utils[\"u\" /* renamePathInObject */])(publicInstance.context, oldPath, newPath);\n            forceUpdate(publicInstance);\n            break;\n\n          case 'hooks':\n            throw new Error('Hooks not supported by this renderer');\n\n          case 'props':\n            const element = internalInstance._currentElement;\n            internalInstance._currentElement = { ...element,\n              props: Object(utils[\"d\" /* copyWithRename */])(element.props, oldPath, newPath)\n            };\n            forceUpdate(publicInstance);\n            break;\n\n          case 'state':\n            Object(src_utils[\"u\" /* renamePathInObject */])(publicInstance.state, oldPath, newPath);\n            forceUpdate(publicInstance);\n            break;\n        }\n      }\n    }\n  }\n\n  function overrideValueAtPath(type, id, hookID, path, value) {\n    const internalInstance = idToInternalInstanceMap.get(id);\n\n    if (internalInstance != null) {\n      const publicInstance = internalInstance._instance;\n\n      if (publicInstance != null) {\n        switch (type) {\n          case 'context':\n            Object(src_utils[\"w\" /* setInObject */])(publicInstance.context, path, value);\n            forceUpdate(publicInstance);\n            break;\n\n          case 'hooks':\n            throw new Error('Hooks not supported by this renderer');\n\n          case 'props':\n            const element = internalInstance._currentElement;\n            internalInstance._currentElement = { ...element,\n              props: Object(utils[\"e\" /* copyWithSet */])(element.props, path, value)\n            };\n            forceUpdate(publicInstance);\n            break;\n\n          case 'state':\n            Object(src_utils[\"w\" /* setInObject */])(publicInstance.state, path, value);\n            forceUpdate(publicInstance);\n            break;\n        }\n      }\n    }\n  } // v16+ only features\n\n\n  const getProfilingData = () => {\n    throw new Error('getProfilingData not supported by this renderer');\n  };\n\n  const handleCommitFiberRoot = () => {\n    throw new Error('handleCommitFiberRoot not supported by this renderer');\n  };\n\n  const handleCommitFiberUnmount = () => {\n    throw new Error('handleCommitFiberUnmount not supported by this renderer');\n  };\n\n  const handlePostCommitFiberRoot = () => {\n    throw new Error('handlePostCommitFiberRoot not supported by this renderer');\n  };\n\n  const overrideError = () => {\n    throw new Error('overrideError not supported by this renderer');\n  };\n\n  const overrideSuspense = () => {\n    throw new Error('overrideSuspense not supported by this renderer');\n  };\n\n  const startProfiling = () => {// Do not throw, since this would break a multi-root scenario where v15 and v16 were both present.\n  };\n\n  const stopProfiling = () => {// Do not throw, since this would break a multi-root scenario where v15 and v16 were both present.\n  };\n\n  function getBestMatchForTrackedPath() {\n    // Not implemented.\n    return null;\n  }\n\n  function getPathForElement(id) {\n    // Not implemented.\n    return null;\n  }\n\n  function updateComponentFilters(componentFilters) {// Not implemented.\n  }\n\n  function setTraceUpdatesEnabled(enabled) {// Not implemented.\n  }\n\n  function setTrackedPath(path) {// Not implemented.\n  }\n\n  function getOwnersList(id) {\n    // Not implemented.\n    return null;\n  }\n\n  function clearErrorsAndWarnings() {// Not implemented\n  }\n\n  function clearErrorsForFiberID(id) {// Not implemented\n  }\n\n  function clearWarningsForFiberID(id) {// Not implemented\n  }\n\n  function patchConsoleForStrictMode() {}\n\n  function unpatchConsoleForStrictMode() {}\n\n  return {\n    clearErrorsAndWarnings,\n    clearErrorsForFiberID,\n    clearWarningsForFiberID,\n    cleanup,\n    copyElementPath,\n    deletePath,\n    flushInitialOperations,\n    getBestMatchForTrackedPath,\n    getDisplayNameForFiberID,\n    getFiberForNative,\n    getFiberIDForNative: getInternalIDForNative,\n    getInstanceAndStyle,\n    findNativeNodesForFiberID: id => {\n      const nativeNode = findNativeNodeForInternalID(id);\n      return nativeNode == null ? null : [nativeNode];\n    },\n    getOwnersList,\n    getPathForElement,\n    getProfilingData,\n    handleCommitFiberRoot,\n    handleCommitFiberUnmount,\n    handlePostCommitFiberRoot,\n    inspectElement,\n    logElementToConsole,\n    overrideError,\n    overrideSuspense,\n    overrideValueAtPath,\n    renamePath,\n    patchConsoleForStrictMode,\n    prepareViewAttributeSource,\n    prepareViewElementSource,\n    renderer,\n    setTraceUpdatesEnabled,\n    setTrackedPath,\n    startProfiling,\n    stopProfiling,\n    storeAsGlobal,\n    unpatchConsoleForStrictMode,\n    updateComponentFilters\n  };\n}\n// CONCATENATED MODULE: ../react-devtools-shared/src/backend/index.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\nfunction initBackend(hook, agent, global) {\n  if (hook == null) {\n    // DevTools didn't get injected into this page (maybe b'c of the contentType).\n    return () => {};\n  }\n\n  const subs = [hook.sub('renderer-attached', ({\n    id,\n    renderer,\n    rendererInterface\n  }) => {\n    agent.setRendererInterface(id, rendererInterface); // Now that the Store and the renderer interface are connected,\n    // it's time to flush the pending operation codes to the frontend.\n\n    rendererInterface.flushInitialOperations();\n  }), hook.sub('unsupported-renderer-version', id => {\n    agent.onUnsupportedRenderer(id);\n  }), hook.sub('fastRefreshScheduled', agent.onFastRefreshScheduled), hook.sub('operations', agent.onHookOperations), hook.sub('traceUpdates', agent.onTraceUpdates) // TODO Add additional subscriptions required for profiling mode\n  ];\n\n  const attachRenderer = (id, renderer) => {\n    let rendererInterface = hook.rendererInterfaces.get(id); // Inject any not-yet-injected renderers (if we didn't reload-and-profile)\n\n    if (rendererInterface == null) {\n      if (typeof renderer.findFiberByHostInstance === 'function') {\n        // react-reconciler v16+\n        rendererInterface = Object(backend_renderer[\"a\" /* attach */])(hook, id, renderer, global);\n      } else if (renderer.ComponentTree) {\n        // react-dom v15\n        rendererInterface = renderer_attach(hook, id, renderer, global);\n      } else {// Older react-dom or other unsupported renderer version\n      }\n\n      if (rendererInterface != null) {\n        hook.rendererInterfaces.set(id, rendererInterface);\n      }\n    } // Notify the DevTools frontend about new renderers.\n    // This includes any that were attached early (via __REACT_DEVTOOLS_ATTACH__).\n\n\n    if (rendererInterface != null) {\n      hook.emit('renderer-attached', {\n        id,\n        renderer,\n        rendererInterface\n      });\n    } else {\n      hook.emit('unsupported-renderer-version', id);\n    }\n  }; // Connect renderers that have already injected themselves.\n\n\n  hook.renderers.forEach((renderer, id) => {\n    attachRenderer(id, renderer);\n  }); // Connect any new renderers that injected themselves.\n\n  subs.push(hook.sub('renderer', ({\n    id,\n    renderer\n  }) => {\n    attachRenderer(id, renderer);\n  }));\n  hook.emit('react-devtools', agent);\n  hook.reactDevtoolsAgent = agent;\n\n  const onAgentShutdown = () => {\n    subs.forEach(fn => fn());\n    hook.rendererInterfaces.forEach(rendererInterface => {\n      rendererInterface.cleanup();\n    });\n    hook.reactDevtoolsAgent = null;\n  };\n\n  agent.addListener('shutdown', onAgentShutdown);\n  subs.push(() => {\n    agent.removeListener('shutdown', onAgentShutdown);\n  });\n  return () => {\n    subs.forEach(fn => fn());\n  };\n}\n// CONCATENATED MODULE: ../react-devtools-shared/src/hook.js\n/**\n * Install the hook on window, which is an event emitter.\n * Note because Chrome content scripts cannot directly modify the window object,\n * we are evaling this function by inserting a script tag.\n * That's why we have to inline the whole event emitter implementation,\n * the string format implementation, and part of the console implementation here.\n *\n * \n */\n\nfunction installHook(target) {\n  if (target.hasOwnProperty('__REACT_DEVTOOLS_GLOBAL_HOOK__')) {\n    return null;\n  }\n\n  let targetConsole = console;\n  let targetConsoleMethods = {};\n\n  for (const method in console) {\n    targetConsoleMethods[method] = console[method];\n  }\n\n  function dangerous_setTargetConsoleForTesting(targetConsoleForTesting) {\n    targetConsole = targetConsoleForTesting;\n    targetConsoleMethods = {};\n\n    for (const method in targetConsole) {\n      targetConsoleMethods[method] = console[method];\n    }\n  }\n\n  function detectReactBuildType(renderer) {\n    try {\n      if (typeof renderer.version === 'string') {\n        // React DOM Fiber (16+)\n        if (renderer.bundleType > 0) {\n          // This is not a production build.\n          // We are currently only using 0 (PROD) and 1 (DEV)\n          // but might add 2 (PROFILE) in the future.\n          return 'development';\n        } // React 16 uses flat bundles. If we report the bundle as production\n        // version, it means we also minified and envified it ourselves.\n\n\n        return 'production'; // Note: There is still a risk that the CommonJS entry point has not\n        // been envified or uglified. In this case the user would have *both*\n        // development and production bundle, but only the prod one would run.\n        // This would be really bad. We have a separate check for this because\n        // it happens *outside* of the renderer injection. See `checkDCE` below.\n      } // $FlowFixMe[method-unbinding]\n\n\n      const toString = Function.prototype.toString;\n\n      if (renderer.Mount && renderer.Mount._renderNewRootComponent) {\n        // React DOM Stack\n        const renderRootCode = toString.call(renderer.Mount._renderNewRootComponent); // Filter out bad results (if that is even possible):\n\n        if (renderRootCode.indexOf('function') !== 0) {\n          // Hope for the best if we're not sure.\n          return 'production';\n        } // Check for React DOM Stack < 15.1.0 in development.\n        // If it contains \"storedMeasure\" call, it's wrapped in ReactPerf (DEV only).\n        // This would be true even if it's minified, as method name still matches.\n\n\n        if (renderRootCode.indexOf('storedMeasure') !== -1) {\n          return 'development';\n        } // For other versions (and configurations) it's not so easy.\n        // Let's quickly exclude proper production builds.\n        // If it contains a warning message, it's either a DEV build,\n        // or an PROD build without proper dead code elimination.\n\n\n        if (renderRootCode.indexOf('should be a pure function') !== -1) {\n          // Now how do we tell a DEV build from a bad PROD build?\n          // If we see NODE_ENV, we're going to assume this is a dev build\n          // because most likely it is referring to an empty shim.\n          if (renderRootCode.indexOf('NODE_ENV') !== -1) {\n            return 'development';\n          } // If we see \"development\", we're dealing with an envified DEV build\n          // (such as the official React DEV UMD).\n\n\n          if (renderRootCode.indexOf('development') !== -1) {\n            return 'development';\n          } // I've seen process.env.NODE_ENV !== 'production' being smartly\n          // replaced by `true` in DEV by Webpack. I don't know how that\n          // works but we can safely guard against it because `true` was\n          // never used in the function source since it was written.\n\n\n          if (renderRootCode.indexOf('true') !== -1) {\n            return 'development';\n          } // By now either it is a production build that has not been minified,\n          // or (worse) this is a minified development build using non-standard\n          // environment (e.g. \"staging\"). We're going to look at whether\n          // the function argument name is mangled:\n\n\n          if ( // 0.13 to 15\n          renderRootCode.indexOf('nextElement') !== -1 || // 0.12\n          renderRootCode.indexOf('nextComponent') !== -1) {\n            // We can't be certain whether this is a development build or not,\n            // but it is definitely unminified.\n            return 'unminified';\n          } else {\n            // This is likely a minified development build.\n            return 'development';\n          }\n        } // By now we know that it's envified and dead code elimination worked,\n        // but what if it's still not minified? (Is this even possible?)\n        // Let's check matches for the first argument name.\n\n\n        if ( // 0.13 to 15\n        renderRootCode.indexOf('nextElement') !== -1 || // 0.12\n        renderRootCode.indexOf('nextComponent') !== -1) {\n          return 'unminified';\n        } // Seems like we're using the production version.\n        // However, the branch above is Stack-only so this is 15 or earlier.\n\n\n        return 'outdated';\n      }\n    } catch (err) {// Weird environments may exist.\n      // This code needs a higher fault tolerance\n      // because it runs even with closed DevTools.\n      // TODO: should we catch errors in all injected code, and not just this part?\n    }\n\n    return 'production';\n  }\n\n  function checkDCE(fn) {\n    // This runs for production versions of React.\n    // Needs to be super safe.\n    try {\n      // $FlowFixMe[method-unbinding]\n      const toString = Function.prototype.toString;\n      const code = toString.call(fn); // This is a string embedded in the passed function under DEV-only\n      // condition. However the function executes only in PROD. Therefore,\n      // if we see it, dead code elimination did not work.\n\n      if (code.indexOf('^_^') > -1) {\n        // Remember to report during next injection.\n        hasDetectedBadDCE = true; // Bonus: throw an exception hoping that it gets picked up by a reporting system.\n        // Not synchronously so that it doesn't break the calling code.\n\n        setTimeout(function () {\n          throw new Error('React is running in production mode, but dead code ' + 'elimination has not been applied. Read how to correctly ' + 'configure React for production: ' + 'https://reactjs.org/link/perf-use-production-build');\n        });\n      }\n    } catch (err) {}\n  } // NOTE: KEEP IN SYNC with src/backend/utils.js\n\n\n  function formatWithStyles(inputArgs, style) {\n    if (inputArgs === undefined || inputArgs === null || inputArgs.length === 0 || // Matches any of %c but not %%c\n    typeof inputArgs[0] === 'string' && inputArgs[0].match(/([^%]|^)(%c)/g) || style === undefined) {\n      return inputArgs;\n    } // Matches any of %(o|O|d|i|s|f), but not %%(o|O|d|i|s|f)\n\n\n    const REGEXP = /([^%]|^)((%%)*)(%([oOdisf]))/g;\n\n    if (typeof inputArgs[0] === 'string' && inputArgs[0].match(REGEXP)) {\n      return [`%c${inputArgs[0]}`, style, ...inputArgs.slice(1)];\n    } else {\n      const firstArg = inputArgs.reduce((formatStr, elem, i) => {\n        if (i > 0) {\n          formatStr += ' ';\n        }\n\n        switch (typeof elem) {\n          case 'string':\n          case 'boolean':\n          case 'symbol':\n            return formatStr += '%s';\n\n          case 'number':\n            const formatting = Number.isInteger(elem) ? '%i' : '%f';\n            return formatStr += formatting;\n\n          default:\n            return formatStr += '%o';\n        }\n      }, '%c');\n      return [firstArg, style, ...inputArgs];\n    }\n  }\n\n  let unpatchFn = null; // NOTE: KEEP IN SYNC with src/backend/console.js:patchForStrictMode\n  // This function hides or dims console logs during the initial double renderer\n  // in Strict Mode. We need this function because during initial render,\n  // React and DevTools are connecting and the renderer interface isn't avaiable\n  // and we want to be able to have consistent logging behavior for double logs\n  // during the initial renderer.\n\n  function patchConsoleForInitialRenderInStrictMode({\n    hideConsoleLogsInStrictMode,\n    browserTheme\n  }) {\n    const overrideConsoleMethods = ['error', 'group', 'groupCollapsed', 'info', 'log', 'trace', 'warn'];\n\n    if (unpatchFn !== null) {\n      // Don't patch twice.\n      return;\n    }\n\n    const originalConsoleMethods = {};\n\n    unpatchFn = () => {\n      for (const method in originalConsoleMethods) {\n        try {\n          targetConsole[method] = originalConsoleMethods[method];\n        } catch (error) {}\n      }\n    };\n\n    overrideConsoleMethods.forEach(method => {\n      try {\n        const originalMethod = originalConsoleMethods[method] = targetConsole[method].__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ ? targetConsole[method].__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ : targetConsole[method];\n\n        const overrideMethod = (...args) => {\n          if (!hideConsoleLogsInStrictMode) {\n            // Dim the text color of the double logs if we're not\n            // hiding them.\n            let color;\n\n            switch (method) {\n              case 'warn':\n                color = browserTheme === 'light' ? \"rgba(250, 180, 50, 0.75)\" : \"rgba(250, 180, 50, 0.5)\";\n                break;\n\n              case 'error':\n                color = browserTheme === 'light' ? \"rgba(250, 123, 130, 0.75)\" : \"rgba(250, 123, 130, 0.5)\";\n                break;\n\n              case 'log':\n              default:\n                color = browserTheme === 'light' ? \"rgba(125, 125, 125, 0.75)\" : \"rgba(125, 125, 125, 0.5)\";\n                break;\n            }\n\n            if (color) {\n              originalMethod(...formatWithStyles(args, `color: ${color}`));\n            } else {\n              throw Error('Console color is not defined');\n            }\n          }\n        };\n\n        overrideMethod.__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ = originalMethod;\n        originalMethod.__REACT_DEVTOOLS_STRICT_MODE_OVERRIDE_METHOD__ = overrideMethod;\n        targetConsole[method] = overrideMethod;\n      } catch (error) {}\n    });\n  } // NOTE: KEEP IN SYNC with src/backend/console.js:unpatchForStrictMode\n\n\n  function unpatchConsoleForInitialRenderInStrictMode() {\n    if (unpatchFn !== null) {\n      unpatchFn();\n      unpatchFn = null;\n    }\n  }\n\n  let uidCounter = 0;\n\n  function inject(renderer) {\n    const id = ++uidCounter;\n    renderers.set(id, renderer);\n    const reactBuildType = hasDetectedBadDCE ? 'deadcode' : detectReactBuildType(renderer); // Patching the console enables DevTools to do a few useful things:\n    // * Append component stacks to warnings and error messages\n    // * Disabling or marking logs during a double render in Strict Mode\n    // * Disable logging during re-renders to inspect hooks (see inspectHooksOfFiber)\n    //\n    // For React Native, we intentionally patch early (during injection).\n    // This provides React Native developers with components stacks even if they don't run DevTools.\n    //\n    // This won't work for DOM though, since this entire file is eval'ed and inserted as a script tag.\n    // In that case, we'll only patch parts of the console that are needed during the first render\n    // and patch everything else later (when the frontend attaches).\n    //\n    // Don't patch in test environments because we don't want to interfere with Jest's own console overrides.\n    //\n    // Note that because this function is inlined, this conditional check must only use static booleans.\n    // Otherwise the extension will throw with an undefined error.\n    // (See comments in the try/catch below for more context on inlining.)\n\n    if (true) {\n      try {\n        // The installHook() function is injected by being stringified in the browser,\n        // so imports outside of this function do not get included.\n        //\n        // Normally we could check \"typeof patchConsole === 'function'\",\n        // but Webpack wraps imports with an object (e.g. _backend_console__WEBPACK_IMPORTED_MODULE_0__)\n        // and the object itself will be undefined as well for the reasons mentioned above,\n        // so we use try/catch instead.\n        Object(backend_console[\"d\" /* registerRenderer */])(renderer);\n        Object(backend_console[\"b\" /* patchConsoleUsingWindowValues */])();\n      } catch (error) {}\n    } // If we have just reloaded to profile, we need to inject the renderer interface before the app loads.\n    // Otherwise the renderer won't yet exist and we can skip this step.\n\n\n    const attach = target.__REACT_DEVTOOLS_ATTACH__;\n\n    if (typeof attach === 'function') {\n      const rendererInterface = attach(hook, id, renderer, target);\n      hook.rendererInterfaces.set(id, rendererInterface);\n    }\n\n    hook.emit('renderer', {\n      id,\n      renderer,\n      reactBuildType\n    });\n    return id;\n  }\n\n  let hasDetectedBadDCE = false;\n\n  function sub(event, fn) {\n    hook.on(event, fn);\n    return () => hook.off(event, fn);\n  }\n\n  function on(event, fn) {\n    if (!listeners[event]) {\n      listeners[event] = [];\n    }\n\n    listeners[event].push(fn);\n  }\n\n  function off(event, fn) {\n    if (!listeners[event]) {\n      return;\n    }\n\n    const index = listeners[event].indexOf(fn);\n\n    if (index !== -1) {\n      listeners[event].splice(index, 1);\n    }\n\n    if (!listeners[event].length) {\n      delete listeners[event];\n    }\n  }\n\n  function emit(event, data) {\n    if (listeners[event]) {\n      listeners[event].map(fn => fn(data));\n    }\n  }\n\n  function getFiberRoots(rendererID) {\n    const roots = fiberRoots;\n\n    if (!roots[rendererID]) {\n      roots[rendererID] = new Set();\n    }\n\n    return roots[rendererID];\n  }\n\n  function onCommitFiberUnmount(rendererID, fiber) {\n    const rendererInterface = rendererInterfaces.get(rendererID);\n\n    if (rendererInterface != null) {\n      rendererInterface.handleCommitFiberUnmount(fiber);\n    }\n  }\n\n  function onCommitFiberRoot(rendererID, root, priorityLevel) {\n    const mountedRoots = hook.getFiberRoots(rendererID);\n    const current = root.current;\n    const isKnownRoot = mountedRoots.has(root);\n    const isUnmounting = current.memoizedState == null || current.memoizedState.element == null; // Keep track of mounted roots so we can hydrate when DevTools connect.\n\n    if (!isKnownRoot && !isUnmounting) {\n      mountedRoots.add(root);\n    } else if (isKnownRoot && isUnmounting) {\n      mountedRoots.delete(root);\n    }\n\n    const rendererInterface = rendererInterfaces.get(rendererID);\n\n    if (rendererInterface != null) {\n      rendererInterface.handleCommitFiberRoot(root, priorityLevel);\n    }\n  }\n\n  function onPostCommitFiberRoot(rendererID, root) {\n    const rendererInterface = rendererInterfaces.get(rendererID);\n\n    if (rendererInterface != null) {\n      rendererInterface.handlePostCommitFiberRoot(root);\n    }\n  }\n\n  function setStrictMode(rendererID, isStrictMode) {\n    const rendererInterface = rendererInterfaces.get(rendererID);\n\n    if (rendererInterface != null) {\n      if (isStrictMode) {\n        rendererInterface.patchConsoleForStrictMode();\n      } else {\n        rendererInterface.unpatchConsoleForStrictMode();\n      }\n    } else {\n      // This should only happen during initial render in the extension before DevTools\n      // finishes its handshake with the injected renderer\n      if (isStrictMode) {\n        const hideConsoleLogsInStrictMode = window.__REACT_DEVTOOLS_HIDE_CONSOLE_LOGS_IN_STRICT_MODE__ === true;\n        const browserTheme = window.__REACT_DEVTOOLS_BROWSER_THEME__;\n        patchConsoleForInitialRenderInStrictMode({\n          hideConsoleLogsInStrictMode,\n          browserTheme\n        });\n      } else {\n        unpatchConsoleForInitialRenderInStrictMode();\n      }\n    }\n  }\n\n  const openModuleRangesStack = [];\n  const moduleRanges = [];\n\n  function getTopStackFrameString(error) {\n    const frames = error.stack.split('\\n');\n    const frame = frames.length > 1 ? frames[1] : null;\n    return frame;\n  }\n\n  function getInternalModuleRanges() {\n    return moduleRanges;\n  }\n\n  function registerInternalModuleStart(error) {\n    const startStackFrame = getTopStackFrameString(error);\n\n    if (startStackFrame !== null) {\n      openModuleRangesStack.push(startStackFrame);\n    }\n  }\n\n  function registerInternalModuleStop(error) {\n    if (openModuleRangesStack.length > 0) {\n      const startStackFrame = openModuleRangesStack.pop();\n      const stopStackFrame = getTopStackFrameString(error);\n\n      if (stopStackFrame !== null) {\n        moduleRanges.push([startStackFrame, stopStackFrame]);\n      }\n    }\n  } // TODO: More meaningful names for \"rendererInterfaces\" and \"renderers\".\n\n\n  const fiberRoots = {};\n  const rendererInterfaces = new Map();\n  const listeners = {};\n  const renderers = new Map();\n  const hook = {\n    rendererInterfaces,\n    listeners,\n    // Fast Refresh for web relies on this.\n    renderers,\n    emit,\n    getFiberRoots,\n    inject,\n    on,\n    off,\n    sub,\n    // This is a legacy flag.\n    // React v16 checks the hook for this to ensure DevTools is new enough.\n    supportsFiber: true,\n    // React calls these methods.\n    checkDCE,\n    onCommitFiberUnmount,\n    onCommitFiberRoot,\n    onPostCommitFiberRoot,\n    setStrictMode,\n    // Schedule Profiler runtime helpers.\n    // These internal React modules to report their own boundaries\n    // which in turn enables the profiler to dim or filter internal frames.\n    getInternalModuleRanges,\n    registerInternalModuleStart,\n    registerInternalModuleStop\n  };\n\n  if (false) {}\n\n  Object.defineProperty(target, '__REACT_DEVTOOLS_GLOBAL_HOOK__', {\n    // This property needs to be configurable for the test environment,\n    // else we won't be able to delete and recreate it between tests.\n    configurable: false,\n    enumerable: false,\n\n    get() {\n      return hook;\n    }\n\n  });\n  return hook;\n}\n// CONCATENATED MODULE: ../react-devtools-shared/src/backend/NativeStyleEditor/resolveBoxStyle.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n/**\n * This mirrors react-native/Libraries/Inspector/resolveBoxStyle.js (but without RTL support).\n *\n * Resolve a style property into it's component parts, e.g.\n *\n * resolveBoxStyle('margin', {margin: 5, marginBottom: 10})\n * -> {top: 5, left: 5, right: 5, bottom: 10}\n */\nfunction resolveBoxStyle(prefix, style) {\n  let hasParts = false;\n  const result = {\n    bottom: 0,\n    left: 0,\n    right: 0,\n    top: 0\n  };\n  const styleForAll = style[prefix];\n\n  if (styleForAll != null) {\n    // eslint-disable-next-line no-for-of-loops/no-for-of-loops\n    for (const key of Object.keys(result)) {\n      result[key] = styleForAll;\n    }\n\n    hasParts = true;\n  }\n\n  const styleForHorizontal = style[prefix + 'Horizontal'];\n\n  if (styleForHorizontal != null) {\n    result.left = styleForHorizontal;\n    result.right = styleForHorizontal;\n    hasParts = true;\n  } else {\n    const styleForLeft = style[prefix + 'Left'];\n\n    if (styleForLeft != null) {\n      result.left = styleForLeft;\n      hasParts = true;\n    }\n\n    const styleForRight = style[prefix + 'Right'];\n\n    if (styleForRight != null) {\n      result.right = styleForRight;\n      hasParts = true;\n    }\n\n    const styleForEnd = style[prefix + 'End'];\n\n    if (styleForEnd != null) {\n      // TODO RTL support\n      result.right = styleForEnd;\n      hasParts = true;\n    }\n\n    const styleForStart = style[prefix + 'Start'];\n\n    if (styleForStart != null) {\n      // TODO RTL support\n      result.left = styleForStart;\n      hasParts = true;\n    }\n  }\n\n  const styleForVertical = style[prefix + 'Vertical'];\n\n  if (styleForVertical != null) {\n    result.bottom = styleForVertical;\n    result.top = styleForVertical;\n    hasParts = true;\n  } else {\n    const styleForBottom = style[prefix + 'Bottom'];\n\n    if (styleForBottom != null) {\n      result.bottom = styleForBottom;\n      hasParts = true;\n    }\n\n    const styleForTop = style[prefix + 'Top'];\n\n    if (styleForTop != null) {\n      result.top = styleForTop;\n      hasParts = true;\n    }\n  }\n\n  return hasParts ? result : null;\n}\n// EXTERNAL MODULE: ../react-devtools-shared/src/isArray.js\nvar isArray = __webpack_require__(20);\n\n// CONCATENATED MODULE: ../react-devtools-shared/src/backend/NativeStyleEditor/setupNativeStyleEditor.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\nfunction setupNativeStyleEditor(bridge, agent, resolveNativeStyle, validAttributes) {\n  bridge.addListener('NativeStyleEditor_measure', ({\n    id,\n    rendererID\n  }) => {\n    measureStyle(agent, bridge, resolveNativeStyle, id, rendererID);\n  });\n  bridge.addListener('NativeStyleEditor_renameAttribute', ({\n    id,\n    rendererID,\n    oldName,\n    newName,\n    value\n  }) => {\n    renameStyle(agent, id, rendererID, oldName, newName, value);\n    setTimeout(() => measureStyle(agent, bridge, resolveNativeStyle, id, rendererID));\n  });\n  bridge.addListener('NativeStyleEditor_setValue', ({\n    id,\n    rendererID,\n    name,\n    value\n  }) => {\n    setStyle(agent, id, rendererID, name, value);\n    setTimeout(() => measureStyle(agent, bridge, resolveNativeStyle, id, rendererID));\n  });\n  bridge.send('isNativeStyleEditorSupported', {\n    isSupported: true,\n    validAttributes\n  });\n}\nconst EMPTY_BOX_STYLE = {\n  top: 0,\n  left: 0,\n  right: 0,\n  bottom: 0\n};\nconst componentIDToStyleOverrides = new Map();\n\nfunction measureStyle(agent, bridge, resolveNativeStyle, id, rendererID) {\n  const data = agent.getInstanceAndStyle({\n    id,\n    rendererID\n  });\n\n  if (!data || !data.style) {\n    bridge.send('NativeStyleEditor_styleAndLayout', {\n      id,\n      layout: null,\n      style: null\n    });\n    return;\n  }\n\n  const {\n    instance,\n    style\n  } = data;\n  let resolvedStyle = resolveNativeStyle(style); // If it's a host component we edited before, amend styles.\n\n  const styleOverrides = componentIDToStyleOverrides.get(id);\n\n  if (styleOverrides != null) {\n    resolvedStyle = Object.assign({}, resolvedStyle, styleOverrides);\n  }\n\n  if (!instance || typeof instance.measure !== 'function') {\n    bridge.send('NativeStyleEditor_styleAndLayout', {\n      id,\n      layout: null,\n      style: resolvedStyle || null\n    });\n    return;\n  }\n\n  instance.measure((x, y, width, height, left, top) => {\n    // RN Android sometimes returns undefined here. Don't send measurements in this case.\n    // https://github.com/jhen0409/react-native-debugger/issues/84#issuecomment-304611817\n    if (typeof x !== 'number') {\n      bridge.send('NativeStyleEditor_styleAndLayout', {\n        id,\n        layout: null,\n        style: resolvedStyle || null\n      });\n      return;\n    }\n\n    const margin = resolvedStyle != null && resolveBoxStyle('margin', resolvedStyle) || EMPTY_BOX_STYLE;\n    const padding = resolvedStyle != null && resolveBoxStyle('padding', resolvedStyle) || EMPTY_BOX_STYLE;\n    bridge.send('NativeStyleEditor_styleAndLayout', {\n      id,\n      layout: {\n        x,\n        y,\n        width,\n        height,\n        left,\n        top,\n        margin,\n        padding\n      },\n      style: resolvedStyle || null\n    });\n  });\n}\n\nfunction shallowClone(object) {\n  const cloned = {};\n\n  for (const n in object) {\n    cloned[n] = object[n];\n  }\n\n  return cloned;\n}\n\nfunction renameStyle(agent, id, rendererID, oldName, newName, value) {\n  const data = agent.getInstanceAndStyle({\n    id,\n    rendererID\n  });\n\n  if (!data || !data.style) {\n    return;\n  }\n\n  const {\n    instance,\n    style\n  } = data;\n  const newStyle = newName ? {\n    [oldName]: undefined,\n    [newName]: value\n  } : {\n    [oldName]: undefined\n  };\n  let customStyle; // TODO It would be nice if the renderer interface abstracted this away somehow.\n\n  if (instance !== null && typeof instance.setNativeProps === 'function') {\n    // In the case of a host component, we need to use setNativeProps().\n    // Remember to \"correct\" resolved styles when we read them next time.\n    const styleOverrides = componentIDToStyleOverrides.get(id);\n\n    if (!styleOverrides) {\n      componentIDToStyleOverrides.set(id, newStyle);\n    } else {\n      Object.assign(styleOverrides, newStyle);\n    } // TODO Fabric does not support setNativeProps; chat with Sebastian or Eli\n\n\n    instance.setNativeProps({\n      style: newStyle\n    });\n  } else if (Object(isArray[\"a\" /* default */])(style)) {\n    const lastIndex = style.length - 1;\n\n    if (typeof style[lastIndex] === 'object' && !Object(isArray[\"a\" /* default */])(style[lastIndex])) {\n      customStyle = shallowClone(style[lastIndex]);\n      delete customStyle[oldName];\n\n      if (newName) {\n        customStyle[newName] = value;\n      } else {\n        customStyle[oldName] = undefined;\n      }\n\n      agent.overrideValueAtPath({\n        type: 'props',\n        id,\n        rendererID,\n        path: ['style', lastIndex],\n        value: customStyle\n      });\n    } else {\n      agent.overrideValueAtPath({\n        type: 'props',\n        id,\n        rendererID,\n        path: ['style'],\n        value: style.concat([newStyle])\n      });\n    }\n  } else if (typeof style === 'object') {\n    customStyle = shallowClone(style);\n    delete customStyle[oldName];\n\n    if (newName) {\n      customStyle[newName] = value;\n    } else {\n      customStyle[oldName] = undefined;\n    }\n\n    agent.overrideValueAtPath({\n      type: 'props',\n      id,\n      rendererID,\n      path: ['style'],\n      value: customStyle\n    });\n  } else {\n    agent.overrideValueAtPath({\n      type: 'props',\n      id,\n      rendererID,\n      path: ['style'],\n      value: [style, newStyle]\n    });\n  }\n\n  agent.emit('hideNativeHighlight');\n}\n\nfunction setStyle(agent, id, rendererID, name, value) {\n  const data = agent.getInstanceAndStyle({\n    id,\n    rendererID\n  });\n\n  if (!data || !data.style) {\n    return;\n  }\n\n  const {\n    instance,\n    style\n  } = data;\n  const newStyle = {\n    [name]: value\n  }; // TODO It would be nice if the renderer interface abstracted this away somehow.\n\n  if (instance !== null && typeof instance.setNativeProps === 'function') {\n    // In the case of a host component, we need to use setNativeProps().\n    // Remember to \"correct\" resolved styles when we read them next time.\n    const styleOverrides = componentIDToStyleOverrides.get(id);\n\n    if (!styleOverrides) {\n      componentIDToStyleOverrides.set(id, newStyle);\n    } else {\n      Object.assign(styleOverrides, newStyle);\n    } // TODO Fabric does not support setNativeProps; chat with Sebastian or Eli\n\n\n    instance.setNativeProps({\n      style: newStyle\n    });\n  } else if (Object(isArray[\"a\" /* default */])(style)) {\n    const lastLength = style.length - 1;\n\n    if (typeof style[lastLength] === 'object' && !Object(isArray[\"a\" /* default */])(style[lastLength])) {\n      agent.overrideValueAtPath({\n        type: 'props',\n        id,\n        rendererID,\n        path: ['style', lastLength, name],\n        value\n      });\n    } else {\n      agent.overrideValueAtPath({\n        type: 'props',\n        id,\n        rendererID,\n        path: ['style'],\n        value: style.concat([newStyle])\n      });\n    }\n  } else {\n    agent.overrideValueAtPath({\n      type: 'props',\n      id,\n      rendererID,\n      path: ['style'],\n      value: [style, newStyle]\n    });\n  }\n\n  agent.emit('hideNativeHighlight');\n}\n// CONCATENATED MODULE: ./src/backend.js\n\n\n\n\n\n\nfunction startActivation(contentWindow, bridge) {\n  // $FlowFixMe[missing-local-annot]\n  const onSavedPreferences = data => {\n    // This is the only message we're listening for,\n    // so it's safe to cleanup after we've received it.\n    bridge.removeListener('savedPreferences', onSavedPreferences);\n    const {\n      appendComponentStack,\n      breakOnConsoleErrors,\n      componentFilters,\n      showInlineWarningsAndErrors,\n      hideConsoleLogsInStrictMode\n    } = data;\n    contentWindow.__REACT_DEVTOOLS_APPEND_COMPONENT_STACK__ = appendComponentStack;\n    contentWindow.__REACT_DEVTOOLS_BREAK_ON_CONSOLE_ERRORS__ = breakOnConsoleErrors;\n    contentWindow.__REACT_DEVTOOLS_COMPONENT_FILTERS__ = componentFilters;\n    contentWindow.__REACT_DEVTOOLS_SHOW_INLINE_WARNINGS_AND_ERRORS__ = showInlineWarningsAndErrors;\n    contentWindow.__REACT_DEVTOOLS_HIDE_CONSOLE_LOGS_IN_STRICT_MODE__ = hideConsoleLogsInStrictMode; // TRICKY\n    // The backend entry point may be required in the context of an iframe or the parent window.\n    // If it's required within the parent window, store the saved values on it as well,\n    // since the injected renderer interface will read from window.\n    // Technically we don't need to store them on the contentWindow in this case,\n    // but it doesn't really hurt anything to store them there too.\n\n    if (contentWindow !== window) {\n      window.__REACT_DEVTOOLS_APPEND_COMPONENT_STACK__ = appendComponentStack;\n      window.__REACT_DEVTOOLS_BREAK_ON_CONSOLE_ERRORS__ = breakOnConsoleErrors;\n      window.__REACT_DEVTOOLS_COMPONENT_FILTERS__ = componentFilters;\n      window.__REACT_DEVTOOLS_SHOW_INLINE_WARNINGS_AND_ERRORS__ = showInlineWarningsAndErrors;\n      window.__REACT_DEVTOOLS_HIDE_CONSOLE_LOGS_IN_STRICT_MODE__ = hideConsoleLogsInStrictMode;\n    }\n\n    finishActivation(contentWindow, bridge);\n  };\n\n  bridge.addListener('savedPreferences', onSavedPreferences); // The backend may be unable to read saved preferences directly,\n  // because they are stored in localStorage within the context of the extension (on the frontend).\n  // Instead it relies on the extension to pass preferences through.\n  // Because we might be in a sandboxed iframe, we have to ask for them by way of postMessage().\n\n  bridge.send('getSavedPreferences');\n}\n\nfunction finishActivation(contentWindow, bridge) {\n  const agent = new agent_Agent(bridge);\n  const hook = contentWindow.__REACT_DEVTOOLS_GLOBAL_HOOK__;\n\n  if (hook) {\n    initBackend(hook, agent, contentWindow); // Setup React Native style editor if a renderer like react-native-web has injected it.\n\n    if (hook.resolveRNStyle) {\n      setupNativeStyleEditor(bridge, agent, hook.resolveRNStyle, hook.nativeStyleEditorValidAttributes);\n    }\n  }\n}\n\nfunction activate(contentWindow, {\n  bridge\n} = {}) {\n  if (bridge == null) {\n    bridge = createBridge(contentWindow);\n  }\n\n  startActivation(contentWindow, bridge);\n}\nfunction createBridge(contentWindow, wall) {\n  const {\n    parent\n  } = contentWindow;\n\n  if (wall == null) {\n    wall = {\n      listen(fn) {\n        // $FlowFixMe[missing-local-annot]\n        const onMessage = ({\n          data\n        }) => {\n          fn(data);\n        };\n\n        contentWindow.addEventListener('message', onMessage);\n        return () => {\n          contentWindow.removeEventListener('message', onMessage);\n        };\n      },\n\n      send(event, payload, transferable) {\n        parent.postMessage({\n          event,\n          payload\n        }, '*', transferable);\n      }\n\n    };\n  }\n\n  return new src_bridge[\"c\" /* default */](wall);\n}\nfunction backend_initialize(contentWindow) {\n  installHook(contentWindow);\n}\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"e\", function() { return /* binding */ getAllEnumerableKeys; });\n__webpack_require__.d(__webpack_exports__, \"s\", function() { return /* binding */ getWrappedDisplayName; });\n__webpack_require__.d(__webpack_exports__, \"k\", function() { return /* binding */ getDisplayName; });\n__webpack_require__.d(__webpack_exports__, \"r\", function() { return /* binding */ getUID; });\n__webpack_require__.d(__webpack_exports__, \"z\", function() { return /* binding */ utfDecodeString; });\n__webpack_require__.d(__webpack_exports__, \"A\", function() { return /* binding */ utfEncodeString; });\n__webpack_require__.d(__webpack_exports__, \"t\", function() { return /* binding */ printOperationsArray; });\n__webpack_require__.d(__webpack_exports__, \"i\", function() { return /* binding */ getDefaultComponentFilters; });\n__webpack_require__.d(__webpack_exports__, \"p\", function() { return /* binding */ getSavedComponentFilters; });\n__webpack_require__.d(__webpack_exports__, \"x\", function() { return /* binding */ setSavedComponentFilters; });\n__webpack_require__.d(__webpack_exports__, \"a\", function() { return /* binding */ castBool; });\n__webpack_require__.d(__webpack_exports__, \"b\", function() { return /* binding */ castBrowserTheme; });\n__webpack_require__.d(__webpack_exports__, \"f\", function() { return /* binding */ getAppendComponentStack; });\n__webpack_require__.d(__webpack_exports__, \"g\", function() { return /* binding */ getBreakOnConsoleErrors; });\n__webpack_require__.d(__webpack_exports__, \"m\", function() { return /* binding */ getHideConsoleLogsInStrictMode; });\n__webpack_require__.d(__webpack_exports__, \"q\", function() { return /* binding */ getShowInlineWarningsAndErrors; });\n__webpack_require__.d(__webpack_exports__, \"j\", function() { return /* binding */ getDefaultOpenInEditorURL; });\n__webpack_require__.d(__webpack_exports__, \"o\", function() { return /* binding */ getOpenInEditorURL; });\n__webpack_require__.d(__webpack_exports__, \"v\", function() { return /* binding */ separateDisplayNameAndHOCs; });\n__webpack_require__.d(__webpack_exports__, \"y\", function() { return /* binding */ shallowDiffers; });\n__webpack_require__.d(__webpack_exports__, \"n\", function() { return /* binding */ getInObject; });\n__webpack_require__.d(__webpack_exports__, \"c\", function() { return /* binding */ deletePathInObject; });\n__webpack_require__.d(__webpack_exports__, \"u\", function() { return /* binding */ renamePathInObject; });\n__webpack_require__.d(__webpack_exports__, \"w\", function() { return /* binding */ setInObject; });\n__webpack_require__.d(__webpack_exports__, \"h\", function() { return /* binding */ getDataType; });\n__webpack_require__.d(__webpack_exports__, \"l\", function() { return /* binding */ getDisplayNameForReactElement; });\n__webpack_require__.d(__webpack_exports__, \"d\", function() { return /* binding */ formatDataForPreview; });\n\n// UNUSED EXPORTS: alphaSortKeys\n\n// EXTERNAL MODULE: /Users/xch/dev/react/node_modules/lru-cache/index.js\nvar lru_cache = __webpack_require__(54);\nvar lru_cache_default = /*#__PURE__*/__webpack_require__.n(lru_cache);\n\n// EXTERNAL MODULE: external \"react-is\"\nvar external_react_is_ = __webpack_require__(16);\n\n// CONCATENATED MODULE: ../shared/ReactSymbols.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nconst REACT_ELEMENT_TYPE = Symbol.for('react.element');\nconst REACT_PORTAL_TYPE = Symbol.for('react.portal');\nconst REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nconst REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nconst REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nconst REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nconst REACT_CONTEXT_TYPE = Symbol.for('react.context');\nconst REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');\nconst REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nconst REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nconst REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nconst REACT_MEMO_TYPE = Symbol.for('react.memo');\nconst REACT_LAZY_TYPE = Symbol.for('react.lazy');\nconst REACT_SCOPE_TYPE = Symbol.for('react.scope');\nconst REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for('react.debug_trace_mode');\nconst REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nconst REACT_LEGACY_HIDDEN_TYPE = Symbol.for('react.legacy_hidden');\nconst REACT_CACHE_TYPE = Symbol.for('react.cache');\nconst REACT_TRACING_MARKER_TYPE = Symbol.for('react.tracing_marker');\nconst REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for('react.default_value');\nconst REACT_MEMO_CACHE_SENTINEL = Symbol.for('react.memo_cache_sentinel');\nconst MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nconst FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  const maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n// EXTERNAL MODULE: ../react-devtools-shared/src/constants.js\nvar constants = __webpack_require__(1);\n\n// EXTERNAL MODULE: ../react-devtools-shared/src/types.js\nvar types = __webpack_require__(2);\n\n// EXTERNAL MODULE: ../react-devtools-shared/src/storage.js\nvar storage = __webpack_require__(10);\n\n// EXTERNAL MODULE: ../react-devtools-shared/src/hydration.js\nvar hydration = __webpack_require__(11);\n\n// EXTERNAL MODULE: ../react-devtools-shared/src/isArray.js\nvar isArray = __webpack_require__(20);\n\n// CONCATENATED MODULE: ../react-devtools-shared/src/utils.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\n\n\n\n\n\n\n// $FlowFixMe[method-unbinding]\nconst utils_hasOwnProperty = Object.prototype.hasOwnProperty;\nconst cachedDisplayNames = new WeakMap(); // On large trees, encoding takes significant time.\n// Try to reuse the already encoded strings.\n\nconst encodedStringCache = new lru_cache_default.a({\n  max: 1000\n});\nfunction alphaSortKeys(a, b) {\n  if (a.toString() > b.toString()) {\n    return 1;\n  } else if (b.toString() > a.toString()) {\n    return -1;\n  } else {\n    return 0;\n  }\n}\nfunction getAllEnumerableKeys(obj) {\n  const keys = new Set();\n  let current = obj;\n\n  while (current != null) {\n    const currentKeys = [...Object.keys(current), ...Object.getOwnPropertySymbols(current)];\n    const descriptors = Object.getOwnPropertyDescriptors(current);\n    currentKeys.forEach(key => {\n      // $FlowFixMe: key can be a Symbol https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor\n      if (descriptors[key].enumerable) {\n        keys.add(key);\n      }\n    });\n    current = Object.getPrototypeOf(current);\n  }\n\n  return keys;\n} // Mirror https://github.com/facebook/react/blob/7c21bf72ace77094fd1910cc350a548287ef8350/packages/shared/getComponentName.js#L27-L37\n\nfunction getWrappedDisplayName(outerType, innerType, wrapperName, fallbackName) {\n  const displayName = outerType.displayName;\n  return displayName || `${wrapperName}(${getDisplayName(innerType, fallbackName)})`;\n}\nfunction getDisplayName(type, fallbackName = 'Anonymous') {\n  const nameFromCache = cachedDisplayNames.get(type);\n\n  if (nameFromCache != null) {\n    return nameFromCache;\n  }\n\n  let displayName = fallbackName; // The displayName property is not guaranteed to be a string.\n  // It's only safe to use for our purposes if it's a string.\n  // github.com/facebook/react-devtools/issues/803\n\n  if (typeof type.displayName === 'string') {\n    displayName = type.displayName;\n  } else if (typeof type.name === 'string' && type.name !== '') {\n    displayName = type.name;\n  }\n\n  cachedDisplayNames.set(type, displayName);\n  return displayName;\n}\nlet uidCounter = 0;\nfunction getUID() {\n  return ++uidCounter;\n}\nfunction utfDecodeString(array) {\n  // Avoid spreading the array (e.g. String.fromCodePoint(...array))\n  // Functions arguments are first placed on the stack before the function is called\n  // which throws a RangeError for large arrays.\n  // See github.com/facebook/react/issues/22293\n  let string = '';\n\n  for (let i = 0; i < array.length; i++) {\n    const char = array[i];\n    string += String.fromCodePoint(char);\n  }\n\n  return string;\n}\n\nfunction surrogatePairToCodePoint(charCode1, charCode2) {\n  return ((charCode1 & 0x3ff) << 10) + (charCode2 & 0x3ff) + 0x10000;\n} // Credit for this encoding approach goes to Tim Down:\n// https://stackoverflow.com/questions/4877326/how-can-i-tell-if-a-string-contains-multibyte-characters-in-javascript\n\n\nfunction utfEncodeString(string) {\n  const cached = encodedStringCache.get(string);\n\n  if (cached !== undefined) {\n    return cached;\n  }\n\n  const encoded = [];\n  let i = 0;\n  let charCode;\n\n  while (i < string.length) {\n    charCode = string.charCodeAt(i); // Handle multibyte unicode characters (like emoji).\n\n    if ((charCode & 0xf800) === 0xd800) {\n      encoded.push(surrogatePairToCodePoint(charCode, string.charCodeAt(++i)));\n    } else {\n      encoded.push(charCode);\n    }\n\n    ++i;\n  }\n\n  encodedStringCache.set(string, encoded);\n  return encoded;\n}\nfunction printOperationsArray(operations) {\n  // The first two values are always rendererID and rootID\n  const rendererID = operations[0];\n  const rootID = operations[1];\n  const logs = [`operations for renderer:${rendererID} and root:${rootID}`];\n  let i = 2; // Reassemble the string table.\n\n  const stringTable = [null // ID = 0 corresponds to the null string.\n  ];\n  const stringTableSize = operations[i++];\n  const stringTableEnd = i + stringTableSize;\n\n  while (i < stringTableEnd) {\n    const nextLength = operations[i++];\n    const nextString = utfDecodeString(operations.slice(i, i + nextLength));\n    stringTable.push(nextString);\n    i += nextLength;\n  }\n\n  while (i < operations.length) {\n    const operation = operations[i];\n\n    switch (operation) {\n      case constants[\"y\" /* TREE_OPERATION_ADD */]:\n        {\n          const id = operations[i + 1];\n          const type = operations[i + 2];\n          i += 3;\n\n          if (type === types[\"m\" /* ElementTypeRoot */]) {\n            logs.push(`Add new root node ${id}`);\n            i++; // isStrictModeCompliant\n\n            i++; // supportsProfiling\n\n            i++; // supportsStrictMode\n\n            i++; // hasOwnerMetadata\n          } else {\n            const parentID = operations[i];\n            i++;\n            i++; // ownerID\n\n            const displayNameStringID = operations[i];\n            const displayName = stringTable[displayNameStringID];\n            i++;\n            i++; // key\n\n            logs.push(`Add node ${id} (${displayName || 'null'}) as child of ${parentID}`);\n          }\n\n          break;\n        }\n\n      case constants[\"z\" /* TREE_OPERATION_REMOVE */]:\n        {\n          const removeLength = operations[i + 1];\n          i += 2;\n\n          for (let removeIndex = 0; removeIndex < removeLength; removeIndex++) {\n            const id = operations[i];\n            i += 1;\n            logs.push(`Remove node ${id}`);\n          }\n\n          break;\n        }\n\n      case constants[\"A\" /* TREE_OPERATION_REMOVE_ROOT */]:\n        {\n          i += 1;\n          logs.push(`Remove root ${rootID}`);\n          break;\n        }\n\n      case constants[\"C\" /* TREE_OPERATION_SET_SUBTREE_MODE */]:\n        {\n          const id = operations[i + 1];\n          const mode = operations[i + 1];\n          i += 3;\n          logs.push(`Mode ${mode} set for subtree with root ${id}`);\n          break;\n        }\n\n      case constants[\"B\" /* TREE_OPERATION_REORDER_CHILDREN */]:\n        {\n          const id = operations[i + 1];\n          const numChildren = operations[i + 2];\n          i += 3;\n          const children = operations.slice(i, i + numChildren);\n          i += numChildren;\n          logs.push(`Re-order node ${id} children ${children.join(',')}`);\n          break;\n        }\n\n      case constants[\"E\" /* TREE_OPERATION_UPDATE_TREE_BASE_DURATION */]:\n        // Base duration updates are only sent while profiling is in progress.\n        // We can ignore them at this point.\n        // The profiler UI uses them lazily in order to generate the tree.\n        i += 3;\n        break;\n\n      case constants[\"D\" /* TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS */]:\n        const id = operations[i + 1];\n        const numErrors = operations[i + 2];\n        const numWarnings = operations[i + 3];\n        i += 4;\n        logs.push(`Node ${id} has ${numErrors} errors and ${numWarnings} warnings`);\n        break;\n\n      default:\n        throw Error(`Unsupported Bridge operation \"${operation}\"`);\n    }\n  }\n\n  console.log(logs.join('\\n  '));\n}\nfunction getDefaultComponentFilters() {\n  return [{\n    type: types[\"b\" /* ComponentFilterElementType */],\n    value: types[\"i\" /* ElementTypeHostComponent */],\n    isEnabled: true\n  }];\n}\nfunction getSavedComponentFilters() {\n  try {\n    const raw = Object(storage[\"a\" /* localStorageGetItem */])(constants[\"h\" /* LOCAL_STORAGE_COMPONENT_FILTER_PREFERENCES_KEY */]);\n\n    if (raw != null) {\n      return JSON.parse(raw);\n    }\n  } catch (error) {}\n\n  return getDefaultComponentFilters();\n}\nfunction setSavedComponentFilters(componentFilters) {\n  Object(storage[\"b\" /* localStorageSetItem */])(constants[\"h\" /* LOCAL_STORAGE_COMPONENT_FILTER_PREFERENCES_KEY */], JSON.stringify(componentFilters));\n}\n\nfunction parseBool(s) {\n  if (s === 'true') {\n    return true;\n  }\n\n  if (s === 'false') {\n    return false;\n  }\n}\n\nfunction castBool(v) {\n  if (v === true || v === false) {\n    return v;\n  }\n}\nfunction castBrowserTheme(v) {\n  if (v === 'light' || v === 'dark' || v === 'auto') {\n    return v;\n  }\n}\nfunction getAppendComponentStack() {\n  var _parseBool;\n\n  const raw = Object(storage[\"a\" /* localStorageGetItem */])(constants[\"m\" /* LOCAL_STORAGE_SHOULD_APPEND_COMPONENT_STACK_KEY */]);\n  return (_parseBool = parseBool(raw)) !== null && _parseBool !== void 0 ? _parseBool : true;\n}\nfunction getBreakOnConsoleErrors() {\n  var _parseBool2;\n\n  const raw = Object(storage[\"a\" /* localStorageGetItem */])(constants[\"n\" /* LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS */]);\n  return (_parseBool2 = parseBool(raw)) !== null && _parseBool2 !== void 0 ? _parseBool2 : false;\n}\nfunction getHideConsoleLogsInStrictMode() {\n  var _parseBool3;\n\n  const raw = Object(storage[\"a\" /* localStorageGetItem */])(constants[\"j\" /* LOCAL_STORAGE_HIDE_CONSOLE_LOGS_IN_STRICT_MODE */]);\n  return (_parseBool3 = parseBool(raw)) !== null && _parseBool3 !== void 0 ? _parseBool3 : false;\n}\nfunction getShowInlineWarningsAndErrors() {\n  var _parseBool4;\n\n  const raw = Object(storage[\"a\" /* localStorageGetItem */])(constants[\"o\" /* LOCAL_STORAGE_SHOW_INLINE_WARNINGS_AND_ERRORS_KEY */]);\n  return (_parseBool4 = parseBool(raw)) !== null && _parseBool4 !== void 0 ? _parseBool4 : true;\n}\nfunction getDefaultOpenInEditorURL() {\n  return typeof null === 'string' ? null : '';\n}\nfunction getOpenInEditorURL() {\n  try {\n    const raw = Object(storage[\"a\" /* localStorageGetItem */])(constants[\"k\" /* LOCAL_STORAGE_OPEN_IN_EDITOR_URL */]);\n\n    if (raw != null) {\n      return JSON.parse(raw);\n    }\n  } catch (error) {}\n\n  return getDefaultOpenInEditorURL();\n}\nfunction separateDisplayNameAndHOCs(displayName, type) {\n  if (displayName === null) {\n    return [null, null];\n  }\n\n  let hocDisplayNames = null;\n\n  switch (type) {\n    case types[\"e\" /* ElementTypeClass */]:\n    case types[\"g\" /* ElementTypeForwardRef */]:\n    case types[\"h\" /* ElementTypeFunction */]:\n    case types[\"j\" /* ElementTypeMemo */]:\n      if (displayName.indexOf('(') >= 0) {\n        const matches = displayName.match(/[^()]+/g);\n\n        if (matches != null) {\n          displayName = matches.pop();\n          hocDisplayNames = matches;\n        }\n      }\n\n      break;\n\n    default:\n      break;\n  }\n\n  return [displayName, hocDisplayNames];\n} // Pulled from react-compat\n// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349\n\nfunction shallowDiffers(prev, next) {\n  for (const attribute in prev) {\n    if (!(attribute in next)) {\n      return true;\n    }\n  }\n\n  for (const attribute in next) {\n    if (prev[attribute] !== next[attribute]) {\n      return true;\n    }\n  }\n\n  return false;\n}\nfunction getInObject(object, path) {\n  return path.reduce((reduced, attr) => {\n    if (reduced) {\n      if (utils_hasOwnProperty.call(reduced, attr)) {\n        return reduced[attr];\n      }\n\n      if (typeof reduced[Symbol.iterator] === 'function') {\n        // Convert iterable to array and return array[index]\n        //\n        // TRICKY\n        // Don't use [...spread] syntax for this purpose.\n        // This project uses @babel/plugin-transform-spread in \"loose\" mode which only works with Array values.\n        // Other types (e.g. typed arrays, Sets) will not spread correctly.\n        return Array.from(reduced)[attr];\n      }\n    }\n\n    return null;\n  }, object);\n}\nfunction deletePathInObject(object, path) {\n  const length = path.length;\n  const last = path[length - 1];\n\n  if (object != null) {\n    const parent = getInObject(object, path.slice(0, length - 1));\n\n    if (parent) {\n      if (Object(isArray[\"a\" /* default */])(parent)) {\n        parent.splice(last, 1);\n      } else {\n        delete parent[last];\n      }\n    }\n  }\n}\nfunction renamePathInObject(object, oldPath, newPath) {\n  const length = oldPath.length;\n\n  if (object != null) {\n    const parent = getInObject(object, oldPath.slice(0, length - 1));\n\n    if (parent) {\n      const lastOld = oldPath[length - 1];\n      const lastNew = newPath[length - 1];\n      parent[lastNew] = parent[lastOld];\n\n      if (Object(isArray[\"a\" /* default */])(parent)) {\n        parent.splice(lastOld, 1);\n      } else {\n        delete parent[lastOld];\n      }\n    }\n  }\n}\nfunction setInObject(object, path, value) {\n  const length = path.length;\n  const last = path[length - 1];\n\n  if (object != null) {\n    const parent = getInObject(object, path.slice(0, length - 1));\n\n    if (parent) {\n      parent[last] = value;\n    }\n  }\n}\n\n/**\n * Get a enhanced/artificial type string based on the object instance\n */\nfunction getDataType(data) {\n  if (data === null) {\n    return 'null';\n  } else if (data === undefined) {\n    return 'undefined';\n  }\n\n  if (Object(external_react_is_[\"isElement\"])(data)) {\n    return 'react_element';\n  }\n\n  if (typeof HTMLElement !== 'undefined' && data instanceof HTMLElement) {\n    return 'html_element';\n  }\n\n  const type = typeof data;\n\n  switch (type) {\n    case 'bigint':\n      return 'bigint';\n\n    case 'boolean':\n      return 'boolean';\n\n    case 'function':\n      return 'function';\n\n    case 'number':\n      if (Number.isNaN(data)) {\n        return 'nan';\n      } else if (!Number.isFinite(data)) {\n        return 'infinity';\n      } else {\n        return 'number';\n      }\n\n    case 'object':\n      if (Object(isArray[\"a\" /* default */])(data)) {\n        return 'array';\n      } else if (ArrayBuffer.isView(data)) {\n        return utils_hasOwnProperty.call(data.constructor, 'BYTES_PER_ELEMENT') ? 'typed_array' : 'data_view';\n      } else if (data.constructor && data.constructor.name === 'ArrayBuffer') {\n        // HACK This ArrayBuffer check is gross; is there a better way?\n        // We could try to create a new DataView with the value.\n        // If it doesn't error, we know it's an ArrayBuffer,\n        // but this seems kind of awkward and expensive.\n        return 'array_buffer';\n      } else if (typeof data[Symbol.iterator] === 'function') {\n        const iterator = data[Symbol.iterator]();\n\n        if (!iterator) {// Proxies might break assumptoins about iterators.\n          // See github.com/facebook/react/issues/21654\n        } else {\n          return iterator === data ? 'opaque_iterator' : 'iterator';\n        }\n      } else if (data.constructor && data.constructor.name === 'RegExp') {\n        return 'regexp';\n      } else {\n        // $FlowFixMe[method-unbinding]\n        const toStringValue = Object.prototype.toString.call(data);\n\n        if (toStringValue === '[object Date]') {\n          return 'date';\n        } else if (toStringValue === '[object HTMLAllCollection]') {\n          return 'html_all_collection';\n        }\n      }\n\n      return 'object';\n\n    case 'string':\n      return 'string';\n\n    case 'symbol':\n      return 'symbol';\n\n    case 'undefined':\n      if ( // $FlowFixMe[method-unbinding]\n      Object.prototype.toString.call(data) === '[object HTMLAllCollection]') {\n        return 'html_all_collection';\n      }\n\n      return 'undefined';\n\n    default:\n      return 'unknown';\n  }\n}\nfunction getDisplayNameForReactElement(element) {\n  const elementType = Object(external_react_is_[\"typeOf\"])(element);\n\n  switch (elementType) {\n    case external_react_is_[\"ContextConsumer\"]:\n      return 'ContextConsumer';\n\n    case external_react_is_[\"ContextProvider\"]:\n      return 'ContextProvider';\n\n    case external_react_is_[\"ForwardRef\"]:\n      return 'ForwardRef';\n\n    case external_react_is_[\"Fragment\"]:\n      return 'Fragment';\n\n    case external_react_is_[\"Lazy\"]:\n      return 'Lazy';\n\n    case external_react_is_[\"Memo\"]:\n      return 'Memo';\n\n    case external_react_is_[\"Portal\"]:\n      return 'Portal';\n\n    case external_react_is_[\"Profiler\"]:\n      return 'Profiler';\n\n    case external_react_is_[\"StrictMode\"]:\n      return 'StrictMode';\n\n    case external_react_is_[\"Suspense\"]:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_TRACING_MARKER_TYPE:\n      return 'TracingMarker';\n\n    default:\n      const {\n        type\n      } = element;\n\n      if (typeof type === 'string') {\n        return type;\n      } else if (typeof type === 'function') {\n        return getDisplayName(type, 'Anonymous');\n      } else if (type != null) {\n        return 'NotImplementedInDevtools';\n      } else {\n        return 'Element';\n      }\n\n  }\n}\nconst MAX_PREVIEW_STRING_LENGTH = 50;\n\nfunction truncateForDisplay(string, length = MAX_PREVIEW_STRING_LENGTH) {\n  if (string.length > length) {\n    return string.substr(0, length) + '';\n  } else {\n    return string;\n  }\n} // Attempts to mimic Chrome's inline preview for values.\n// For example, the following value...\n//   {\n//      foo: 123,\n//      bar: \"abc\",\n//      baz: [true, false],\n//      qux: { ab: 1, cd: 2 }\n//   };\n//\n// Would show a preview of...\n//   {foo: 123, bar: \"abc\", baz: Array(2), qux: {}}\n//\n// And the following value...\n//   [\n//     123,\n//     \"abc\",\n//     [true, false],\n//     { foo: 123, bar: \"abc\" }\n//   ];\n//\n// Would show a preview of...\n//   [123, \"abc\", Array(2), {}]\n\n\nfunction formatDataForPreview(data, showFormattedValue) {\n  if (data != null && utils_hasOwnProperty.call(data, hydration[\"d\" /* meta */].type)) {\n    return showFormattedValue ? data[hydration[\"d\" /* meta */].preview_long] : data[hydration[\"d\" /* meta */].preview_short];\n  }\n\n  const type = getDataType(data);\n\n  switch (type) {\n    case 'html_element':\n      return `<${truncateForDisplay(data.tagName.toLowerCase())} />`;\n\n    case 'function':\n      return truncateForDisplay(` ${typeof data.name === 'function' ? '' : data.name}() {}`);\n\n    case 'string':\n      return `\"${data}\"`;\n\n    case 'bigint':\n      return truncateForDisplay(data.toString() + 'n');\n\n    case 'regexp':\n      return truncateForDisplay(data.toString());\n\n    case 'symbol':\n      return truncateForDisplay(data.toString());\n\n    case 'react_element':\n      return `<${truncateForDisplay(getDisplayNameForReactElement(data) || 'Unknown')} />`;\n\n    case 'array_buffer':\n      return `ArrayBuffer(${data.byteLength})`;\n\n    case 'data_view':\n      return `DataView(${data.buffer.byteLength})`;\n\n    case 'array':\n      if (showFormattedValue) {\n        let formatted = '';\n\n        for (let i = 0; i < data.length; i++) {\n          if (i > 0) {\n            formatted += ', ';\n          }\n\n          formatted += formatDataForPreview(data[i], false);\n\n          if (formatted.length > MAX_PREVIEW_STRING_LENGTH) {\n            // Prevent doing a lot of unnecessary iteration...\n            break;\n          }\n        }\n\n        return `[${truncateForDisplay(formatted)}]`;\n      } else {\n        const length = utils_hasOwnProperty.call(data, hydration[\"d\" /* meta */].size) ? data[hydration[\"d\" /* meta */].size] : data.length;\n        return `Array(${length})`;\n      }\n\n    case 'typed_array':\n      const shortName = `${data.constructor.name}(${data.length})`;\n\n      if (showFormattedValue) {\n        let formatted = '';\n\n        for (let i = 0; i < data.length; i++) {\n          if (i > 0) {\n            formatted += ', ';\n          }\n\n          formatted += data[i];\n\n          if (formatted.length > MAX_PREVIEW_STRING_LENGTH) {\n            // Prevent doing a lot of unnecessary iteration...\n            break;\n          }\n        }\n\n        return `${shortName} [${truncateForDisplay(formatted)}]`;\n      } else {\n        return shortName;\n      }\n\n    case 'iterator':\n      const name = data.constructor.name;\n\n      if (showFormattedValue) {\n        // TRICKY\n        // Don't use [...spread] syntax for this purpose.\n        // This project uses @babel/plugin-transform-spread in \"loose\" mode which only works with Array values.\n        // Other types (e.g. typed arrays, Sets) will not spread correctly.\n        const array = Array.from(data);\n        let formatted = '';\n\n        for (let i = 0; i < array.length; i++) {\n          const entryOrEntries = array[i];\n\n          if (i > 0) {\n            formatted += ', ';\n          } // TRICKY\n          // Browsers display Maps and Sets differently.\n          // To mimic their behavior, detect if we've been given an entries tuple.\n          //   Map(2) {\"abc\" => 123, \"def\" => 123}\n          //   Set(2) {\"abc\", 123}\n\n\n          if (Object(isArray[\"a\" /* default */])(entryOrEntries)) {\n            const key = formatDataForPreview(entryOrEntries[0], true);\n            const value = formatDataForPreview(entryOrEntries[1], false);\n            formatted += `${key} => ${value}`;\n          } else {\n            formatted += formatDataForPreview(entryOrEntries, false);\n          }\n\n          if (formatted.length > MAX_PREVIEW_STRING_LENGTH) {\n            // Prevent doing a lot of unnecessary iteration...\n            break;\n          }\n        }\n\n        return `${name}(${data.size}) {${truncateForDisplay(formatted)}}`;\n      } else {\n        return `${name}(${data.size})`;\n      }\n\n    case 'opaque_iterator':\n      {\n        return data[Symbol.toStringTag];\n      }\n\n    case 'date':\n      return data.toString();\n\n    case 'object':\n      if (showFormattedValue) {\n        const keys = Array.from(getAllEnumerableKeys(data)).sort(alphaSortKeys);\n        let formatted = '';\n\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i];\n\n          if (i > 0) {\n            formatted += ', ';\n          }\n\n          formatted += `${key.toString()}: ${formatDataForPreview(data[key], false)}`;\n\n          if (formatted.length > MAX_PREVIEW_STRING_LENGTH) {\n            // Prevent doing a lot of unnecessary iteration...\n            break;\n          }\n        }\n\n        return `{${truncateForDisplay(formatted)}}`;\n      } else {\n        return '{}';\n      }\n\n    case 'boolean':\n    case 'number':\n    case 'infinity':\n    case 'nan':\n    case 'null':\n    case 'undefined':\n      return data;\n\n    default:\n      try {\n        return truncateForDisplay(String(data));\n      } catch (error) {\n        return 'unserializable';\n      }\n\n  }\n}\n\n/***/ }),\n\n/***/ 34:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return BRIDGE_PROTOCOL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return currentBridgeProtocol; });\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(41);\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nconst BATCH_DURATION = 100; // This message specifies the version of the DevTools protocol currently supported by the backend,\n// as well as the earliest NPM version (e.g. \"4.13.0\") that protocol is supported by on the frontend.\n// This enables an older frontend to display an upgrade message to users for a newer, unsupported backend.\n\n// Bump protocol version whenever a backwards breaking change is made\n// in the messages sent between BackendBridge and FrontendBridge.\n// This mapping is embedded in both frontend and backend builds.\n//\n// The backend protocol will always be the latest entry in the BRIDGE_PROTOCOL array.\n//\n// When an older frontend connects to a newer backend,\n// the backend can send the minNpmVersion and the frontend can display an NPM upgrade prompt.\n//\n// When a newer frontend connects with an older protocol version,\n// the frontend can use the embedded minNpmVersion/maxNpmVersion values to display a downgrade prompt.\nconst BRIDGE_PROTOCOL = [// This version technically never existed,\n// but a backwards breaking change was added in 4.11,\n// so the safest guess to downgrade the frontend would be to version 4.10.\n{\n  version: 0,\n  minNpmVersion: '\"<4.11.0\"',\n  maxNpmVersion: '\"<4.11.0\"'\n}, // Versions 4.11.x  4.12.x contained the backwards breaking change,\n// but we didn't add the \"fix\" of checking the protocol version until 4.13,\n// so we don't recommend downgrading to 4.11 or 4.12.\n{\n  version: 1,\n  minNpmVersion: '4.13.0',\n  maxNpmVersion: '4.21.0'\n}, // Version 2 adds a StrictMode-enabled and supports-StrictMode bits to add-root operation.\n{\n  version: 2,\n  minNpmVersion: '4.22.0',\n  maxNpmVersion: null\n}];\nconst currentBridgeProtocol = BRIDGE_PROTOCOL[BRIDGE_PROTOCOL.length - 1];\n\nclass Bridge extends _events__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"] {\n  constructor(wall) {\n    super();\n\n    _defineProperty(this, \"_isShutdown\", false);\n\n    _defineProperty(this, \"_messageQueue\", []);\n\n    _defineProperty(this, \"_timeoutID\", null);\n\n    _defineProperty(this, \"_wallUnlisten\", null);\n\n    _defineProperty(this, \"_flush\", () => {\n      // This method is used after the bridge is marked as destroyed in shutdown sequence,\n      // so we do not bail out if the bridge marked as destroyed.\n      // It is a private method that the bridge ensures is only called at the right times.\n      if (this._timeoutID !== null) {\n        clearTimeout(this._timeoutID);\n        this._timeoutID = null;\n      }\n\n      if (this._messageQueue.length) {\n        for (let i = 0; i < this._messageQueue.length; i += 2) {\n          this._wall.send(this._messageQueue[i], ...this._messageQueue[i + 1]);\n        }\n\n        this._messageQueue.length = 0; // Check again for queued messages in BATCH_DURATION ms. This will keep\n        // flushing in a loop as long as messages continue to be added. Once no\n        // more are, the timer expires.\n\n        this._timeoutID = setTimeout(this._flush, BATCH_DURATION);\n      }\n    });\n\n    _defineProperty(this, \"overrideValueAtPath\", ({\n      id,\n      path,\n      rendererID,\n      type,\n      value\n    }) => {\n      switch (type) {\n        case 'context':\n          this.send('overrideContext', {\n            id,\n            path,\n            rendererID,\n            wasForwarded: true,\n            value\n          });\n          break;\n\n        case 'hooks':\n          this.send('overrideHookState', {\n            id,\n            path,\n            rendererID,\n            wasForwarded: true,\n            value\n          });\n          break;\n\n        case 'props':\n          this.send('overrideProps', {\n            id,\n            path,\n            rendererID,\n            wasForwarded: true,\n            value\n          });\n          break;\n\n        case 'state':\n          this.send('overrideState', {\n            id,\n            path,\n            rendererID,\n            wasForwarded: true,\n            value\n          });\n          break;\n      }\n    });\n\n    this._wall = wall;\n    this._wallUnlisten = wall.listen(message => {\n      if (message && message.event) {\n        this.emit(message.event, message.payload);\n      }\n    }) || null; // Temporarily support older standalone front-ends sending commands to newer embedded backends.\n    // We do this because React Native embeds the React DevTools backend,\n    // but cannot control which version of the frontend users use.\n\n    this.addListener('overrideValueAtPath', this.overrideValueAtPath);\n  } // Listening directly to the wall isn't advised.\n  // It can be used to listen for legacy (v3) messages (since they use a different format).\n\n\n  get wall() {\n    return this._wall;\n  }\n\n  send(event, ...payload) {\n    if (this._isShutdown) {\n      console.warn(`Cannot send message \"${event}\" through a Bridge that has been shutdown.`);\n      return;\n    } // When we receive a message:\n    // - we add it to our queue of messages to be sent\n    // - if there hasn't been a message recently, we set a timer for 0 ms in\n    //   the future, allowing all messages created in the same tick to be sent\n    //   together\n    // - if there *has* been a message flushed in the last BATCH_DURATION ms\n    //   (or we're waiting for our setTimeout-0 to fire), then _timeoutID will\n    //   be set, and we'll simply add to the queue and wait for that\n\n\n    this._messageQueue.push(event, payload);\n\n    if (!this._timeoutID) {\n      this._timeoutID = setTimeout(this._flush, 0);\n    }\n  }\n\n  shutdown() {\n    if (this._isShutdown) {\n      console.warn('Bridge was already shutdown.');\n      return;\n    } // Queue the shutdown outgoing message for subscribers.\n\n\n    this.send('shutdown'); // Mark this bridge as destroyed, i.e. disable its public API.\n\n    this._isShutdown = true; // Disable the API inherited from EventEmitter that can add more listeners and send more messages.\n    // $FlowFixMe This property is not writable.\n\n    this.addListener = function () {}; // $FlowFixMe This property is not writable.\n\n\n    this.emit = function () {}; // NOTE: There's also EventEmitter API like `on` and `prependListener` that we didn't add to our Flow type of EventEmitter.\n    // Unsubscribe this bridge incoming message listeners to be sure, and so they don't have to do that.\n\n\n    this.removeAllListeners(); // Stop accepting and emitting incoming messages from the wall.\n\n    const wallUnlisten = this._wallUnlisten;\n\n    if (wallUnlisten) {\n      wallUnlisten();\n    } // Synchronously flush all queued outgoing messages.\n    // At this step the subscribers' code may run in this call stack.\n\n\n    do {\n      this._flush();\n    } while (this._messageQueue.length); // Make sure once again that there is no dangling timer.\n\n\n    if (this._timeoutID !== null) {\n      clearTimeout(this._timeoutID);\n      this._timeoutID = null;\n    }\n  }\n\n}\n\n/* harmony default export */ __webpack_exports__[\"c\"] = (Bridge);\n\n/***/ }),\n\n/***/ 35:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (isArray);\n\n/***/ }),\n\n/***/ 40:\n/***/ (function(module, exports) {\n\nvar g; // This works in non-strict mode\n\ng = function () {\n  return this;\n}();\n\ntry {\n  // This works if eval is allowed (see CSP)\n  g = g || new Function(\"return this\")();\n} catch (e) {\n  // This works if the window reference is available\n  if (typeof window === \"object\") g = window;\n} // g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\n\nmodule.exports = g;\n\n/***/ }),\n\n/***/ 41:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return EventEmitter; });\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nclass EventEmitter {\n  constructor() {\n    _defineProperty(this, \"listenersMap\", new Map());\n  }\n\n  addListener(event, listener) {\n    const listeners = this.listenersMap.get(event);\n\n    if (listeners === undefined) {\n      this.listenersMap.set(event, [listener]);\n    } else {\n      const index = listeners.indexOf(listener);\n\n      if (index < 0) {\n        listeners.push(listener);\n      }\n    }\n  }\n\n  emit(event, ...args) {\n    const listeners = this.listenersMap.get(event);\n\n    if (listeners !== undefined) {\n      if (listeners.length === 1) {\n        // No need to clone or try/catch\n        const listener = listeners[0];\n        listener.apply(null, args);\n      } else {\n        let didThrow = false;\n        let caughtError = null;\n        const clonedListeners = Array.from(listeners);\n\n        for (let i = 0; i < clonedListeners.length; i++) {\n          const listener = clonedListeners[i];\n\n          try {\n            listener.apply(null, args);\n          } catch (error) {\n            if (caughtError === null) {\n              didThrow = true;\n              caughtError = error;\n            }\n          }\n        }\n\n        if (didThrow) {\n          throw caughtError;\n        }\n      }\n    }\n  }\n\n  removeAllListeners() {\n    this.listenersMap.clear();\n  }\n\n  removeListener(event, listener) {\n    const listeners = this.listenersMap.get(event);\n\n    if (listeners !== undefined) {\n      const index = listeners.indexOf(listener);\n\n      if (index >= 0) {\n        listeners.splice(index, 1);\n      }\n    }\n  }\n\n}\n\n/***/ }),\n\n/***/ 43:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar simpleIsEqual = function simpleIsEqual(a, b) {\n  return a === b;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (resultFn) {\n  var isEqual = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : simpleIsEqual;\n  var lastThis = void 0;\n  var lastArgs = [];\n  var lastResult = void 0;\n  var calledOnce = false;\n\n  var isNewArgEqualToLast = function isNewArgEqualToLast(newArg, index) {\n    return isEqual(newArg, lastArgs[index]);\n  };\n\n  var result = function result() {\n    for (var _len = arguments.length, newArgs = Array(_len), _key = 0; _key < _len; _key++) {\n      newArgs[_key] = arguments[_key];\n    }\n\n    if (calledOnce && lastThis === this && newArgs.length === lastArgs.length && newArgs.every(isNewArgEqualToLast)) {\n      return lastResult;\n    }\n\n    calledOnce = true;\n    lastThis = this;\n    lastArgs = newArgs;\n    lastResult = resultFn.apply(this, newArgs);\n    return lastResult;\n  };\n\n  return result;\n});\n\n/***/ }),\n\n/***/ 44:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {/* unused harmony export isStringComponentStack */\n/* unused harmony export dangerous_setTargetConsoleForTesting */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return registerRenderer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return patch; });\n/* unused harmony export unpatch */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return patchForStrictMode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return unpatchForStrictMode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return patchConsoleUsingWindowValues; });\n/* unused harmony export writeConsolePatchSettingsToWindow */\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);\n/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(70);\n/* harmony import */ var _DevToolsFiberComponentStack__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(71);\n/* harmony import */ var react_devtools_feature_flags__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(13);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(3);\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\n\n\nconst OVERRIDE_CONSOLE_METHODS = ['error', 'trace', 'warn'];\nconst DIMMED_NODE_CONSOLE_COLOR = '\\x1b[2m%s\\x1b[0m'; // React's custom built component stack strings match \"\\s{4}in\"\n// Chrome's prefix matches \"\\s{4}at\"\n\nconst PREFIX_REGEX = /\\s{4}(in|at)\\s{1}/; // Firefox and Safari have no prefix (\"\")\n// but we can fallback to looking for location info (e.g. \"foo.js:12:345\")\n\nconst ROW_COLUMN_NUMBER_REGEX = /:\\d+:\\d+(\\n|$)/;\nfunction isStringComponentStack(text) {\n  return PREFIX_REGEX.test(text) || ROW_COLUMN_NUMBER_REGEX.test(text);\n}\nconst STYLE_DIRECTIVE_REGEX = /^%c/; // This function tells whether or not the arguments for a console\n// method has been overridden by the patchForStrictMode function.\n// If it has we'll need to do some special formatting of the arguments\n// so the console color stays consistent\n\nfunction isStrictModeOverride(args, method) {\n  return args.length >= 2 && STYLE_DIRECTIVE_REGEX.test(args[0]) && args[1] === `color: ${getConsoleColor(method) || ''}`;\n}\n\nfunction getConsoleColor(method) {\n  switch (method) {\n    case 'warn':\n      return consoleSettingsRef.browserTheme === 'light' ? \"rgba(250, 180, 50, 0.75)\" : \"rgba(250, 180, 50, 0.5)\";\n\n    case 'error':\n      return consoleSettingsRef.browserTheme === 'light' ? \"rgba(250, 123, 130, 0.75)\" : \"rgba(250, 123, 130, 0.5)\";\n\n    case 'log':\n    default:\n      return consoleSettingsRef.browserTheme === 'light' ? \"rgba(125, 125, 125, 0.75)\" : \"rgba(125, 125, 125, 0.5)\";\n  }\n}\n\nconst injectedRenderers = new Map();\nlet targetConsole = console;\nlet targetConsoleMethods = {};\n\nfor (const method in console) {\n  targetConsoleMethods[method] = console[method];\n}\n\nlet unpatchFn = null;\nlet isNode = false;\n\ntry {\n  isNode = undefined === global;\n} catch (error) {} // Enables e.g. Jest tests to inject a mock console object.\n\n\nfunction dangerous_setTargetConsoleForTesting(targetConsoleForTesting) {\n  targetConsole = targetConsoleForTesting;\n  targetConsoleMethods = {};\n\n  for (const method in targetConsole) {\n    targetConsoleMethods[method] = console[method];\n  }\n} // v16 renderers should use this method to inject internals necessary to generate a component stack.\n// These internals will be used if the console is patched.\n// Injecting them separately allows the console to easily be patched or un-patched later (at runtime).\n\nfunction registerRenderer(renderer, onErrorOrWarning) {\n  const {\n    currentDispatcherRef,\n    getCurrentFiber,\n    findFiberByHostInstance,\n    version\n  } = renderer; // Ignore React v15 and older because they don't expose a component stack anyway.\n\n  if (typeof findFiberByHostInstance !== 'function') {\n    return;\n  } // currentDispatcherRef gets injected for v16.8+ to support hooks inspection.\n  // getCurrentFiber gets injected for v16.9+.\n\n\n  if (currentDispatcherRef != null && typeof getCurrentFiber === 'function') {\n    const {\n      ReactTypeOfWork\n    } = Object(_renderer__WEBPACK_IMPORTED_MODULE_1__[/* getInternalReactConstants */ \"b\"])(version);\n    injectedRenderers.set(renderer, {\n      currentDispatcherRef,\n      getCurrentFiber,\n      workTagMap: ReactTypeOfWork,\n      onErrorOrWarning\n    });\n  }\n}\nconst consoleSettingsRef = {\n  appendComponentStack: false,\n  breakOnConsoleErrors: false,\n  showInlineWarningsAndErrors: false,\n  hideConsoleLogsInStrictMode: false,\n  browserTheme: 'dark'\n};\n// Patches console methods to append component stack for the current fiber.\n// Call unpatch() to remove the injected behavior.\nfunction patch({\n  appendComponentStack,\n  breakOnConsoleErrors,\n  showInlineWarningsAndErrors,\n  hideConsoleLogsInStrictMode,\n  browserTheme\n}) {\n  // Settings may change after we've patched the console.\n  // Using a shared ref allows the patch function to read the latest values.\n  consoleSettingsRef.appendComponentStack = appendComponentStack;\n  consoleSettingsRef.breakOnConsoleErrors = breakOnConsoleErrors;\n  consoleSettingsRef.showInlineWarningsAndErrors = showInlineWarningsAndErrors;\n  consoleSettingsRef.hideConsoleLogsInStrictMode = hideConsoleLogsInStrictMode;\n  consoleSettingsRef.browserTheme = browserTheme;\n\n  if (appendComponentStack || breakOnConsoleErrors || showInlineWarningsAndErrors) {\n    if (unpatchFn !== null) {\n      // Don't patch twice.\n      return;\n    }\n\n    const originalConsoleMethods = {};\n\n    unpatchFn = () => {\n      for (const method in originalConsoleMethods) {\n        try {\n          targetConsole[method] = originalConsoleMethods[method];\n        } catch (error) {}\n      }\n    };\n\n    OVERRIDE_CONSOLE_METHODS.forEach(method => {\n      try {\n        const originalMethod = originalConsoleMethods[method] = targetConsole[method].__REACT_DEVTOOLS_ORIGINAL_METHOD__ ? targetConsole[method].__REACT_DEVTOOLS_ORIGINAL_METHOD__ : targetConsole[method]; // $FlowFixMe[missing-local-annot]\n\n        const overrideMethod = (...args) => {\n          let shouldAppendWarningStack = false;\n\n          if (method !== 'log') {\n            if (consoleSettingsRef.appendComponentStack) {\n              const lastArg = args.length > 0 ? args[args.length - 1] : null;\n              const alreadyHasComponentStack = typeof lastArg === 'string' && isStringComponentStack(lastArg); // If we are ever called with a string that already has a component stack,\n              // e.g. a React error/warning, don't append a second stack.\n\n              shouldAppendWarningStack = !alreadyHasComponentStack;\n            }\n          }\n\n          const shouldShowInlineWarningsAndErrors = consoleSettingsRef.showInlineWarningsAndErrors && (method === 'error' || method === 'warn'); // Search for the first renderer that has a current Fiber.\n          // We don't handle the edge case of stacks for more than one (e.g. interleaved renderers?)\n          // eslint-disable-next-line no-for-of-loops/no-for-of-loops\n\n          for (const {\n            currentDispatcherRef,\n            getCurrentFiber,\n            onErrorOrWarning,\n            workTagMap\n          } of injectedRenderers.values()) {\n            const current = getCurrentFiber();\n\n            if (current != null) {\n              try {\n                if (shouldShowInlineWarningsAndErrors) {\n                  // patch() is called by two places: (1) the hook and (2) the renderer backend.\n                  // The backend is what implements a message queue, so it's the only one that injects onErrorOrWarning.\n                  if (typeof onErrorOrWarning === 'function') {\n                    onErrorOrWarning(current, method, // Copy args before we mutate them (e.g. adding the component stack)\n                    args.slice());\n                  }\n                }\n\n                if (shouldAppendWarningStack) {\n                  const componentStack = Object(_DevToolsFiberComponentStack__WEBPACK_IMPORTED_MODULE_2__[/* getStackByFiberInDevAndProd */ \"b\"])(workTagMap, current, currentDispatcherRef);\n\n                  if (componentStack !== '') {\n                    if (isStrictModeOverride(args, method)) {\n                      args[0] = `${args[0]} %s`;\n                      args.push(componentStack);\n                    } else {\n                      args.push(componentStack);\n                    }\n                  }\n                }\n              } catch (error) {\n                // Don't let a DevTools or React internal error interfere with logging.\n                setTimeout(() => {\n                  throw error;\n                }, 0);\n              } finally {\n                break;\n              }\n            }\n          }\n\n          if (consoleSettingsRef.breakOnConsoleErrors) {\n            // --- Welcome to debugging with React DevTools ---\n            // This debugger statement means that you've enabled the \"break on warnings\" feature.\n            // Use the browser's Call Stack panel to step out of this override function-\n            // to where the original warning or error was logged.\n            // eslint-disable-next-line no-debugger\n            debugger;\n          }\n\n          originalMethod(...args);\n        };\n\n        overrideMethod.__REACT_DEVTOOLS_ORIGINAL_METHOD__ = originalMethod;\n        originalMethod.__REACT_DEVTOOLS_OVERRIDE_METHOD__ = overrideMethod;\n        targetConsole[method] = overrideMethod;\n      } catch (error) {}\n    });\n  } else {\n    unpatch();\n  }\n} // Removed component stack patch from console methods.\n\nfunction unpatch() {\n  if (unpatchFn !== null) {\n    unpatchFn();\n    unpatchFn = null;\n  }\n}\nlet unpatchForStrictModeFn = null; // NOTE: KEEP IN SYNC with src/hook.js:patchConsoleForInitialRenderInStrictMode\n\nfunction patchForStrictMode() {\n  if (react_devtools_feature_flags__WEBPACK_IMPORTED_MODULE_3__[/* consoleManagedByDevToolsDuringStrictMode */ \"a\"]) {\n    const overrideConsoleMethods = ['error', 'group', 'groupCollapsed', 'info', 'log', 'trace', 'warn'];\n\n    if (unpatchForStrictModeFn !== null) {\n      // Don't patch twice.\n      return;\n    }\n\n    const originalConsoleMethods = {};\n\n    unpatchForStrictModeFn = () => {\n      for (const method in originalConsoleMethods) {\n        try {\n          targetConsole[method] = originalConsoleMethods[method];\n        } catch (error) {}\n      }\n    };\n\n    overrideConsoleMethods.forEach(method => {\n      try {\n        const originalMethod = originalConsoleMethods[method] = targetConsole[method].__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ ? targetConsole[method].__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ : targetConsole[method]; // $FlowFixMe[missing-local-annot]\n\n        const overrideMethod = (...args) => {\n          if (!consoleSettingsRef.hideConsoleLogsInStrictMode) {\n            // Dim the text color of the double logs if we're not\n            // hiding them.\n            if (isNode) {\n              originalMethod(DIMMED_NODE_CONSOLE_COLOR, Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* format */ \"f\"])(...args));\n            } else {\n              const color = getConsoleColor(method);\n\n              if (color) {\n                originalMethod(...Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatWithStyles */ \"g\"])(args, `color: ${color}`));\n              } else {\n                throw Error('Console color is not defined');\n              }\n            }\n          }\n        };\n\n        overrideMethod.__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ = originalMethod;\n        originalMethod.__REACT_DEVTOOLS_STRICT_MODE_OVERRIDE_METHOD__ = overrideMethod;\n        targetConsole[method] = overrideMethod;\n      } catch (error) {}\n    });\n  }\n} // NOTE: KEEP IN SYNC with src/hook.js:unpatchConsoleForInitialRenderInStrictMode\n\nfunction unpatchForStrictMode() {\n  if (react_devtools_feature_flags__WEBPACK_IMPORTED_MODULE_3__[/* consoleManagedByDevToolsDuringStrictMode */ \"a\"]) {\n    if (unpatchForStrictModeFn !== null) {\n      unpatchForStrictModeFn();\n      unpatchForStrictModeFn = null;\n    }\n  }\n}\nfunction patchConsoleUsingWindowValues() {\n  var _castBool, _castBool2, _castBool3, _castBool4, _castBrowserTheme;\n\n  const appendComponentStack = (_castBool = Object(_utils__WEBPACK_IMPORTED_MODULE_4__[/* castBool */ \"a\"])(window.__REACT_DEVTOOLS_APPEND_COMPONENT_STACK__)) !== null && _castBool !== void 0 ? _castBool : true;\n  const breakOnConsoleErrors = (_castBool2 = Object(_utils__WEBPACK_IMPORTED_MODULE_4__[/* castBool */ \"a\"])(window.__REACT_DEVTOOLS_BREAK_ON_CONSOLE_ERRORS__)) !== null && _castBool2 !== void 0 ? _castBool2 : false;\n  const showInlineWarningsAndErrors = (_castBool3 = Object(_utils__WEBPACK_IMPORTED_MODULE_4__[/* castBool */ \"a\"])(window.__REACT_DEVTOOLS_SHOW_INLINE_WARNINGS_AND_ERRORS__)) !== null && _castBool3 !== void 0 ? _castBool3 : true;\n  const hideConsoleLogsInStrictMode = (_castBool4 = Object(_utils__WEBPACK_IMPORTED_MODULE_4__[/* castBool */ \"a\"])(window.__REACT_DEVTOOLS_HIDE_CONSOLE_LOGS_IN_STRICT_MODE__)) !== null && _castBool4 !== void 0 ? _castBool4 : false;\n  const browserTheme = (_castBrowserTheme = Object(_utils__WEBPACK_IMPORTED_MODULE_4__[/* castBrowserTheme */ \"b\"])(window.__REACT_DEVTOOLS_BROWSER_THEME__)) !== null && _castBrowserTheme !== void 0 ? _castBrowserTheme : 'dark';\n  patch({\n    appendComponentStack,\n    breakOnConsoleErrors,\n    showInlineWarningsAndErrors,\n    hideConsoleLogsInStrictMode,\n    browserTheme\n  });\n} // After receiving cached console patch settings from React Native, we set them on window.\n// When the console is initially patched (in renderer.js and hook.js), these values are read.\n// The browser extension (etc.) sets these values on window, but through another method.\n\nfunction writeConsolePatchSettingsToWindow(settings) {\n  window.__REACT_DEVTOOLS_APPEND_COMPONENT_STACK__ = settings.appendComponentStack;\n  window.__REACT_DEVTOOLS_BREAK_ON_CONSOLE_ERRORS__ = settings.breakOnConsoleErrors;\n  window.__REACT_DEVTOOLS_SHOW_INLINE_WARNINGS_AND_ERRORS__ = settings.showInlineWarningsAndErrors;\n  window.__REACT_DEVTOOLS_HIDE_CONSOLE_LOGS_IN_STRICT_MODE__ = settings.hideConsoleLogsInStrictMode;\n  window.__REACT_DEVTOOLS_BROWSER_THEME__ = settings.browserTheme;\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(40)))\n\n/***/ }),\n\n/***/ 45:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return REACT_TOTAL_NUM_LANES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return SCHEDULING_PROFILER_VERSION; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return SNAPSHOT_MAX_HEIGHT; });\n/* harmony import */ var react_devtools_shared_src_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nconst REACT_TOTAL_NUM_LANES = 31; // Increment this number any time a backwards breaking change is made to the profiler metadata.\n\nconst SCHEDULING_PROFILER_VERSION = 1;\nconst SNAPSHOT_MAX_HEIGHT = 60;\n\n/***/ }),\n\n/***/ 51:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {\n  'use strict'; // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n  /* istanbul ignore next */\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(84)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(this, function ErrorStackParser(StackFrame) {\n  'use strict';\n\n  var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\\S+:\\d+/;\n  var CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+:\\d+|\\(native\\))/m;\n  var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\\[native code])?$/;\n  return {\n    /**\n     * Given an Error object, extract the most information from it.\n     *\n     * @param {Error} error object\n     * @return {Array} of StackFrames\n     */\n    parse: function ErrorStackParser$$parse(error) {\n      if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {\n        return this.parseOpera(error);\n      } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {\n        return this.parseV8OrIE(error);\n      } else if (error.stack) {\n        return this.parseFFOrSafari(error);\n      } else {\n        throw new Error('Cannot parse given Error object');\n      }\n    },\n    // Separate line and column numbers from a string of the form: (URI:Line:Column)\n    extractLocation: function ErrorStackParser$$extractLocation(urlLike) {\n      // Fail-fast but return locations like \"(native)\"\n      if (urlLike.indexOf(':') === -1) {\n        return [urlLike];\n      }\n\n      var regExp = /(.+?)(?::(\\d+))?(?::(\\d+))?$/;\n      var parts = regExp.exec(urlLike.replace(/[()]/g, ''));\n      return [parts[1], parts[2] || undefined, parts[3] || undefined];\n    },\n    parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {\n      var filtered = error.stack.split('\\n').filter(function (line) {\n        return !!line.match(CHROME_IE_STACK_REGEXP);\n      }, this);\n      return filtered.map(function (line) {\n        if (line.indexOf('(eval ') > -1) {\n          // Throw away eval information until we implement stacktrace.js/stackframe#8\n          line = line.replace(/eval code/g, 'eval').replace(/(\\(eval at [^()]*)|(\\),.*$)/g, '');\n        }\n\n        var sanitizedLine = line.replace(/^\\s+/, '').replace(/\\(eval code/g, '('); // capture and preseve the parenthesized location \"(/foo/my bar.js:12:87)\" in\n        // case it has spaces in it, as the string is split on \\s+ later on\n\n        var location = sanitizedLine.match(/ (\\((.+):(\\d+):(\\d+)\\)$)/); // remove the parenthesized location from the line, if it was matched\n\n        sanitizedLine = location ? sanitizedLine.replace(location[0], '') : sanitizedLine;\n        var tokens = sanitizedLine.split(/\\s+/).slice(1); // if a location was matched, pass it to extractLocation() otherwise pop the last token\n\n        var locationParts = this.extractLocation(location ? location[1] : tokens.pop());\n        var functionName = tokens.join(' ') || undefined;\n        var fileName = ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1 ? undefined : locationParts[0];\n        return new StackFrame({\n          functionName: functionName,\n          fileName: fileName,\n          lineNumber: locationParts[1],\n          columnNumber: locationParts[2],\n          source: line\n        });\n      }, this);\n    },\n    parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {\n      var filtered = error.stack.split('\\n').filter(function (line) {\n        return !line.match(SAFARI_NATIVE_CODE_REGEXP);\n      }, this);\n      return filtered.map(function (line) {\n        // Throw away eval information until we implement stacktrace.js/stackframe#8\n        if (line.indexOf(' > eval') > -1) {\n          line = line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval:\\d+:\\d+/g, ':$1');\n        }\n\n        if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {\n          // Safari eval frames only have function names and nothing else\n          return new StackFrame({\n            functionName: line\n          });\n        } else {\n          var functionNameRegex = /((.*\".+\"[^@]*)?[^@]*)(?:@)/;\n          var matches = line.match(functionNameRegex);\n          var functionName = matches && matches[1] ? matches[1] : undefined;\n          var locationParts = this.extractLocation(line.replace(functionNameRegex, ''));\n          return new StackFrame({\n            functionName: functionName,\n            fileName: locationParts[0],\n            lineNumber: locationParts[1],\n            columnNumber: locationParts[2],\n            source: line\n          });\n        }\n      }, this);\n    },\n    parseOpera: function ErrorStackParser$$parseOpera(e) {\n      if (!e.stacktrace || e.message.indexOf('\\n') > -1 && e.message.split('\\n').length > e.stacktrace.split('\\n').length) {\n        return this.parseOpera9(e);\n      } else if (!e.stack) {\n        return this.parseOpera10(e);\n      } else {\n        return this.parseOpera11(e);\n      }\n    },\n    parseOpera9: function ErrorStackParser$$parseOpera9(e) {\n      var lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n      var lines = e.message.split('\\n');\n      var result = [];\n\n      for (var i = 2, len = lines.length; i < len; i += 2) {\n        var match = lineRE.exec(lines[i]);\n\n        if (match) {\n          result.push(new StackFrame({\n            fileName: match[2],\n            lineNumber: match[1],\n            source: lines[i]\n          }));\n        }\n      }\n\n      return result;\n    },\n    parseOpera10: function ErrorStackParser$$parseOpera10(e) {\n      var lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n      var lines = e.stacktrace.split('\\n');\n      var result = [];\n\n      for (var i = 0, len = lines.length; i < len; i += 2) {\n        var match = lineRE.exec(lines[i]);\n\n        if (match) {\n          result.push(new StackFrame({\n            functionName: match[3] || undefined,\n            fileName: match[2],\n            lineNumber: match[1],\n            source: lines[i]\n          }));\n        }\n      }\n\n      return result;\n    },\n    // Opera 10.65+ Error.stack very similar to FF/Safari\n    parseOpera11: function ErrorStackParser$$parseOpera11(error) {\n      var filtered = error.stack.split('\\n').filter(function (line) {\n        return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);\n      }, this);\n      return filtered.map(function (line) {\n        var tokens = line.split('@');\n        var locationParts = this.extractLocation(tokens.pop());\n        var functionCall = tokens.shift() || '';\n        var functionName = functionCall.replace(/<anonymous function(: (\\w+))?>/, '$2').replace(/\\([^)]*\\)/g, '') || undefined;\n        var argsRaw;\n\n        if (functionCall.match(/\\(([^)]*)\\)/)) {\n          argsRaw = functionCall.replace(/^[^(]+\\(([^)]*)\\)$/, '$1');\n        }\n\n        var args = argsRaw === undefined || argsRaw === '[arguments not available]' ? undefined : argsRaw.split(',');\n        return new StackFrame({\n          functionName: functionName,\n          args: args,\n          fileName: locationParts[0],\n          lineNumber: locationParts[1],\n          columnNumber: locationParts[2],\n          source: line\n        });\n      }, this);\n    }\n  };\n});\n\n/***/ }),\n\n/***/ 53:\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n/** Used as references for various `Number` constants. */\n\nvar NAN = 0 / 0;\n/** `Object#toString` result references. */\n\nvar symbolTag = '[object Symbol]';\n/** Used to match leading and trailing whitespace. */\n\nvar reTrim = /^\\s+|\\s+$/g;\n/** Used to detect bad signed hexadecimal string values. */\n\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n/** Used to detect binary string values. */\n\nvar reIsBinary = /^0b[01]+$/i;\n/** Used to detect octal string values. */\n\nvar reIsOctal = /^0o[0-7]+$/i;\n/** Built-in method references without a dependency on `root`. */\n\nvar freeParseInt = parseInt;\n/** Detect free variable `global` from Node.js. */\n\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n/** Detect free variable `self`. */\n\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n/** Used as a reference to the global object. */\n\nvar root = freeGlobal || freeSelf || Function('return this')();\n/** Used for built-in method references. */\n\nvar objectProto = Object.prototype;\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\n\nvar objectToString = objectProto.toString;\n/* Built-in method references for those with the same name as other `lodash` methods. */\n\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\n\nvar now = function () {\n  return root.Date.now();\n};\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\n\n\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n\n  wait = toNumber(wait) || 0;\n\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time; // Start the timer for the trailing edge.\n\n    timerId = setTimeout(timerExpired, wait); // Invoke the leading edge.\n\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n\n    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n  }\n\n  function timerExpired() {\n    var time = now();\n\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    } // Restart the timer.\n\n\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n\n    return result;\n  }\n\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide `options` to indicate whether `func`\n * should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */\n\n\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\n\n\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\n\n\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\n\n\nfunction isSymbol(value) {\n  return typeof value == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;\n}\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\n\n\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n\n  if (isSymbol(value)) {\n    return NAN;\n  }\n\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? other + '' : other;\n  }\n\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;\n}\n\nmodule.exports = throttle;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(40)))\n\n/***/ }),\n\n/***/ 54:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n // A linked list to keep track of recently-used-ness\n\nconst Yallist = __webpack_require__(82);\n\nconst MAX = Symbol('max');\nconst LENGTH = Symbol('length');\nconst LENGTH_CALCULATOR = Symbol('lengthCalculator');\nconst ALLOW_STALE = Symbol('allowStale');\nconst MAX_AGE = Symbol('maxAge');\nconst DISPOSE = Symbol('dispose');\nconst NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet');\nconst LRU_LIST = Symbol('lruList');\nconst CACHE = Symbol('cache');\nconst UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet');\n\nconst naiveLength = () => 1; // lruList is a yallist where the head is the youngest\n// item, and the tail is the oldest.  the list contains the Hit\n// objects as the entries.\n// Each Hit object has a reference to its Yallist.Node.  This\n// never changes.\n//\n// cache is a Map (or PseudoMap) that matches the keys to\n// the Yallist.Node object.\n\n\nclass LRUCache {\n  constructor(options) {\n    if (typeof options === 'number') options = {\n      max: options\n    };\n    if (!options) options = {};\n    if (options.max && (typeof options.max !== 'number' || options.max < 0)) throw new TypeError('max must be a non-negative number'); // Kind of weird to have a default max of Infinity, but oh well.\n\n    const max = this[MAX] = options.max || Infinity;\n    const lc = options.length || naiveLength;\n    this[LENGTH_CALCULATOR] = typeof lc !== 'function' ? naiveLength : lc;\n    this[ALLOW_STALE] = options.stale || false;\n    if (options.maxAge && typeof options.maxAge !== 'number') throw new TypeError('maxAge must be a number');\n    this[MAX_AGE] = options.maxAge || 0;\n    this[DISPOSE] = options.dispose;\n    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;\n    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;\n    this.reset();\n  } // resize the cache when the max changes.\n\n\n  set max(mL) {\n    if (typeof mL !== 'number' || mL < 0) throw new TypeError('max must be a non-negative number');\n    this[MAX] = mL || Infinity;\n    trim(this);\n  }\n\n  get max() {\n    return this[MAX];\n  }\n\n  set allowStale(allowStale) {\n    this[ALLOW_STALE] = !!allowStale;\n  }\n\n  get allowStale() {\n    return this[ALLOW_STALE];\n  }\n\n  set maxAge(mA) {\n    if (typeof mA !== 'number') throw new TypeError('maxAge must be a non-negative number');\n    this[MAX_AGE] = mA;\n    trim(this);\n  }\n\n  get maxAge() {\n    return this[MAX_AGE];\n  } // resize the cache when the lengthCalculator changes.\n\n\n  set lengthCalculator(lC) {\n    if (typeof lC !== 'function') lC = naiveLength;\n\n    if (lC !== this[LENGTH_CALCULATOR]) {\n      this[LENGTH_CALCULATOR] = lC;\n      this[LENGTH] = 0;\n      this[LRU_LIST].forEach(hit => {\n        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);\n        this[LENGTH] += hit.length;\n      });\n    }\n\n    trim(this);\n  }\n\n  get lengthCalculator() {\n    return this[LENGTH_CALCULATOR];\n  }\n\n  get length() {\n    return this[LENGTH];\n  }\n\n  get itemCount() {\n    return this[LRU_LIST].length;\n  }\n\n  rforEach(fn, thisp) {\n    thisp = thisp || this;\n\n    for (let walker = this[LRU_LIST].tail; walker !== null;) {\n      const prev = walker.prev;\n      forEachStep(this, fn, walker, thisp);\n      walker = prev;\n    }\n  }\n\n  forEach(fn, thisp) {\n    thisp = thisp || this;\n\n    for (let walker = this[LRU_LIST].head; walker !== null;) {\n      const next = walker.next;\n      forEachStep(this, fn, walker, thisp);\n      walker = next;\n    }\n  }\n\n  keys() {\n    return this[LRU_LIST].toArray().map(k => k.key);\n  }\n\n  values() {\n    return this[LRU_LIST].toArray().map(k => k.value);\n  }\n\n  reset() {\n    if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {\n      this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value));\n    }\n\n    this[CACHE] = new Map(); // hash of items by key\n\n    this[LRU_LIST] = new Yallist(); // list of items in order of use recency\n\n    this[LENGTH] = 0; // length of items in the list\n  }\n\n  dump() {\n    return this[LRU_LIST].map(hit => isStale(this, hit) ? false : {\n      k: hit.key,\n      v: hit.value,\n      e: hit.now + (hit.maxAge || 0)\n    }).toArray().filter(h => h);\n  }\n\n  dumpLru() {\n    return this[LRU_LIST];\n  }\n\n  set(key, value, maxAge) {\n    maxAge = maxAge || this[MAX_AGE];\n    if (maxAge && typeof maxAge !== 'number') throw new TypeError('maxAge must be a number');\n    const now = maxAge ? Date.now() : 0;\n    const len = this[LENGTH_CALCULATOR](value, key);\n\n    if (this[CACHE].has(key)) {\n      if (len > this[MAX]) {\n        del(this, this[CACHE].get(key));\n        return false;\n      }\n\n      const node = this[CACHE].get(key);\n      const item = node.value; // dispose of the old one before overwriting\n      // split out into 2 ifs for better coverage tracking\n\n      if (this[DISPOSE]) {\n        if (!this[NO_DISPOSE_ON_SET]) this[DISPOSE](key, item.value);\n      }\n\n      item.now = now;\n      item.maxAge = maxAge;\n      item.value = value;\n      this[LENGTH] += len - item.length;\n      item.length = len;\n      this.get(key);\n      trim(this);\n      return true;\n    }\n\n    const hit = new Entry(key, value, len, now, maxAge); // oversized objects fall out of cache automatically.\n\n    if (hit.length > this[MAX]) {\n      if (this[DISPOSE]) this[DISPOSE](key, value);\n      return false;\n    }\n\n    this[LENGTH] += hit.length;\n    this[LRU_LIST].unshift(hit);\n    this[CACHE].set(key, this[LRU_LIST].head);\n    trim(this);\n    return true;\n  }\n\n  has(key) {\n    if (!this[CACHE].has(key)) return false;\n    const hit = this[CACHE].get(key).value;\n    return !isStale(this, hit);\n  }\n\n  get(key) {\n    return get(this, key, true);\n  }\n\n  peek(key) {\n    return get(this, key, false);\n  }\n\n  pop() {\n    const node = this[LRU_LIST].tail;\n    if (!node) return null;\n    del(this, node);\n    return node.value;\n  }\n\n  del(key) {\n    del(this, this[CACHE].get(key));\n  }\n\n  load(arr) {\n    // reset the cache\n    this.reset();\n    const now = Date.now(); // A previous serialized cache has the most recent items first\n\n    for (let l = arr.length - 1; l >= 0; l--) {\n      const hit = arr[l];\n      const expiresAt = hit.e || 0;\n      if (expiresAt === 0) // the item was created without expiration in a non aged cache\n        this.set(hit.k, hit.v);else {\n        const maxAge = expiresAt - now; // dont add already expired items\n\n        if (maxAge > 0) {\n          this.set(hit.k, hit.v, maxAge);\n        }\n      }\n    }\n  }\n\n  prune() {\n    this[CACHE].forEach((value, key) => get(this, key, false));\n  }\n\n}\n\nconst get = (self, key, doUse) => {\n  const node = self[CACHE].get(key);\n\n  if (node) {\n    const hit = node.value;\n\n    if (isStale(self, hit)) {\n      del(self, node);\n      if (!self[ALLOW_STALE]) return undefined;\n    } else {\n      if (doUse) {\n        if (self[UPDATE_AGE_ON_GET]) node.value.now = Date.now();\n        self[LRU_LIST].unshiftNode(node);\n      }\n    }\n\n    return hit.value;\n  }\n};\n\nconst isStale = (self, hit) => {\n  if (!hit || !hit.maxAge && !self[MAX_AGE]) return false;\n  const diff = Date.now() - hit.now;\n  return hit.maxAge ? diff > hit.maxAge : self[MAX_AGE] && diff > self[MAX_AGE];\n};\n\nconst trim = self => {\n  if (self[LENGTH] > self[MAX]) {\n    for (let walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null;) {\n      // We know that we're about to delete this one, and also\n      // what the next least recently used key will be, so just\n      // go ahead and set it now.\n      const prev = walker.prev;\n      del(self, walker);\n      walker = prev;\n    }\n  }\n};\n\nconst del = (self, node) => {\n  if (node) {\n    const hit = node.value;\n    if (self[DISPOSE]) self[DISPOSE](hit.key, hit.value);\n    self[LENGTH] -= hit.length;\n    self[CACHE].delete(hit.key);\n    self[LRU_LIST].removeNode(node);\n  }\n};\n\nclass Entry {\n  constructor(key, value, length, now, maxAge) {\n    this.key = key;\n    this.value = value;\n    this.length = length;\n    this.now = now;\n    this.maxAge = maxAge || 0;\n  }\n\n}\n\nconst forEachStep = (self, fn, node, thisp) => {\n  let hit = node.value;\n\n  if (isStale(self, hit)) {\n    del(self, node);\n    if (!self[ALLOW_STALE]) hit = undefined;\n  }\n\n  if (hit) fn.call(thisp, hit.value, hit.key, self);\n};\n\nmodule.exports = LRUCache;\n\n/***/ }),\n\n/***/ 61:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// $FlowFixMe[method-unbinding]\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n/* harmony default export */ __webpack_exports__[\"a\"] = (hasOwnProperty);\n\n/***/ }),\n\n/***/ 67:\n/***/ (function(module, exports) {\n\n// shim for using process in browser\nvar process = module.exports = {}; // cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n  throw new Error('setTimeout has not been defined');\n}\n\nfunction defaultClearTimeout() {\n  throw new Error('clearTimeout has not been defined');\n}\n\n(function () {\n  try {\n    if (typeof setTimeout === 'function') {\n      cachedSetTimeout = setTimeout;\n    } else {\n      cachedSetTimeout = defaultSetTimout;\n    }\n  } catch (e) {\n    cachedSetTimeout = defaultSetTimout;\n  }\n\n  try {\n    if (typeof clearTimeout === 'function') {\n      cachedClearTimeout = clearTimeout;\n    } else {\n      cachedClearTimeout = defaultClearTimeout;\n    }\n  } catch (e) {\n    cachedClearTimeout = defaultClearTimeout;\n  }\n})();\n\nfunction runTimeout(fun) {\n  if (cachedSetTimeout === setTimeout) {\n    //normal enviroments in sane situations\n    return setTimeout(fun, 0);\n  } // if setTimeout wasn't available but was latter defined\n\n\n  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n    cachedSetTimeout = setTimeout;\n    return setTimeout(fun, 0);\n  }\n\n  try {\n    // when when somebody has screwed with setTimeout but no I.E. maddness\n    return cachedSetTimeout(fun, 0);\n  } catch (e) {\n    try {\n      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n      return cachedSetTimeout.call(null, fun, 0);\n    } catch (e) {\n      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n      return cachedSetTimeout.call(this, fun, 0);\n    }\n  }\n}\n\nfunction runClearTimeout(marker) {\n  if (cachedClearTimeout === clearTimeout) {\n    //normal enviroments in sane situations\n    return clearTimeout(marker);\n  } // if clearTimeout wasn't available but was latter defined\n\n\n  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n    cachedClearTimeout = clearTimeout;\n    return clearTimeout(marker);\n  }\n\n  try {\n    // when when somebody has screwed with setTimeout but no I.E. maddness\n    return cachedClearTimeout(marker);\n  } catch (e) {\n    try {\n      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n      return cachedClearTimeout.call(null, marker);\n    } catch (e) {\n      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n      // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n      return cachedClearTimeout.call(this, marker);\n    }\n  }\n}\n\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n  if (!draining || !currentQueue) {\n    return;\n  }\n\n  draining = false;\n\n  if (currentQueue.length) {\n    queue = currentQueue.concat(queue);\n  } else {\n    queueIndex = -1;\n  }\n\n  if (queue.length) {\n    drainQueue();\n  }\n}\n\nfunction drainQueue() {\n  if (draining) {\n    return;\n  }\n\n  var timeout = runTimeout(cleanUpNextTick);\n  draining = true;\n  var len = queue.length;\n\n  while (len) {\n    currentQueue = queue;\n    queue = [];\n\n    while (++queueIndex < len) {\n      if (currentQueue) {\n        currentQueue[queueIndex].run();\n      }\n    }\n\n    queueIndex = -1;\n    len = queue.length;\n  }\n\n  currentQueue = null;\n  draining = false;\n  runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n  var args = new Array(arguments.length - 1);\n\n  if (arguments.length > 1) {\n    for (var i = 1; i < arguments.length; i++) {\n      args[i - 1] = arguments[i];\n    }\n  }\n\n  queue.push(new Item(fun, args));\n\n  if (queue.length === 1 && !draining) {\n    runTimeout(drainQueue);\n  }\n}; // v8 likes predictible objects\n\n\nfunction Item(fun, array) {\n  this.fun = fun;\n  this.array = array;\n}\n\nItem.prototype.run = function () {\n  this.fun.apply(null, this.array);\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\n\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) {\n  return [];\n};\n\nprocess.binding = function (name) {\n  throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () {\n  return '/';\n};\n\nprocess.chdir = function (dir) {\n  throw new Error('process.chdir is not supported');\n};\n\nprocess.umask = function () {\n  return 0;\n};\n\n/***/ }),\n\n/***/ 70:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"b\", function() { return /* binding */ getInternalReactConstants; });\n__webpack_require__.d(__webpack_exports__, \"a\", function() { return /* binding */ attach; });\n\n// EXTERNAL MODULE: ../react-devtools-shared/src/types.js\nvar types = __webpack_require__(2);\n\n// EXTERNAL MODULE: ../react-devtools-shared/src/utils.js + 1 modules\nvar utils = __webpack_require__(3);\n\n// EXTERNAL MODULE: ../react-devtools-shared/src/storage.js\nvar storage = __webpack_require__(10);\n\n// EXTERNAL MODULE: ../react-devtools-shared/src/backend/utils.js + 1 modules\nvar backend_utils = __webpack_require__(12);\n\n// EXTERNAL MODULE: ../react-devtools-shared/src/constants.js\nvar constants = __webpack_require__(1);\n\n// EXTERNAL MODULE: /Users/xch/dev/react/node_modules/error-stack-parser/error-stack-parser.js\nvar error_stack_parser = __webpack_require__(51);\nvar error_stack_parser_default = /*#__PURE__*/__webpack_require__.n(error_stack_parser);\n\n// CONCATENATED MODULE: ../shared/assign.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst assign_assign = Object.assign;\n/* harmony default export */ var shared_assign = (assign_assign);\n// EXTERNAL MODULE: external \"react\"\nvar external_react_ = __webpack_require__(0);\n\n// CONCATENATED MODULE: ../shared/ReactSharedInternals.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nconst ReactSharedInternals = external_react_[\"__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\"];\n/* harmony default export */ var shared_ReactSharedInternals = (ReactSharedInternals);\n// CONCATENATED MODULE: ../react-reconciler/src/ReactWorkTags.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst ReactWorkTags_FunctionComponent = 0;\nconst ReactWorkTags_ClassComponent = 1;\nconst ReactWorkTags_IndeterminateComponent = 2; // Before we know whether it is function or class\n\nconst ReactWorkTags_HostRoot = 3; // Root of a host tree. Could be nested inside another node.\n\nconst ReactWorkTags_HostPortal = 4; // A subtree. Could be an entry point to a different renderer.\n\nconst ReactWorkTags_HostComponent = 5;\nconst ReactWorkTags_HostText = 6;\nconst ReactWorkTags_Fragment = 7;\nconst Mode = 8;\nconst ReactWorkTags_ContextConsumer = 9;\nconst ContextProvider = 10;\nconst ReactWorkTags_ForwardRef = 11;\nconst ReactWorkTags_Profiler = 12;\nconst ReactWorkTags_SuspenseComponent = 13;\nconst ReactWorkTags_MemoComponent = 14;\nconst ReactWorkTags_SimpleMemoComponent = 15;\nconst ReactWorkTags_LazyComponent = 16;\nconst ReactWorkTags_IncompleteClassComponent = 17;\nconst DehydratedFragment = 18;\nconst ReactWorkTags_SuspenseListComponent = 19;\nconst ReactWorkTags_ScopeComponent = 21;\nconst ReactWorkTags_OffscreenComponent = 22;\nconst ReactWorkTags_LegacyHiddenComponent = 23;\nconst ReactWorkTags_CacheComponent = 24;\nconst ReactWorkTags_TracingMarkerComponent = 25;\nconst ReactWorkTags_HostResource = 26;\nconst ReactWorkTags_HostSingleton = 27;\n// CONCATENATED MODULE: ../react-debug-tools/src/ReactDebugHooks.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\n\nlet hookLog = []; // Primitives\n\nlet primitiveStackCache = null;\n\nfunction getPrimitiveStackCache() {\n  // This initializes a cache of all primitive hooks so that the top\n  // most stack frames added by calling the primitive hook can be removed.\n  if (primitiveStackCache === null) {\n    const cache = new Map();\n    let readHookLog;\n\n    try {\n      // Use all hooks here to add them to the hook log.\n      Dispatcher.useContext({\n        _currentValue: null\n      });\n      Dispatcher.useState(null);\n      Dispatcher.useReducer((s, a) => s, null);\n      Dispatcher.useRef(null);\n\n      if (typeof Dispatcher.useCacheRefresh === 'function') {\n        // This type check is for Flow only.\n        Dispatcher.useCacheRefresh();\n      }\n\n      Dispatcher.useLayoutEffect(() => {});\n      Dispatcher.useInsertionEffect(() => {});\n      Dispatcher.useEffect(() => {});\n      Dispatcher.useImperativeHandle(undefined, () => null);\n      Dispatcher.useDebugValue(null);\n      Dispatcher.useCallback(() => {});\n      Dispatcher.useMemo(() => null);\n    } finally {\n      readHookLog = hookLog;\n      hookLog = [];\n    }\n\n    for (let i = 0; i < readHookLog.length; i++) {\n      const hook = readHookLog[i];\n      cache.set(hook.primitive, error_stack_parser_default.a.parse(hook.stackError));\n    }\n\n    primitiveStackCache = cache;\n  }\n\n  return primitiveStackCache;\n}\n\nlet currentHook = null;\n\nfunction nextHook() {\n  const hook = currentHook;\n\n  if (hook !== null) {\n    currentHook = hook.next;\n  }\n\n  return hook;\n}\n\nfunction readContext(context) {\n  // For now we don't expose readContext usage in the hooks debugging info.\n  return context._currentValue;\n}\n\nfunction useContext(context) {\n  hookLog.push({\n    primitive: 'Context',\n    stackError: new Error(),\n    value: context._currentValue\n  });\n  return context._currentValue;\n}\n\nfunction useState(initialState) {\n  const hook = nextHook();\n  const state = hook !== null ? hook.memoizedState : typeof initialState === 'function' ? // $FlowFixMe: Flow doesn't like mixed types\n  initialState() : initialState;\n  hookLog.push({\n    primitive: 'State',\n    stackError: new Error(),\n    value: state\n  });\n  return [state, action => {}];\n}\n\nfunction useReducer(reducer, initialArg, init) {\n  const hook = nextHook();\n  let state;\n\n  if (hook !== null) {\n    state = hook.memoizedState;\n  } else {\n    state = init !== undefined ? init(initialArg) : initialArg;\n  }\n\n  hookLog.push({\n    primitive: 'Reducer',\n    stackError: new Error(),\n    value: state\n  });\n  return [state, action => {}];\n}\n\nfunction useRef(initialValue) {\n  const hook = nextHook();\n  const ref = hook !== null ? hook.memoizedState : {\n    current: initialValue\n  };\n  hookLog.push({\n    primitive: 'Ref',\n    stackError: new Error(),\n    value: ref.current\n  });\n  return ref;\n}\n\nfunction useCacheRefresh() {\n  const hook = nextHook();\n  hookLog.push({\n    primitive: 'CacheRefresh',\n    stackError: new Error(),\n    value: hook !== null ? hook.memoizedState : function refresh() {}\n  });\n  return () => {};\n}\n\nfunction useLayoutEffect(create, inputs) {\n  nextHook();\n  hookLog.push({\n    primitive: 'LayoutEffect',\n    stackError: new Error(),\n    value: create\n  });\n}\n\nfunction useInsertionEffect(create, inputs) {\n  nextHook();\n  hookLog.push({\n    primitive: 'InsertionEffect',\n    stackError: new Error(),\n    value: create\n  });\n}\n\nfunction useEffect(create, inputs) {\n  nextHook();\n  hookLog.push({\n    primitive: 'Effect',\n    stackError: new Error(),\n    value: create\n  });\n}\n\nfunction useImperativeHandle(ref, create, inputs) {\n  nextHook(); // We don't actually store the instance anywhere if there is no ref callback\n  // and if there is a ref callback it might not store it but if it does we\n  // have no way of knowing where. So let's only enable introspection of the\n  // ref itself if it is using the object form.\n\n  let instance = undefined;\n\n  if (ref !== null && typeof ref === 'object') {\n    instance = ref.current;\n  }\n\n  hookLog.push({\n    primitive: 'ImperativeHandle',\n    stackError: new Error(),\n    value: instance\n  });\n}\n\nfunction useDebugValue(value, formatterFn) {\n  hookLog.push({\n    primitive: 'DebugValue',\n    stackError: new Error(),\n    value: typeof formatterFn === 'function' ? formatterFn(value) : value\n  });\n}\n\nfunction useCallback(callback, inputs) {\n  const hook = nextHook();\n  hookLog.push({\n    primitive: 'Callback',\n    stackError: new Error(),\n    value: hook !== null ? hook.memoizedState[0] : callback\n  });\n  return callback;\n}\n\nfunction useMemo(nextCreate, inputs) {\n  const hook = nextHook();\n  const value = hook !== null ? hook.memoizedState[0] : nextCreate();\n  hookLog.push({\n    primitive: 'Memo',\n    stackError: new Error(),\n    value\n  });\n  return value;\n}\n\nfunction useMutableSource(source, getSnapshot, subscribe) {\n  // useMutableSource() composes multiple hooks internally.\n  // Advance the current hook index the same number of times\n  // so that subsequent hooks have the right memoized state.\n  nextHook(); // MutableSource\n\n  nextHook(); // State\n\n  nextHook(); // Effect\n\n  nextHook(); // Effect\n\n  const value = getSnapshot(source._source);\n  hookLog.push({\n    primitive: 'MutableSource',\n    stackError: new Error(),\n    value\n  });\n  return value;\n}\n\nfunction useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n  // useSyncExternalStore() composes multiple hooks internally.\n  // Advance the current hook index the same number of times\n  // so that subsequent hooks have the right memoized state.\n  nextHook(); // SyncExternalStore\n\n  nextHook(); // Effect\n\n  const value = getSnapshot();\n  hookLog.push({\n    primitive: 'SyncExternalStore',\n    stackError: new Error(),\n    value\n  });\n  return value;\n}\n\nfunction useTransition() {\n  // useTransition() composes multiple hooks internally.\n  // Advance the current hook index the same number of times\n  // so that subsequent hooks have the right memoized state.\n  nextHook(); // State\n\n  nextHook(); // Callback\n\n  hookLog.push({\n    primitive: 'Transition',\n    stackError: new Error(),\n    value: undefined\n  });\n  return [false, callback => {}];\n}\n\nfunction useDeferredValue(value) {\n  const hook = nextHook();\n  hookLog.push({\n    primitive: 'DeferredValue',\n    stackError: new Error(),\n    value: hook !== null ? hook.memoizedState : value\n  });\n  return value;\n}\n\nfunction useId() {\n  const hook = nextHook();\n  const id = hook !== null ? hook.memoizedState : '';\n  hookLog.push({\n    primitive: 'Id',\n    stackError: new Error(),\n    value: id\n  });\n  return id;\n}\n\nconst Dispatcher = {\n  readContext,\n  useCacheRefresh,\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useDebugValue,\n  useLayoutEffect,\n  useInsertionEffect,\n  useMemo,\n  useReducer,\n  useRef,\n  useState,\n  useTransition,\n  useMutableSource,\n  useSyncExternalStore,\n  useDeferredValue,\n  useId\n}; // create a proxy to throw a custom error\n// in case future versions of React adds more hooks\n\nconst DispatcherProxyHandler = {\n  get(target, prop) {\n    if (target.hasOwnProperty(prop)) {\n      return target[prop];\n    }\n\n    const error = new Error('Missing method in Dispatcher: ' + prop); // Note: This error name needs to stay in sync with react-devtools-shared\n    // TODO: refactor this if we ever combine the devtools and debug tools packages\n\n    error.name = 'ReactDebugToolsUnsupportedHookError';\n    throw error;\n  }\n\n}; // `Proxy` may not exist on some platforms\n\nconst DispatcherProxy = typeof Proxy === 'undefined' ? Dispatcher : new Proxy(Dispatcher, DispatcherProxyHandler); // Inspect\n\n// Don't assume\n//\n// We can't assume that stack frames are nth steps away from anything.\n// E.g. we can't assume that the root call shares all frames with the stack\n// of a hook call. A simple way to demonstrate this is wrapping `new Error()`\n// in a wrapper constructor like a polyfill. That'll add an extra frame.\n// Similar things can happen with the call to the dispatcher. The top frame\n// may not be the primitive. Likewise the primitive can have fewer stack frames\n// such as when a call to useState got inlined to use dispatcher.useState.\n//\n// We also can't assume that the last frame of the root call is the same\n// frame as the last frame of the hook call because long stack traces can be\n// truncated to a stack trace limit.\nlet mostLikelyAncestorIndex = 0;\n\nfunction findSharedIndex(hookStack, rootStack, rootIndex) {\n  const source = rootStack[rootIndex].source;\n\n  hookSearch: for (let i = 0; i < hookStack.length; i++) {\n    if (hookStack[i].source === source) {\n      // This looks like a match. Validate that the rest of both stack match up.\n      for (let a = rootIndex + 1, b = i + 1; a < rootStack.length && b < hookStack.length; a++, b++) {\n        if (hookStack[b].source !== rootStack[a].source) {\n          // If not, give up and try a different match.\n          continue hookSearch;\n        }\n      }\n\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nfunction findCommonAncestorIndex(rootStack, hookStack) {\n  let rootIndex = findSharedIndex(hookStack, rootStack, mostLikelyAncestorIndex);\n\n  if (rootIndex !== -1) {\n    return rootIndex;\n  } // If the most likely one wasn't a hit, try any other frame to see if it is shared.\n  // If that takes more than 5 frames, something probably went wrong.\n\n\n  for (let i = 0; i < rootStack.length && i < 5; i++) {\n    rootIndex = findSharedIndex(hookStack, rootStack, i);\n\n    if (rootIndex !== -1) {\n      mostLikelyAncestorIndex = i;\n      return rootIndex;\n    }\n  }\n\n  return -1;\n}\n\nfunction isReactWrapper(functionName, primitiveName) {\n  if (!functionName) {\n    return false;\n  }\n\n  const expectedPrimitiveName = 'use' + primitiveName;\n\n  if (functionName.length < expectedPrimitiveName.length) {\n    return false;\n  }\n\n  return functionName.lastIndexOf(expectedPrimitiveName) === functionName.length - expectedPrimitiveName.length;\n}\n\nfunction findPrimitiveIndex(hookStack, hook) {\n  const stackCache = getPrimitiveStackCache();\n  const primitiveStack = stackCache.get(hook.primitive);\n\n  if (primitiveStack === undefined) {\n    return -1;\n  }\n\n  for (let i = 0; i < primitiveStack.length && i < hookStack.length; i++) {\n    if (primitiveStack[i].source !== hookStack[i].source) {\n      // If the next two frames are functions called `useX` then we assume that they're part of the\n      // wrappers that the React packager or other packages adds around the dispatcher.\n      if (i < hookStack.length - 1 && isReactWrapper(hookStack[i].functionName, hook.primitive)) {\n        i++;\n      }\n\n      if (i < hookStack.length - 1 && isReactWrapper(hookStack[i].functionName, hook.primitive)) {\n        i++;\n      }\n\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nfunction parseTrimmedStack(rootStack, hook) {\n  // Get the stack trace between the primitive hook function and\n  // the root function call. I.e. the stack frames of custom hooks.\n  const hookStack = error_stack_parser_default.a.parse(hook.stackError);\n  const rootIndex = findCommonAncestorIndex(rootStack, hookStack);\n  const primitiveIndex = findPrimitiveIndex(hookStack, hook);\n\n  if (rootIndex === -1 || primitiveIndex === -1 || rootIndex - primitiveIndex < 2) {\n    // Something went wrong. Give up.\n    return null;\n  }\n\n  return hookStack.slice(primitiveIndex, rootIndex - 1);\n}\n\nfunction parseCustomHookName(functionName) {\n  if (!functionName) {\n    return '';\n  }\n\n  let startIndex = functionName.lastIndexOf('.');\n\n  if (startIndex === -1) {\n    startIndex = 0;\n  }\n\n  if (functionName.substr(startIndex, 3) === 'use') {\n    startIndex += 3;\n  }\n\n  return functionName.substr(startIndex);\n}\n\nfunction buildTree(rootStack, readHookLog, includeHooksSource) {\n  const rootChildren = [];\n  let prevStack = null;\n  let levelChildren = rootChildren;\n  let nativeHookID = 0;\n  const stackOfChildren = [];\n\n  for (let i = 0; i < readHookLog.length; i++) {\n    const hook = readHookLog[i];\n    const stack = parseTrimmedStack(rootStack, hook);\n\n    if (stack !== null) {\n      // Note: The indices 0 <= n < length-1 will contain the names.\n      // The indices 1 <= n < length will contain the source locations.\n      // That's why we get the name from n - 1 and don't check the source\n      // of index 0.\n      let commonSteps = 0;\n\n      if (prevStack !== null) {\n        // Compare the current level's stack to the new stack.\n        while (commonSteps < stack.length && commonSteps < prevStack.length) {\n          const stackSource = stack[stack.length - commonSteps - 1].source;\n          const prevSource = prevStack[prevStack.length - commonSteps - 1].source;\n\n          if (stackSource !== prevSource) {\n            break;\n          }\n\n          commonSteps++;\n        } // Pop back the stack as many steps as were not common.\n\n\n        for (let j = prevStack.length - 1; j > commonSteps; j--) {\n          levelChildren = stackOfChildren.pop();\n        }\n      } // The remaining part of the new stack are custom hooks. Push them\n      // to the tree.\n\n\n      for (let j = stack.length - commonSteps - 1; j >= 1; j--) {\n        const children = [];\n        const stackFrame = stack[j];\n        const levelChild = {\n          id: null,\n          isStateEditable: false,\n          name: parseCustomHookName(stack[j - 1].functionName),\n          value: undefined,\n          subHooks: children\n        };\n\n        if (includeHooksSource) {\n          levelChild.hookSource = {\n            lineNumber: stackFrame.lineNumber,\n            columnNumber: stackFrame.columnNumber,\n            functionName: stackFrame.functionName,\n            fileName: stackFrame.fileName\n          };\n        }\n\n        levelChildren.push(levelChild);\n        stackOfChildren.push(levelChildren);\n        levelChildren = children;\n      }\n\n      prevStack = stack;\n    }\n\n    const {\n      primitive\n    } = hook; // For now, the \"id\" of stateful hooks is just the stateful hook index.\n    // Custom hooks have no ids, nor do non-stateful native hooks (e.g. Context, DebugValue).\n\n    const id = primitive === 'Context' || primitive === 'DebugValue' ? null : nativeHookID++; // For the time being, only State and Reducer hooks support runtime overrides.\n\n    const isStateEditable = primitive === 'Reducer' || primitive === 'State';\n    const levelChild = {\n      id,\n      isStateEditable,\n      name: primitive,\n      value: hook.value,\n      subHooks: []\n    };\n\n    if (includeHooksSource) {\n      const hookSource = {\n        lineNumber: null,\n        functionName: null,\n        fileName: null,\n        columnNumber: null\n      };\n\n      if (stack && stack.length >= 1) {\n        const stackFrame = stack[0];\n        hookSource.lineNumber = stackFrame.lineNumber;\n        hookSource.functionName = stackFrame.functionName;\n        hookSource.fileName = stackFrame.fileName;\n        hookSource.columnNumber = stackFrame.columnNumber;\n      }\n\n      levelChild.hookSource = hookSource;\n    }\n\n    levelChildren.push(levelChild);\n  } // Associate custom hook values (useDebugValue() hook entries) with the correct hooks.\n\n\n  processDebugValues(rootChildren, null);\n  return rootChildren;\n} // Custom hooks support user-configurable labels (via the special useDebugValue() hook).\n// That hook adds user-provided values to the hooks tree,\n// but these values aren't intended to appear alongside of the other hooks.\n// Instead they should be attributed to their parent custom hook.\n// This method walks the tree and assigns debug values to their custom hook owners.\n\n\nfunction processDebugValues(hooksTree, parentHooksNode) {\n  const debugValueHooksNodes = [];\n\n  for (let i = 0; i < hooksTree.length; i++) {\n    const hooksNode = hooksTree[i];\n\n    if (hooksNode.name === 'DebugValue' && hooksNode.subHooks.length === 0) {\n      hooksTree.splice(i, 1);\n      i--;\n      debugValueHooksNodes.push(hooksNode);\n    } else {\n      processDebugValues(hooksNode.subHooks, hooksNode);\n    }\n  } // Bubble debug value labels to their custom hook owner.\n  // If there is no parent hook, just ignore them for now.\n  // (We may warn about this in the future.)\n\n\n  if (parentHooksNode !== null) {\n    if (debugValueHooksNodes.length === 1) {\n      parentHooksNode.value = debugValueHooksNodes[0].value;\n    } else if (debugValueHooksNodes.length > 1) {\n      parentHooksNode.value = debugValueHooksNodes.map(({\n        value\n      }) => value);\n    }\n  }\n}\n\nfunction handleRenderFunctionError(error) {\n  // original error might be any type.\n  if (error instanceof Error && error.name === 'ReactDebugToolsUnsupportedHookError') {\n    throw error;\n  } // If the error is not caused by an unsupported feature, it means\n  // that the error is caused by user's code in renderFunction.\n  // In this case, we should wrap the original error inside a custom error\n  // so that devtools can give a clear message about it.\n  // $FlowFixMe: Flow doesn't know about 2nd argument of Error constructor\n\n\n  const wrapperError = new Error('Error rendering inspected component', {\n    cause: error\n  }); // Note: This error name needs to stay in sync with react-devtools-shared\n  // TODO: refactor this if we ever combine the devtools and debug tools packages\n\n  wrapperError.name = 'ReactDebugToolsRenderError'; // this stage-4 proposal is not supported by all environments yet.\n  // $FlowFixMe Flow doesn't have this type yet.\n\n  wrapperError.cause = error;\n  throw wrapperError;\n}\n\nfunction inspectHooks(renderFunction, props, currentDispatcher, includeHooksSource = false) {\n  // DevTools will pass the current renderer's injected dispatcher.\n  // Other apps might compile debug hooks as part of their app though.\n  if (currentDispatcher == null) {\n    currentDispatcher = shared_ReactSharedInternals.ReactCurrentDispatcher;\n  }\n\n  const previousDispatcher = currentDispatcher.current;\n  let readHookLog;\n  currentDispatcher.current = DispatcherProxy;\n  let ancestorStackError;\n\n  try {\n    ancestorStackError = new Error();\n    renderFunction(props);\n  } catch (error) {\n    handleRenderFunctionError(error);\n  } finally {\n    readHookLog = hookLog;\n    hookLog = []; // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n    currentDispatcher.current = previousDispatcher;\n  }\n\n  const rootStack = error_stack_parser_default.a.parse(ancestorStackError);\n  return buildTree(rootStack, readHookLog, includeHooksSource);\n}\n\nfunction setupContexts(contextMap, fiber) {\n  let current = fiber;\n\n  while (current) {\n    if (current.tag === ContextProvider) {\n      const providerType = current.type;\n      const context = providerType._context;\n\n      if (!contextMap.has(context)) {\n        // Store the current value that we're going to restore later.\n        contextMap.set(context, context._currentValue); // Set the inner most provider value on the context.\n\n        context._currentValue = current.memoizedProps.value;\n      }\n    }\n\n    current = current.return;\n  }\n}\n\nfunction restoreContexts(contextMap) {\n  contextMap.forEach((value, context) => context._currentValue = value);\n}\n\nfunction inspectHooksOfForwardRef(renderFunction, props, ref, currentDispatcher, includeHooksSource) {\n  const previousDispatcher = currentDispatcher.current;\n  let readHookLog;\n  currentDispatcher.current = DispatcherProxy;\n  let ancestorStackError;\n\n  try {\n    ancestorStackError = new Error();\n    renderFunction(props, ref);\n  } catch (error) {\n    handleRenderFunctionError(error);\n  } finally {\n    readHookLog = hookLog;\n    hookLog = [];\n    currentDispatcher.current = previousDispatcher;\n  }\n\n  const rootStack = error_stack_parser_default.a.parse(ancestorStackError);\n  return buildTree(rootStack, readHookLog, includeHooksSource);\n}\n\nfunction resolveDefaultProps(Component, baseProps) {\n  if (Component && Component.defaultProps) {\n    // Resolve default props. Taken from ReactElement\n    const props = shared_assign({}, baseProps);\n    const defaultProps = Component.defaultProps;\n\n    for (const propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n\n    return props;\n  }\n\n  return baseProps;\n}\n\nfunction inspectHooksOfFiber(fiber, currentDispatcher, includeHooksSource = false) {\n  // DevTools will pass the current renderer's injected dispatcher.\n  // Other apps might compile debug hooks as part of their app though.\n  if (currentDispatcher == null) {\n    currentDispatcher = shared_ReactSharedInternals.ReactCurrentDispatcher;\n  }\n\n  if (fiber.tag !== ReactWorkTags_FunctionComponent && fiber.tag !== ReactWorkTags_SimpleMemoComponent && fiber.tag !== ReactWorkTags_ForwardRef) {\n    throw new Error('Unknown Fiber. Needs to be a function component to inspect hooks.');\n  } // Warm up the cache so that it doesn't consume the currentHook.\n\n\n  getPrimitiveStackCache();\n  const type = fiber.type;\n  let props = fiber.memoizedProps;\n\n  if (type !== fiber.elementType) {\n    props = resolveDefaultProps(type, props);\n  } // Set up the current hook so that we can step through and read the\n  // current state from them.\n\n\n  currentHook = fiber.memoizedState;\n  const contextMap = new Map();\n\n  try {\n    setupContexts(contextMap, fiber);\n\n    if (fiber.tag === ReactWorkTags_ForwardRef) {\n      return inspectHooksOfForwardRef(type.render, props, fiber.ref, currentDispatcher, includeHooksSource);\n    }\n\n    return inspectHooks(type, props, currentDispatcher, includeHooksSource);\n  } finally {\n    currentHook = null;\n    restoreContexts(contextMap);\n  }\n}\n// CONCATENATED MODULE: ../react-debug-tools/src/ReactDebugTools.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n// CONCATENATED MODULE: ../react-debug-tools/index.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// EXTERNAL MODULE: ../react-devtools-shared/src/backend/console.js\nvar backend_console = __webpack_require__(44);\n\n// EXTERNAL MODULE: ../react-devtools-shared/src/backend/ReactSymbols.js\nvar ReactSymbols = __webpack_require__(8);\n\n// CONCATENATED MODULE: ../react-devtools-shared/src/backend/ReactFiberFlags.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// This list of flags must be synced with the following file:\n// https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberFlags.js\nconst NoFlags =\n/*                      */\n0b000000000000000000000000000;\nconst PerformedWork =\n/*                */\n0b000000000000000000000000001;\nconst Placement =\n/*                    */\n0b000000000000000000000000010;\nconst DidCapture =\n/*                   */\n0b000000000000000000010000000;\nconst Hydrating =\n/*                    */\n0b000000000000001000000000000;\n// EXTERNAL MODULE: ../react-devtools-shared/src/config/DevToolsFeatureFlags.default.js\nvar DevToolsFeatureFlags_default = __webpack_require__(13);\n\n// CONCATENATED MODULE: ../shared/objectIs.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x, y) {\n  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n  ;\n}\n\nconst objectIs = // $FlowFixMe[method-unbinding]\ntypeof Object.is === 'function' ? Object.is : is;\n/* harmony default export */ var shared_objectIs = (objectIs);\n// EXTERNAL MODULE: ../shared/hasOwnProperty.js\nvar shared_hasOwnProperty = __webpack_require__(61);\n\n// EXTERNAL MODULE: ../react-devtools-shared/src/isArray.js\nvar isArray = __webpack_require__(20);\n\n// CONCATENATED MODULE: ../react-devtools-shared/src/backend/StyleX/utils.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nconst cachedStyleNameToValueMap = new Map();\nfunction getStyleXData(data) {\n  const sources = new Set();\n  const resolvedStyles = {};\n  crawlData(data, sources, resolvedStyles);\n  return {\n    sources: Array.from(sources).sort(),\n    resolvedStyles\n  };\n}\nfunction crawlData(data, sources, resolvedStyles) {\n  if (data == null) {\n    return;\n  }\n\n  if (Object(isArray[\"a\" /* default */])(data)) {\n    data.forEach(entry => {\n      if (entry == null) {\n        return;\n      }\n\n      if (Object(isArray[\"a\" /* default */])(entry)) {\n        crawlData(entry, sources, resolvedStyles);\n      } else {\n        crawlObjectProperties(entry, sources, resolvedStyles);\n      }\n    });\n  } else {\n    crawlObjectProperties(data, sources, resolvedStyles);\n  }\n\n  resolvedStyles = Object.fromEntries(Object.entries(resolvedStyles).sort());\n}\n\nfunction crawlObjectProperties(entry, sources, resolvedStyles) {\n  const keys = Object.keys(entry);\n  keys.forEach(key => {\n    const value = entry[key];\n\n    if (typeof value === 'string') {\n      if (key === value) {\n        // Special case; this key is the name of the style's source/file/module.\n        sources.add(key);\n      } else {\n        resolvedStyles[key] = getPropertyValueForStyleName(value);\n      }\n    } else {\n      const nestedStyle = {};\n      resolvedStyles[key] = nestedStyle;\n      crawlData([value], sources, nestedStyle);\n    }\n  });\n}\n\nfunction getPropertyValueForStyleName(styleName) {\n  if (cachedStyleNameToValueMap.has(styleName)) {\n    return cachedStyleNameToValueMap.get(styleName);\n  }\n\n  for (let styleSheetIndex = 0; styleSheetIndex < document.styleSheets.length; styleSheetIndex++) {\n    const styleSheet = document.styleSheets[styleSheetIndex]; // $FlowFixMe Flow doesn't konw about these properties\n\n    const rules = styleSheet.rules || styleSheet.cssRules; // $FlowFixMe `rules` is mixed\n\n    for (let ruleIndex = 0; ruleIndex < rules.length; ruleIndex++) {\n      // $FlowFixMe `rules` is mixed\n      const rule = rules[ruleIndex]; // $FlowFixMe Flow doesn't konw about these properties\n\n      const {\n        cssText,\n        selectorText,\n        style\n      } = rule;\n\n      if (selectorText != null) {\n        if (selectorText.startsWith(`.${styleName}`)) {\n          const match = cssText.match(/{ *([a-z\\-]+):/);\n\n          if (match !== null) {\n            const property = match[1];\n            const value = style.getPropertyValue(property);\n            cachedStyleNameToValueMap.set(styleName, value);\n            return value;\n          } else {\n            return null;\n          }\n        }\n      }\n    }\n  }\n\n  return null;\n}\n// EXTERNAL MODULE: ../shared/isArray.js\nvar shared_isArray = __webpack_require__(35);\n\n// EXTERNAL MODULE: ../react-devtools-timeline/src/constants.js\nvar src_constants = __webpack_require__(45);\n\n// EXTERNAL MODULE: ../react-devtools-shared/src/backend/DevToolsFiberComponentStack.js + 2 modules\nvar DevToolsFiberComponentStack = __webpack_require__(71);\n\n// CONCATENATED MODULE: ../react-devtools-shared/src/backend/profilingHooks.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n // Add padding to the start/stop time of the profile.\n// This makes the UI nicer to use.\n\nconst TIME_OFFSET = 10;\nlet performanceTarget = null; // If performance exists and supports the subset of the User Timing API that we require.\n\nlet supportsUserTiming = typeof performance !== 'undefined' && // $FlowFixMe[method-unbinding]\ntypeof performance.mark === 'function' && // $FlowFixMe[method-unbinding]\ntypeof performance.clearMarks === 'function';\nlet supportsUserTimingV3 = false;\n\nif (supportsUserTiming) {\n  const CHECK_V3_MARK = '__v3';\n  const markOptions = {};\n  Object.defineProperty(markOptions, 'startTime', {\n    get: function () {\n      supportsUserTimingV3 = true;\n      return 0;\n    },\n    set: function () {}\n  });\n\n  try {\n    // $FlowFixMe: Flow expects the User Timing level 2 API.\n    performance.mark(CHECK_V3_MARK, markOptions);\n  } catch (error) {// Ignore\n  } finally {\n    performance.clearMarks(CHECK_V3_MARK);\n  }\n}\n\nif (supportsUserTimingV3) {\n  performanceTarget = performance;\n} // Some environments (e.g. React Native / Hermes) don't support the performance API yet.\n\n\nconst getCurrentTime = // $FlowFixMe[method-unbinding]\ntypeof performance === 'object' && typeof performance.now === 'function' ? () => performance.now() : () => Date.now(); // Mocking the Performance Object (and User Timing APIs) for testing is fragile.\n// This API allows tests to directly override the User Timing APIs.\n\nfunction setPerformanceMock_ONLY_FOR_TESTING(performanceMock) {\n  performanceTarget = performanceMock;\n  supportsUserTiming = performanceMock !== null;\n  supportsUserTimingV3 = performanceMock !== null;\n}\nfunction createProfilingHooks({\n  getDisplayNameForFiber,\n  getIsProfiling,\n  getLaneLabelMap,\n  workTagMap,\n  currentDispatcherRef,\n  reactVersion\n}) {\n  let currentBatchUID = 0;\n  let currentReactComponentMeasure = null;\n  let currentReactMeasuresStack = [];\n  let currentTimelineData = null;\n  let currentFiberStacks = new Map();\n  let isProfiling = false;\n  let nextRenderShouldStartNewBatch = false;\n\n  function getRelativeTime() {\n    const currentTime = getCurrentTime();\n\n    if (currentTimelineData) {\n      if (currentTimelineData.startTime === 0) {\n        currentTimelineData.startTime = currentTime - TIME_OFFSET;\n      }\n\n      return currentTime - currentTimelineData.startTime;\n    }\n\n    return 0;\n  }\n\n  function getInternalModuleRanges() {\n    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.getInternalModuleRanges === 'function') {\n      // Ask the DevTools hook for module ranges that may have been reported by the current renderer(s).\n      // Don't do this eagerly like the laneToLabelMap,\n      // because some modules might not yet have registered their boundaries when the renderer is injected.\n      const ranges = __REACT_DEVTOOLS_GLOBAL_HOOK__.getInternalModuleRanges(); // This check would not be required,\n      // except that it's possible for things to override __REACT_DEVTOOLS_GLOBAL_HOOK__.\n\n\n      if (Object(shared_isArray[\"a\" /* default */])(ranges)) {\n        return ranges;\n      }\n    }\n\n    return null;\n  }\n\n  function getTimelineData() {\n    return currentTimelineData;\n  }\n\n  function laneToLanesArray(lanes) {\n    const lanesArray = [];\n    let lane = 1;\n\n    for (let index = 0; index < src_constants[\"a\" /* REACT_TOTAL_NUM_LANES */]; index++) {\n      if (lane & lanes) {\n        lanesArray.push(lane);\n      }\n\n      lane *= 2;\n    }\n\n    return lanesArray;\n  }\n\n  const laneToLabelMap = typeof getLaneLabelMap === 'function' ? getLaneLabelMap() : null;\n\n  function markMetadata() {\n    markAndClear(`--react-version-${reactVersion}`);\n    markAndClear(`--profiler-version-${src_constants[\"b\" /* SCHEDULING_PROFILER_VERSION */]}`);\n    const ranges = getInternalModuleRanges();\n\n    if (ranges) {\n      for (let i = 0; i < ranges.length; i++) {\n        const range = ranges[i];\n\n        if (Object(shared_isArray[\"a\" /* default */])(range) && range.length === 2) {\n          const [startStackFrame, stopStackFrame] = ranges[i];\n          markAndClear(`--react-internal-module-start-${startStackFrame}`);\n          markAndClear(`--react-internal-module-stop-${stopStackFrame}`);\n        }\n      }\n    }\n\n    if (laneToLabelMap != null) {\n      const labels = Array.from(laneToLabelMap.values()).join(',');\n      markAndClear(`--react-lane-labels-${labels}`);\n    }\n  }\n\n  function markAndClear(markName) {\n    // This method won't be called unless these functions are defined, so we can skip the extra typeof check.\n    performanceTarget.mark(markName);\n    performanceTarget.clearMarks(markName);\n  }\n\n  function recordReactMeasureStarted(type, lanes) {\n    // Decide what depth thi work should be rendered at, based on what's on the top of the stack.\n    // It's okay to render over top of \"idle\" work but everything else should be on its own row.\n    let depth = 0;\n\n    if (currentReactMeasuresStack.length > 0) {\n      const top = currentReactMeasuresStack[currentReactMeasuresStack.length - 1];\n      depth = top.type === 'render-idle' ? top.depth : top.depth + 1;\n    }\n\n    const lanesArray = laneToLanesArray(lanes);\n    const reactMeasure = {\n      type,\n      batchUID: currentBatchUID,\n      depth,\n      lanes: lanesArray,\n      timestamp: getRelativeTime(),\n      duration: 0\n    };\n    currentReactMeasuresStack.push(reactMeasure);\n\n    if (currentTimelineData) {\n      const {\n        batchUIDToMeasuresMap,\n        laneToReactMeasureMap\n      } = currentTimelineData;\n      let reactMeasures = batchUIDToMeasuresMap.get(currentBatchUID);\n\n      if (reactMeasures != null) {\n        reactMeasures.push(reactMeasure);\n      } else {\n        batchUIDToMeasuresMap.set(currentBatchUID, [reactMeasure]);\n      }\n\n      lanesArray.forEach(lane => {\n        reactMeasures = laneToReactMeasureMap.get(lane);\n\n        if (reactMeasures) {\n          reactMeasures.push(reactMeasure);\n        }\n      });\n    }\n  }\n\n  function recordReactMeasureCompleted(type) {\n    const currentTime = getRelativeTime();\n\n    if (currentReactMeasuresStack.length === 0) {\n      console.error('Unexpected type \"%s\" completed at %sms while currentReactMeasuresStack is empty.', type, currentTime); // Ignore work \"completion\" user timing mark that doesn't complete anything\n\n      return;\n    }\n\n    const top = currentReactMeasuresStack.pop();\n\n    if (top.type !== type) {\n      console.error('Unexpected type \"%s\" completed at %sms before \"%s\" completed.', type, currentTime, top.type);\n    } // $FlowFixMe This property should not be writable outside of this function.\n\n\n    top.duration = currentTime - top.timestamp;\n\n    if (currentTimelineData) {\n      currentTimelineData.duration = getRelativeTime() + TIME_OFFSET;\n    }\n  }\n\n  function markCommitStarted(lanes) {\n    if (isProfiling) {\n      recordReactMeasureStarted('commit', lanes); // TODO (timeline) Re-think this approach to \"batching\"; I don't think it works for Suspense or pre-rendering.\n      // This issue applies to the User Timing data also.\n\n      nextRenderShouldStartNewBatch = true;\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear(`--commit-start-${lanes}`); // Some metadata only needs to be logged once per session,\n      // but if profiling information is being recorded via the Performance tab,\n      // DevTools has no way of knowing when the recording starts.\n      // Because of that, we log thie type of data periodically (once per commit).\n\n      markMetadata();\n    }\n  }\n\n  function markCommitStopped() {\n    if (isProfiling) {\n      recordReactMeasureCompleted('commit');\n      recordReactMeasureCompleted('render-idle');\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear('--commit-stop');\n    }\n  }\n\n  function markComponentRenderStarted(fiber) {\n    if (isProfiling || supportsUserTimingV3) {\n      const componentName = getDisplayNameForFiber(fiber) || 'Unknown';\n\n      if (isProfiling) {\n        // TODO (timeline) Record and cache component stack\n        if (isProfiling) {\n          currentReactComponentMeasure = {\n            componentName,\n            duration: 0,\n            timestamp: getRelativeTime(),\n            type: 'render',\n            warning: null\n          };\n        }\n      }\n\n      if (supportsUserTimingV3) {\n        markAndClear(`--component-render-start-${componentName}`);\n      }\n    }\n  }\n\n  function markComponentRenderStopped() {\n    if (isProfiling) {\n      if (currentReactComponentMeasure) {\n        if (currentTimelineData) {\n          currentTimelineData.componentMeasures.push(currentReactComponentMeasure);\n        } // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n\n        currentReactComponentMeasure.duration = // $FlowFixMe[incompatible-use] found when upgrading Flow\n        getRelativeTime() - currentReactComponentMeasure.timestamp;\n        currentReactComponentMeasure = null;\n      }\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear('--component-render-stop');\n    }\n  }\n\n  function markComponentLayoutEffectMountStarted(fiber) {\n    if (isProfiling || supportsUserTimingV3) {\n      const componentName = getDisplayNameForFiber(fiber) || 'Unknown';\n\n      if (isProfiling) {\n        // TODO (timeline) Record and cache component stack\n        if (isProfiling) {\n          currentReactComponentMeasure = {\n            componentName,\n            duration: 0,\n            timestamp: getRelativeTime(),\n            type: 'layout-effect-mount',\n            warning: null\n          };\n        }\n      }\n\n      if (supportsUserTimingV3) {\n        markAndClear(`--component-layout-effect-mount-start-${componentName}`);\n      }\n    }\n  }\n\n  function markComponentLayoutEffectMountStopped() {\n    if (isProfiling) {\n      if (currentReactComponentMeasure) {\n        if (currentTimelineData) {\n          currentTimelineData.componentMeasures.push(currentReactComponentMeasure);\n        } // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n\n        currentReactComponentMeasure.duration = // $FlowFixMe[incompatible-use] found when upgrading Flow\n        getRelativeTime() - currentReactComponentMeasure.timestamp;\n        currentReactComponentMeasure = null;\n      }\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear('--component-layout-effect-mount-stop');\n    }\n  }\n\n  function markComponentLayoutEffectUnmountStarted(fiber) {\n    if (isProfiling || supportsUserTimingV3) {\n      const componentName = getDisplayNameForFiber(fiber) || 'Unknown';\n\n      if (isProfiling) {\n        // TODO (timeline) Record and cache component stack\n        if (isProfiling) {\n          currentReactComponentMeasure = {\n            componentName,\n            duration: 0,\n            timestamp: getRelativeTime(),\n            type: 'layout-effect-unmount',\n            warning: null\n          };\n        }\n      }\n\n      if (supportsUserTimingV3) {\n        markAndClear(`--component-layout-effect-unmount-start-${componentName}`);\n      }\n    }\n  }\n\n  function markComponentLayoutEffectUnmountStopped() {\n    if (isProfiling) {\n      if (currentReactComponentMeasure) {\n        if (currentTimelineData) {\n          currentTimelineData.componentMeasures.push(currentReactComponentMeasure);\n        } // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n\n        currentReactComponentMeasure.duration = // $FlowFixMe[incompatible-use] found when upgrading Flow\n        getRelativeTime() - currentReactComponentMeasure.timestamp;\n        currentReactComponentMeasure = null;\n      }\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear('--component-layout-effect-unmount-stop');\n    }\n  }\n\n  function markComponentPassiveEffectMountStarted(fiber) {\n    if (isProfiling || supportsUserTimingV3) {\n      const componentName = getDisplayNameForFiber(fiber) || 'Unknown';\n\n      if (isProfiling) {\n        // TODO (timeline) Record and cache component stack\n        if (isProfiling) {\n          currentReactComponentMeasure = {\n            componentName,\n            duration: 0,\n            timestamp: getRelativeTime(),\n            type: 'passive-effect-mount',\n            warning: null\n          };\n        }\n      }\n\n      if (supportsUserTimingV3) {\n        markAndClear(`--component-passive-effect-mount-start-${componentName}`);\n      }\n    }\n  }\n\n  function markComponentPassiveEffectMountStopped() {\n    if (isProfiling) {\n      if (currentReactComponentMeasure) {\n        if (currentTimelineData) {\n          currentTimelineData.componentMeasures.push(currentReactComponentMeasure);\n        } // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n\n        currentReactComponentMeasure.duration = // $FlowFixMe[incompatible-use] found when upgrading Flow\n        getRelativeTime() - currentReactComponentMeasure.timestamp;\n        currentReactComponentMeasure = null;\n      }\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear('--component-passive-effect-mount-stop');\n    }\n  }\n\n  function markComponentPassiveEffectUnmountStarted(fiber) {\n    if (isProfiling || supportsUserTimingV3) {\n      const componentName = getDisplayNameForFiber(fiber) || 'Unknown';\n\n      if (isProfiling) {\n        // TODO (timeline) Record and cache component stack\n        if (isProfiling) {\n          currentReactComponentMeasure = {\n            componentName,\n            duration: 0,\n            timestamp: getRelativeTime(),\n            type: 'passive-effect-unmount',\n            warning: null\n          };\n        }\n      }\n\n      if (supportsUserTimingV3) {\n        markAndClear(`--component-passive-effect-unmount-start-${componentName}`);\n      }\n    }\n  }\n\n  function markComponentPassiveEffectUnmountStopped() {\n    if (isProfiling) {\n      if (currentReactComponentMeasure) {\n        if (currentTimelineData) {\n          currentTimelineData.componentMeasures.push(currentReactComponentMeasure);\n        } // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n\n        currentReactComponentMeasure.duration = // $FlowFixMe[incompatible-use] found when upgrading Flow\n        getRelativeTime() - currentReactComponentMeasure.timestamp;\n        currentReactComponentMeasure = null;\n      }\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear('--component-passive-effect-unmount-stop');\n    }\n  }\n\n  function markComponentErrored(fiber, thrownValue, lanes) {\n    if (isProfiling || supportsUserTimingV3) {\n      const componentName = getDisplayNameForFiber(fiber) || 'Unknown';\n      const phase = fiber.alternate === null ? 'mount' : 'update';\n      let message = '';\n\n      if (thrownValue !== null && typeof thrownValue === 'object' && typeof thrownValue.message === 'string') {\n        message = thrownValue.message;\n      } else if (typeof thrownValue === 'string') {\n        message = thrownValue;\n      }\n\n      if (isProfiling) {\n        // TODO (timeline) Record and cache component stack\n        if (currentTimelineData) {\n          currentTimelineData.thrownErrors.push({\n            componentName,\n            message,\n            phase,\n            timestamp: getRelativeTime(),\n            type: 'thrown-error'\n          });\n        }\n      }\n\n      if (supportsUserTimingV3) {\n        markAndClear(`--error-${componentName}-${phase}-${message}`);\n      }\n    }\n  }\n\n  const PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map; // $FlowFixMe: Flow cannot handle polymorphic WeakMaps\n\n  const wakeableIDs = new PossiblyWeakMap();\n  let wakeableID = 0;\n\n  function getWakeableID(wakeable) {\n    if (!wakeableIDs.has(wakeable)) {\n      wakeableIDs.set(wakeable, wakeableID++);\n    }\n\n    return wakeableIDs.get(wakeable);\n  }\n\n  function markComponentSuspended(fiber, wakeable, lanes) {\n    if (isProfiling || supportsUserTimingV3) {\n      const eventType = wakeableIDs.has(wakeable) ? 'resuspend' : 'suspend';\n      const id = getWakeableID(wakeable);\n      const componentName = getDisplayNameForFiber(fiber) || 'Unknown';\n      const phase = fiber.alternate === null ? 'mount' : 'update'; // Following the non-standard fn.displayName convention,\n      // frameworks like Relay may also annotate Promises with a displayName,\n      // describing what operation/data the thrown Promise is related to.\n      // When this is available we should pass it along to the Timeline.\n\n      const displayName = wakeable.displayName || '';\n      let suspenseEvent = null;\n\n      if (isProfiling) {\n        // TODO (timeline) Record and cache component stack\n        suspenseEvent = {\n          componentName,\n          depth: 0,\n          duration: 0,\n          id: `${id}`,\n          phase,\n          promiseName: displayName,\n          resolution: 'unresolved',\n          timestamp: getRelativeTime(),\n          type: 'suspense',\n          warning: null\n        };\n\n        if (currentTimelineData) {\n          currentTimelineData.suspenseEvents.push(suspenseEvent);\n        }\n      }\n\n      if (supportsUserTimingV3) {\n        markAndClear(`--suspense-${eventType}-${id}-${componentName}-${phase}-${lanes}-${displayName}`);\n      }\n\n      wakeable.then(() => {\n        if (suspenseEvent) {\n          suspenseEvent.duration = getRelativeTime() - suspenseEvent.timestamp;\n          suspenseEvent.resolution = 'resolved';\n        }\n\n        if (supportsUserTimingV3) {\n          markAndClear(`--suspense-resolved-${id}-${componentName}`);\n        }\n      }, () => {\n        if (suspenseEvent) {\n          suspenseEvent.duration = getRelativeTime() - suspenseEvent.timestamp;\n          suspenseEvent.resolution = 'rejected';\n        }\n\n        if (supportsUserTimingV3) {\n          markAndClear(`--suspense-rejected-${id}-${componentName}`);\n        }\n      });\n    }\n  }\n\n  function markLayoutEffectsStarted(lanes) {\n    if (isProfiling) {\n      recordReactMeasureStarted('layout-effects', lanes);\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear(`--layout-effects-start-${lanes}`);\n    }\n  }\n\n  function markLayoutEffectsStopped() {\n    if (isProfiling) {\n      recordReactMeasureCompleted('layout-effects');\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear('--layout-effects-stop');\n    }\n  }\n\n  function markPassiveEffectsStarted(lanes) {\n    if (isProfiling) {\n      recordReactMeasureStarted('passive-effects', lanes);\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear(`--passive-effects-start-${lanes}`);\n    }\n  }\n\n  function markPassiveEffectsStopped() {\n    if (isProfiling) {\n      recordReactMeasureCompleted('passive-effects');\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear('--passive-effects-stop');\n    }\n  }\n\n  function markRenderStarted(lanes) {\n    if (isProfiling) {\n      if (nextRenderShouldStartNewBatch) {\n        nextRenderShouldStartNewBatch = false;\n        currentBatchUID++;\n      } // If this is a new batch of work, wrap an \"idle\" measure around it.\n      // Log it before the \"render\" measure to preserve the stack ordering.\n\n\n      if (currentReactMeasuresStack.length === 0 || currentReactMeasuresStack[currentReactMeasuresStack.length - 1].type !== 'render-idle') {\n        recordReactMeasureStarted('render-idle', lanes);\n      }\n\n      recordReactMeasureStarted('render', lanes);\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear(`--render-start-${lanes}`);\n    }\n  }\n\n  function markRenderYielded() {\n    if (isProfiling) {\n      recordReactMeasureCompleted('render');\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear('--render-yield');\n    }\n  }\n\n  function markRenderStopped() {\n    if (isProfiling) {\n      recordReactMeasureCompleted('render');\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear('--render-stop');\n    }\n  }\n\n  function markRenderScheduled(lane) {\n    if (isProfiling) {\n      if (currentTimelineData) {\n        currentTimelineData.schedulingEvents.push({\n          lanes: laneToLanesArray(lane),\n          timestamp: getRelativeTime(),\n          type: 'schedule-render',\n          warning: null\n        });\n      }\n    }\n\n    if (supportsUserTimingV3) {\n      markAndClear(`--schedule-render-${lane}`);\n    }\n  }\n\n  function markForceUpdateScheduled(fiber, lane) {\n    if (isProfiling || supportsUserTimingV3) {\n      const componentName = getDisplayNameForFiber(fiber) || 'Unknown';\n\n      if (isProfiling) {\n        // TODO (timeline) Record and cache component stack\n        if (currentTimelineData) {\n          currentTimelineData.schedulingEvents.push({\n            componentName,\n            lanes: laneToLanesArray(lane),\n            timestamp: getRelativeTime(),\n            type: 'schedule-force-update',\n            warning: null\n          });\n        }\n      }\n\n      if (supportsUserTimingV3) {\n        markAndClear(`--schedule-forced-update-${lane}-${componentName}`);\n      }\n    }\n  }\n\n  function getParentFibers(fiber) {\n    const parents = [];\n    let parent = fiber;\n\n    while (parent !== null) {\n      parents.push(parent);\n      parent = parent.return;\n    }\n\n    return parents;\n  }\n\n  function markStateUpdateScheduled(fiber, lane) {\n    if (isProfiling || supportsUserTimingV3) {\n      const componentName = getDisplayNameForFiber(fiber) || 'Unknown';\n\n      if (isProfiling) {\n        // TODO (timeline) Record and cache component stack\n        if (currentTimelineData) {\n          const event = {\n            componentName,\n            // Store the parent fibers so we can post process\n            // them after we finish profiling\n            lanes: laneToLanesArray(lane),\n            timestamp: getRelativeTime(),\n            type: 'schedule-state-update',\n            warning: null\n          };\n          currentFiberStacks.set(event, getParentFibers(fiber)); // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n          currentTimelineData.schedulingEvents.push(event);\n        }\n      }\n\n      if (supportsUserTimingV3) {\n        markAndClear(`--schedule-state-update-${lane}-${componentName}`);\n      }\n    }\n  }\n\n  function toggleProfilingStatus(value) {\n    if (isProfiling !== value) {\n      isProfiling = value;\n\n      if (isProfiling) {\n        const internalModuleSourceToRanges = new Map();\n\n        if (supportsUserTimingV3) {\n          const ranges = getInternalModuleRanges();\n\n          if (ranges) {\n            for (let i = 0; i < ranges.length; i++) {\n              const range = ranges[i];\n\n              if (Object(shared_isArray[\"a\" /* default */])(range) && range.length === 2) {\n                const [startStackFrame, stopStackFrame] = ranges[i];\n                markAndClear(`--react-internal-module-start-${startStackFrame}`);\n                markAndClear(`--react-internal-module-stop-${stopStackFrame}`);\n              }\n            }\n          }\n        }\n\n        const laneToReactMeasureMap = new Map();\n        let lane = 1;\n\n        for (let index = 0; index < src_constants[\"a\" /* REACT_TOTAL_NUM_LANES */]; index++) {\n          laneToReactMeasureMap.set(lane, []);\n          lane *= 2;\n        }\n\n        currentBatchUID = 0;\n        currentReactComponentMeasure = null;\n        currentReactMeasuresStack = [];\n        currentFiberStacks = new Map();\n        currentTimelineData = {\n          // Session wide metadata; only collected once.\n          internalModuleSourceToRanges,\n          laneToLabelMap: laneToLabelMap || new Map(),\n          reactVersion,\n          // Data logged by React during profiling session.\n          componentMeasures: [],\n          schedulingEvents: [],\n          suspenseEvents: [],\n          thrownErrors: [],\n          // Data inferred based on what React logs.\n          batchUIDToMeasuresMap: new Map(),\n          duration: 0,\n          laneToReactMeasureMap,\n          startTime: 0,\n          // Data only available in Chrome profiles.\n          flamechart: [],\n          nativeEvents: [],\n          networkMeasures: [],\n          otherUserTimingMarks: [],\n          snapshots: [],\n          snapshotHeight: 0\n        };\n        nextRenderShouldStartNewBatch = true;\n      } else {\n        // Postprocess Profile data\n        if (currentTimelineData !== null) {\n          currentTimelineData.schedulingEvents.forEach(event => {\n            if (event.type === 'schedule-state-update') {\n              // TODO(luna): We can optimize this by creating a map of\n              // fiber to component stack instead of generating the stack\n              // for every fiber every time\n              const fiberStack = currentFiberStacks.get(event);\n\n              if (fiberStack && currentDispatcherRef != null) {\n                event.componentStack = fiberStack.reduce((trace, fiber) => {\n                  return trace + Object(DevToolsFiberComponentStack[\"a\" /* describeFiber */])(workTagMap, fiber, currentDispatcherRef);\n                }, '');\n              }\n            }\n          });\n        } // Clear the current fiber stacks so we don't hold onto the fibers\n        // in memory after profiling finishes\n\n\n        currentFiberStacks.clear();\n      }\n    }\n  }\n\n  return {\n    getTimelineData,\n    profilingHooks: {\n      markCommitStarted,\n      markCommitStopped,\n      markComponentRenderStarted,\n      markComponentRenderStopped,\n      markComponentPassiveEffectMountStarted,\n      markComponentPassiveEffectMountStopped,\n      markComponentPassiveEffectUnmountStarted,\n      markComponentPassiveEffectUnmountStopped,\n      markComponentLayoutEffectMountStarted,\n      markComponentLayoutEffectMountStopped,\n      markComponentLayoutEffectUnmountStarted,\n      markComponentLayoutEffectUnmountStopped,\n      markComponentErrored,\n      markComponentSuspended,\n      markLayoutEffectsStarted,\n      markLayoutEffectsStopped,\n      markPassiveEffectsStarted,\n      markPassiveEffectsStopped,\n      markRenderStarted,\n      markRenderYielded,\n      markRenderStopped,\n      markRenderScheduled,\n      markForceUpdateScheduled,\n      markStateUpdateScheduled\n    },\n    toggleProfilingStatus\n  };\n}\n// CONCATENATED MODULE: ../react-devtools-shared/src/backend/renderer.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction getFiberFlags(fiber) {\n  // The name of this field changed from \"effectTag\" to \"flags\"\n  return fiber.flags !== undefined ? fiber.flags : fiber.effectTag;\n} // Some environments (e.g. React Native / Hermes) don't support the performance API yet.\n\n\nconst renderer_getCurrentTime = // $FlowFixMe[method-unbinding]\ntypeof performance === 'object' && typeof performance.now === 'function' ? () => performance.now() : () => Date.now();\nfunction getInternalReactConstants(version) {\n  // **********************************************************\n  // The section below is copied from files in React repo.\n  // Keep it in sync, and add version guards if it changes.\n  //\n  // Technically these priority levels are invalid for versions before 16.9,\n  // but 16.9 is the first version to report priority level to DevTools,\n  // so we can avoid checking for earlier versions and support pre-16.9 canary releases in the process.\n  let ReactPriorityLevels = {\n    ImmediatePriority: 99,\n    UserBlockingPriority: 98,\n    NormalPriority: 97,\n    LowPriority: 96,\n    IdlePriority: 95,\n    NoPriority: 90\n  };\n\n  if (Object(backend_utils[\"i\" /* gt */])(version, '17.0.2')) {\n    ReactPriorityLevels = {\n      ImmediatePriority: 1,\n      UserBlockingPriority: 2,\n      NormalPriority: 3,\n      LowPriority: 4,\n      IdlePriority: 5,\n      NoPriority: 0\n    };\n  }\n\n  let StrictModeBits = 0;\n\n  if (Object(backend_utils[\"j\" /* gte */])(version, '18.0.0-alpha')) {\n    // 18+\n    StrictModeBits = 0b011000;\n  } else if (Object(backend_utils[\"j\" /* gte */])(version, '16.9.0')) {\n    // 16.9 - 17\n    StrictModeBits = 0b1;\n  } else if (Object(backend_utils[\"j\" /* gte */])(version, '16.3.0')) {\n    // 16.3 - 16.8\n    StrictModeBits = 0b10;\n  }\n\n  let ReactTypeOfWork = null; // **********************************************************\n  // The section below is copied from files in React repo.\n  // Keep it in sync, and add version guards if it changes.\n  //\n  // TODO Update the gt() check below to be gte() whichever the next version number is.\n  // Currently the version in Git is 17.0.2 (but that version has not been/may not end up being released).\n\n  if (Object(backend_utils[\"i\" /* gt */])(version, '17.0.1')) {\n    ReactTypeOfWork = {\n      CacheComponent: 24,\n      // Experimental\n      ClassComponent: 1,\n      ContextConsumer: 9,\n      ContextProvider: 10,\n      CoroutineComponent: -1,\n      // Removed\n      CoroutineHandlerPhase: -1,\n      // Removed\n      DehydratedSuspenseComponent: 18,\n      // Behind a flag\n      ForwardRef: 11,\n      Fragment: 7,\n      FunctionComponent: 0,\n      HostComponent: 5,\n      HostPortal: 4,\n      HostRoot: 3,\n      HostResource: 26,\n      // In reality, 18.2+. But doesn't hurt to include it here\n      HostSingleton: 27,\n      // Same as above\n      HostText: 6,\n      IncompleteClassComponent: 17,\n      IndeterminateComponent: 2,\n      LazyComponent: 16,\n      LegacyHiddenComponent: 23,\n      MemoComponent: 14,\n      Mode: 8,\n      OffscreenComponent: 22,\n      // Experimental\n      Profiler: 12,\n      ScopeComponent: 21,\n      // Experimental\n      SimpleMemoComponent: 15,\n      SuspenseComponent: 13,\n      SuspenseListComponent: 19,\n      // Experimental\n      TracingMarkerComponent: 25,\n      // Experimental - This is technically in 18 but we don't\n      // want to fork again so we're adding it here instead\n      YieldComponent: -1 // Removed\n\n    };\n  } else if (Object(backend_utils[\"j\" /* gte */])(version, '17.0.0-alpha')) {\n    ReactTypeOfWork = {\n      CacheComponent: -1,\n      // Doesn't exist yet\n      ClassComponent: 1,\n      ContextConsumer: 9,\n      ContextProvider: 10,\n      CoroutineComponent: -1,\n      // Removed\n      CoroutineHandlerPhase: -1,\n      // Removed\n      DehydratedSuspenseComponent: 18,\n      // Behind a flag\n      ForwardRef: 11,\n      Fragment: 7,\n      FunctionComponent: 0,\n      HostComponent: 5,\n      HostPortal: 4,\n      HostRoot: 3,\n      HostResource: -1,\n      // Doesn't exist yet\n      HostSingleton: -1,\n      // Doesn't exist yet\n      HostText: 6,\n      IncompleteClassComponent: 17,\n      IndeterminateComponent: 2,\n      LazyComponent: 16,\n      LegacyHiddenComponent: 24,\n      MemoComponent: 14,\n      Mode: 8,\n      OffscreenComponent: 23,\n      // Experimental\n      Profiler: 12,\n      ScopeComponent: 21,\n      // Experimental\n      SimpleMemoComponent: 15,\n      SuspenseComponent: 13,\n      SuspenseListComponent: 19,\n      // Experimental\n      TracingMarkerComponent: -1,\n      // Doesn't exist yet\n      YieldComponent: -1 // Removed\n\n    };\n  } else if (Object(backend_utils[\"j\" /* gte */])(version, '16.6.0-beta.0')) {\n    ReactTypeOfWork = {\n      CacheComponent: -1,\n      // Doesn't exist yet\n      ClassComponent: 1,\n      ContextConsumer: 9,\n      ContextProvider: 10,\n      CoroutineComponent: -1,\n      // Removed\n      CoroutineHandlerPhase: -1,\n      // Removed\n      DehydratedSuspenseComponent: 18,\n      // Behind a flag\n      ForwardRef: 11,\n      Fragment: 7,\n      FunctionComponent: 0,\n      HostComponent: 5,\n      HostPortal: 4,\n      HostRoot: 3,\n      HostResource: -1,\n      // Doesn't exist yet\n      HostSingleton: -1,\n      // Doesn't exist yet\n      HostText: 6,\n      IncompleteClassComponent: 17,\n      IndeterminateComponent: 2,\n      LazyComponent: 16,\n      LegacyHiddenComponent: -1,\n      MemoComponent: 14,\n      Mode: 8,\n      OffscreenComponent: -1,\n      // Experimental\n      Profiler: 12,\n      ScopeComponent: -1,\n      // Experimental\n      SimpleMemoComponent: 15,\n      SuspenseComponent: 13,\n      SuspenseListComponent: 19,\n      // Experimental\n      TracingMarkerComponent: -1,\n      // Doesn't exist yet\n      YieldComponent: -1 // Removed\n\n    };\n  } else if (Object(backend_utils[\"j\" /* gte */])(version, '16.4.3-alpha')) {\n    ReactTypeOfWork = {\n      CacheComponent: -1,\n      // Doesn't exist yet\n      ClassComponent: 2,\n      ContextConsumer: 11,\n      ContextProvider: 12,\n      CoroutineComponent: -1,\n      // Removed\n      CoroutineHandlerPhase: -1,\n      // Removed\n      DehydratedSuspenseComponent: -1,\n      // Doesn't exist yet\n      ForwardRef: 13,\n      Fragment: 9,\n      FunctionComponent: 0,\n      HostComponent: 7,\n      HostPortal: 6,\n      HostRoot: 5,\n      HostResource: -1,\n      // Doesn't exist yet\n      HostSingleton: -1,\n      // Doesn't exist yet\n      HostText: 8,\n      IncompleteClassComponent: -1,\n      // Doesn't exist yet\n      IndeterminateComponent: 4,\n      LazyComponent: -1,\n      // Doesn't exist yet\n      LegacyHiddenComponent: -1,\n      MemoComponent: -1,\n      // Doesn't exist yet\n      Mode: 10,\n      OffscreenComponent: -1,\n      // Experimental\n      Profiler: 15,\n      ScopeComponent: -1,\n      // Experimental\n      SimpleMemoComponent: -1,\n      // Doesn't exist yet\n      SuspenseComponent: 16,\n      SuspenseListComponent: -1,\n      // Doesn't exist yet\n      TracingMarkerComponent: -1,\n      // Doesn't exist yet\n      YieldComponent: -1 // Removed\n\n    };\n  } else {\n    ReactTypeOfWork = {\n      CacheComponent: -1,\n      // Doesn't exist yet\n      ClassComponent: 2,\n      ContextConsumer: 12,\n      ContextProvider: 13,\n      CoroutineComponent: 7,\n      CoroutineHandlerPhase: 8,\n      DehydratedSuspenseComponent: -1,\n      // Doesn't exist yet\n      ForwardRef: 14,\n      Fragment: 10,\n      FunctionComponent: 1,\n      HostComponent: 5,\n      HostPortal: 4,\n      HostRoot: 3,\n      HostResource: -1,\n      // Doesn't exist yet\n      HostSingleton: -1,\n      // Doesn't exist yet\n      HostText: 6,\n      IncompleteClassComponent: -1,\n      // Doesn't exist yet\n      IndeterminateComponent: 0,\n      LazyComponent: -1,\n      // Doesn't exist yet\n      LegacyHiddenComponent: -1,\n      MemoComponent: -1,\n      // Doesn't exist yet\n      Mode: 11,\n      OffscreenComponent: -1,\n      // Experimental\n      Profiler: 15,\n      ScopeComponent: -1,\n      // Experimental\n      SimpleMemoComponent: -1,\n      // Doesn't exist yet\n      SuspenseComponent: 16,\n      SuspenseListComponent: -1,\n      // Doesn't exist yet\n      TracingMarkerComponent: -1,\n      // Doesn't exist yet\n      YieldComponent: 9\n    };\n  } // **********************************************************\n  // End of copied code.\n  // **********************************************************\n\n\n  function getTypeSymbol(type) {\n    const symbolOrNumber = typeof type === 'object' && type !== null ? type.$$typeof : type;\n    return typeof symbolOrNumber === 'symbol' ? // $FlowFixMe `toString()` doesn't match the type signature?\n    symbolOrNumber.toString() : symbolOrNumber;\n  }\n\n  const {\n    CacheComponent,\n    ClassComponent,\n    IncompleteClassComponent,\n    FunctionComponent,\n    IndeterminateComponent,\n    ForwardRef,\n    HostRoot,\n    HostResource,\n    HostSingleton,\n    HostComponent,\n    HostPortal,\n    HostText,\n    Fragment,\n    LazyComponent,\n    LegacyHiddenComponent,\n    MemoComponent,\n    OffscreenComponent,\n    Profiler,\n    ScopeComponent,\n    SimpleMemoComponent,\n    SuspenseComponent,\n    SuspenseListComponent,\n    TracingMarkerComponent\n  } = ReactTypeOfWork;\n\n  function resolveFiberType(type) {\n    const typeSymbol = getTypeSymbol(type);\n\n    switch (typeSymbol) {\n      case ReactSymbols[\"j\" /* MEMO_NUMBER */]:\n      case ReactSymbols[\"k\" /* MEMO_SYMBOL_STRING */]:\n        // recursively resolving memo type in case of memo(forwardRef(Component))\n        return resolveFiberType(type.type);\n\n      case ReactSymbols[\"f\" /* FORWARD_REF_NUMBER */]:\n      case ReactSymbols[\"g\" /* FORWARD_REF_SYMBOL_STRING */]:\n        return type.render;\n\n      default:\n        return type;\n    }\n  } // NOTICE Keep in sync with shouldFilterFiber() and other get*ForFiber methods\n\n\n  function getDisplayNameForFiber(fiber) {\n    const {\n      elementType,\n      type,\n      tag\n    } = fiber;\n    let resolvedType = type;\n\n    if (typeof type === 'object' && type !== null) {\n      resolvedType = resolveFiberType(type);\n    }\n\n    let resolvedContext = null;\n\n    switch (tag) {\n      case CacheComponent:\n        return 'Cache';\n\n      case ClassComponent:\n      case IncompleteClassComponent:\n        return Object(utils[\"k\" /* getDisplayName */])(resolvedType);\n\n      case FunctionComponent:\n      case IndeterminateComponent:\n        return Object(utils[\"k\" /* getDisplayName */])(resolvedType);\n\n      case ForwardRef:\n        return Object(utils[\"s\" /* getWrappedDisplayName */])(elementType, resolvedType, 'ForwardRef', 'Anonymous');\n\n      case HostRoot:\n        const fiberRoot = fiber.stateNode;\n\n        if (fiberRoot != null && fiberRoot._debugRootType !== null) {\n          return fiberRoot._debugRootType;\n        }\n\n        return null;\n\n      case HostComponent:\n      case HostSingleton:\n      case HostResource:\n        return type;\n\n      case HostPortal:\n      case HostText:\n        return null;\n\n      case Fragment:\n        return 'Fragment';\n\n      case LazyComponent:\n        // This display name will not be user visible.\n        // Once a Lazy component loads its inner component, React replaces the tag and type.\n        // This display name will only show up in console logs when DevTools DEBUG mode is on.\n        return 'Lazy';\n\n      case MemoComponent:\n      case SimpleMemoComponent:\n        // Display name in React does not use `Memo` as a wrapper but fallback name.\n        return Object(utils[\"s\" /* getWrappedDisplayName */])(elementType, resolvedType, 'Memo', 'Anonymous');\n\n      case SuspenseComponent:\n        return 'Suspense';\n\n      case LegacyHiddenComponent:\n        return 'LegacyHidden';\n\n      case OffscreenComponent:\n        return 'Offscreen';\n\n      case ScopeComponent:\n        return 'Scope';\n\n      case SuspenseListComponent:\n        return 'SuspenseList';\n\n      case Profiler:\n        return 'Profiler';\n\n      case TracingMarkerComponent:\n        return 'TracingMarker';\n\n      default:\n        const typeSymbol = getTypeSymbol(type);\n\n        switch (typeSymbol) {\n          case ReactSymbols[\"a\" /* CONCURRENT_MODE_NUMBER */]:\n          case ReactSymbols[\"b\" /* CONCURRENT_MODE_SYMBOL_STRING */]:\n          case ReactSymbols[\"e\" /* DEPRECATED_ASYNC_MODE_SYMBOL_STRING */]:\n            return null;\n\n          case ReactSymbols[\"n\" /* PROVIDER_NUMBER */]:\n          case ReactSymbols[\"o\" /* PROVIDER_SYMBOL_STRING */]:\n            // 16.3.0 exposed the context object as \"context\"\n            // PR #12501 changed it to \"_context\" for 16.3.1+\n            // NOTE Keep in sync with inspectElementRaw()\n            resolvedContext = fiber.type._context || fiber.type.context;\n            return `${resolvedContext.displayName || 'Context'}.Provider`;\n\n          case ReactSymbols[\"c\" /* CONTEXT_NUMBER */]:\n          case ReactSymbols[\"d\" /* CONTEXT_SYMBOL_STRING */]:\n          case ReactSymbols[\"r\" /* SERVER_CONTEXT_SYMBOL_STRING */]:\n            // 16.3-16.5 read from \"type\" because the Consumer is the actual context object.\n            // 16.6+ should read from \"type._context\" because Consumer can be different (in DEV).\n            // NOTE Keep in sync with inspectElementRaw()\n            resolvedContext = fiber.type._context || fiber.type; // NOTE: TraceUpdatesBackendManager depends on the name ending in '.Consumer'\n            // If you change the name, figure out a more resilient way to detect it.\n\n            return `${resolvedContext.displayName || 'Context'}.Consumer`;\n\n          case ReactSymbols[\"s\" /* STRICT_MODE_NUMBER */]:\n          case ReactSymbols[\"t\" /* STRICT_MODE_SYMBOL_STRING */]:\n            return null;\n\n          case ReactSymbols[\"l\" /* PROFILER_NUMBER */]:\n          case ReactSymbols[\"m\" /* PROFILER_SYMBOL_STRING */]:\n            return `Profiler(${fiber.memoizedProps.id})`;\n\n          case ReactSymbols[\"p\" /* SCOPE_NUMBER */]:\n          case ReactSymbols[\"q\" /* SCOPE_SYMBOL_STRING */]:\n            return 'Scope';\n\n          default:\n            // Unknown element type.\n            // This may mean a new element type that has not yet been added to DevTools.\n            return null;\n        }\n\n    }\n  }\n\n  return {\n    getDisplayNameForFiber,\n    getTypeSymbol,\n    ReactPriorityLevels,\n    ReactTypeOfWork,\n    StrictModeBits\n  };\n} // Map of one or more Fibers in a pair to their unique id number.\n// We track both Fibers to support Fast Refresh,\n// which may forcefully replace one of the pair as part of hot reloading.\n// In that case it's still important to be able to locate the previous ID during subsequent renders.\n\nconst fiberToIDMap = new Map(); // Map of id to one (arbitrary) Fiber in a pair.\n// This Map is used to e.g. get the display name for a Fiber or schedule an update,\n// operations that should be the same whether the current and work-in-progress Fiber is used.\n\nconst idToArbitraryFiberMap = new Map();\nfunction attach(hook, rendererID, renderer, global) {\n  // Newer versions of the reconciler package also specific reconciler version.\n  // If that version number is present, use it.\n  // Third party renderer versions may not match the reconciler version,\n  // and the latter is what's important in terms of tags and symbols.\n  const version = renderer.reconcilerVersion || renderer.version;\n  const {\n    getDisplayNameForFiber,\n    getTypeSymbol,\n    ReactPriorityLevels,\n    ReactTypeOfWork,\n    StrictModeBits\n  } = getInternalReactConstants(version);\n  const {\n    CacheComponent,\n    ClassComponent,\n    ContextConsumer,\n    DehydratedSuspenseComponent,\n    ForwardRef,\n    Fragment,\n    FunctionComponent,\n    HostRoot,\n    HostResource,\n    HostSingleton,\n    HostPortal,\n    HostComponent,\n    HostText,\n    IncompleteClassComponent,\n    IndeterminateComponent,\n    LegacyHiddenComponent,\n    MemoComponent,\n    OffscreenComponent,\n    SimpleMemoComponent,\n    SuspenseComponent,\n    SuspenseListComponent,\n    TracingMarkerComponent\n  } = ReactTypeOfWork;\n  const {\n    ImmediatePriority,\n    UserBlockingPriority,\n    NormalPriority,\n    LowPriority,\n    IdlePriority,\n    NoPriority\n  } = ReactPriorityLevels;\n  const {\n    getLaneLabelMap,\n    injectProfilingHooks,\n    overrideHookState,\n    overrideHookStateDeletePath,\n    overrideHookStateRenamePath,\n    overrideProps,\n    overridePropsDeletePath,\n    overridePropsRenamePath,\n    scheduleRefresh,\n    setErrorHandler,\n    setSuspenseHandler,\n    scheduleUpdate\n  } = renderer;\n  const supportsTogglingError = typeof setErrorHandler === 'function' && typeof scheduleUpdate === 'function';\n  const supportsTogglingSuspense = typeof setSuspenseHandler === 'function' && typeof scheduleUpdate === 'function';\n\n  if (typeof scheduleRefresh === 'function') {\n    // When Fast Refresh updates a component, the frontend may need to purge cached information.\n    // For example, ASTs cached for the component (for named hooks) may no longer be valid.\n    // Send a signal to the frontend to purge this cached information.\n    // The \"fastRefreshScheduled\" dispatched is global (not Fiber or even Renderer specific).\n    // This is less effecient since it means the front-end will need to purge the entire cache,\n    // but this is probably an okay trade off in order to reduce coupling between the DevTools and Fast Refresh.\n    renderer.scheduleRefresh = (...args) => {\n      try {\n        hook.emit('fastRefreshScheduled');\n      } finally {\n        return scheduleRefresh(...args);\n      }\n    };\n  }\n\n  let getTimelineData = null;\n  let toggleProfilingStatus = null;\n\n  if (typeof injectProfilingHooks === 'function') {\n    const response = createProfilingHooks({\n      getDisplayNameForFiber,\n      getIsProfiling: () => isProfiling,\n      getLaneLabelMap,\n      currentDispatcherRef: renderer.currentDispatcherRef,\n      workTagMap: ReactTypeOfWork,\n      reactVersion: version\n    }); // Pass the Profiling hooks to the reconciler for it to call during render.\n\n    injectProfilingHooks(response.profilingHooks); // Hang onto this toggle so we can notify the external methods of profiling status changes.\n\n    getTimelineData = response.getTimelineData;\n    toggleProfilingStatus = response.toggleProfilingStatus;\n  } // Tracks Fibers with recently changed number of error/warning messages.\n  // These collections store the Fiber rather than the ID,\n  // in order to avoid generating an ID for Fibers that never get mounted\n  // (due to e.g. Suspense or error boundaries).\n  // onErrorOrWarning() adds Fibers and recordPendingErrorsAndWarnings() later clears them.\n\n\n  const fibersWithChangedErrorOrWarningCounts = new Set();\n  const pendingFiberToErrorsMap = new Map();\n  const pendingFiberToWarningsMap = new Map(); // Mapping of fiber IDs to error/warning messages and counts.\n\n  const fiberIDToErrorsMap = new Map();\n  const fiberIDToWarningsMap = new Map();\n\n  function clearErrorsAndWarnings() {\n    // eslint-disable-next-line no-for-of-loops/no-for-of-loops\n    for (const id of fiberIDToErrorsMap.keys()) {\n      const fiber = idToArbitraryFiberMap.get(id);\n\n      if (fiber != null) {\n        fibersWithChangedErrorOrWarningCounts.add(fiber);\n        updateMostRecentlyInspectedElementIfNecessary(id);\n      }\n    } // eslint-disable-next-line no-for-of-loops/no-for-of-loops\n\n\n    for (const id of fiberIDToWarningsMap.keys()) {\n      const fiber = idToArbitraryFiberMap.get(id);\n\n      if (fiber != null) {\n        fibersWithChangedErrorOrWarningCounts.add(fiber);\n        updateMostRecentlyInspectedElementIfNecessary(id);\n      }\n    }\n\n    fiberIDToErrorsMap.clear();\n    fiberIDToWarningsMap.clear();\n    flushPendingEvents();\n  }\n\n  function clearMessageCountHelper(fiberID, pendingFiberToMessageCountMap, fiberIDToMessageCountMap) {\n    const fiber = idToArbitraryFiberMap.get(fiberID);\n\n    if (fiber != null) {\n      // Throw out any pending changes.\n      pendingFiberToErrorsMap.delete(fiber);\n\n      if (fiberIDToMessageCountMap.has(fiberID)) {\n        fiberIDToMessageCountMap.delete(fiberID); // If previous flushed counts have changed, schedule an update too.\n\n        fibersWithChangedErrorOrWarningCounts.add(fiber);\n        flushPendingEvents();\n        updateMostRecentlyInspectedElementIfNecessary(fiberID);\n      } else {\n        fibersWithChangedErrorOrWarningCounts.delete(fiber);\n      }\n    }\n  }\n\n  function clearErrorsForFiberID(fiberID) {\n    clearMessageCountHelper(fiberID, pendingFiberToErrorsMap, fiberIDToErrorsMap);\n  }\n\n  function clearWarningsForFiberID(fiberID) {\n    clearMessageCountHelper(fiberID, pendingFiberToWarningsMap, fiberIDToWarningsMap);\n  }\n\n  function updateMostRecentlyInspectedElementIfNecessary(fiberID) {\n    if (mostRecentlyInspectedElement !== null && mostRecentlyInspectedElement.id === fiberID) {\n      hasElementUpdatedSinceLastInspected = true;\n    }\n  } // Called when an error or warning is logged during render, commit, or passive (including unmount functions).\n\n\n  function onErrorOrWarning(fiber, type, args) {\n    if (type === 'error') {\n      const maybeID = getFiberIDUnsafe(fiber); // if this is an error simulated by us to trigger error boundary, ignore\n\n      if (maybeID != null && forceErrorForFiberIDs.get(maybeID) === true) {\n        return;\n      }\n    }\n\n    const message = Object(backend_utils[\"f\" /* format */])(...args);\n\n    if (constants[\"G\" /* __DEBUG__ */]) {\n      debug('onErrorOrWarning', fiber, null, `${type}: \"${message}\"`);\n    } // Mark this Fiber as needed its warning/error count updated during the next flush.\n\n\n    fibersWithChangedErrorOrWarningCounts.add(fiber); // Track the warning/error for later.\n\n    const fiberMap = type === 'error' ? pendingFiberToErrorsMap : pendingFiberToWarningsMap;\n    const messageMap = fiberMap.get(fiber);\n\n    if (messageMap != null) {\n      const count = messageMap.get(message) || 0;\n      messageMap.set(message, count + 1);\n    } else {\n      fiberMap.set(fiber, new Map([[message, 1]]));\n    } // Passive effects may trigger errors or warnings too;\n    // In this case, we should wait until the rest of the passive effects have run,\n    // but we shouldn't wait until the next commit because that might be a long time.\n    // This would also cause \"tearing\" between an inspected Component and the tree view.\n    // Then again we don't want to flush too soon because this could be an error during async rendering.\n    // Use a debounce technique to ensure that we'll eventually flush.\n\n\n    flushPendingErrorsAndWarningsAfterDelay();\n  } // Patching the console enables DevTools to do a few useful things:\n  // * Append component stacks to warnings and error messages\n  // * Disable logging during re-renders to inspect hooks (see inspectHooksOfFiber)\n\n\n  Object(backend_console[\"d\" /* registerRenderer */])(renderer, onErrorOrWarning); // The renderer interface can't read these preferences directly,\n  // because it is stored in localStorage within the context of the extension.\n  // It relies on the extension to pass the preference through via the global.\n\n  Object(backend_console[\"b\" /* patchConsoleUsingWindowValues */])();\n\n  const debug = (name, fiber, parentFiber, extraString = '') => {\n    if (constants[\"G\" /* __DEBUG__ */]) {\n      const displayName = fiber.tag + ':' + (getDisplayNameForFiber(fiber) || 'null');\n      const maybeID = getFiberIDUnsafe(fiber) || '<no id>';\n      const parentDisplayName = parentFiber ? parentFiber.tag + ':' + (getDisplayNameForFiber(parentFiber) || 'null') : '';\n      const maybeParentID = parentFiber ? getFiberIDUnsafe(parentFiber) || '<no-id>' : '';\n      console.groupCollapsed(`[renderer] %c${name} %c${displayName} (${maybeID}) %c${parentFiber ? `${parentDisplayName} (${maybeParentID})` : ''} %c${extraString}`, 'color: red; font-weight: bold;', 'color: blue;', 'color: purple;', 'color: black;');\n      console.log(new Error().stack.split('\\n').slice(1).join('\\n'));\n      console.groupEnd();\n    }\n  }; // Configurable Components tree filters.\n\n\n  const hideElementsWithDisplayNames = new Set();\n  const hideElementsWithPaths = new Set();\n  const hideElementsWithTypes = new Set(); // Highlight updates\n\n  let traceUpdatesEnabled = false;\n  const traceUpdatesForNodes = new Set();\n\n  function applyComponentFilters(componentFilters) {\n    hideElementsWithTypes.clear();\n    hideElementsWithDisplayNames.clear();\n    hideElementsWithPaths.clear();\n    componentFilters.forEach(componentFilter => {\n      if (!componentFilter.isEnabled) {\n        return;\n      }\n\n      switch (componentFilter.type) {\n        case types[\"a\" /* ComponentFilterDisplayName */]:\n          if (componentFilter.isValid && componentFilter.value !== '') {\n            hideElementsWithDisplayNames.add(new RegExp(componentFilter.value, 'i'));\n          }\n\n          break;\n\n        case types[\"b\" /* ComponentFilterElementType */]:\n          hideElementsWithTypes.add(componentFilter.value);\n          break;\n\n        case types[\"d\" /* ComponentFilterLocation */]:\n          if (componentFilter.isValid && componentFilter.value !== '') {\n            hideElementsWithPaths.add(new RegExp(componentFilter.value, 'i'));\n          }\n\n          break;\n\n        case types[\"c\" /* ComponentFilterHOC */]:\n          hideElementsWithDisplayNames.add(new RegExp('\\\\('));\n          break;\n\n        default:\n          console.warn(`Invalid component filter type \"${componentFilter.type}\"`);\n          break;\n      }\n    });\n  } // The renderer interface can't read saved component filters directly,\n  // because they are stored in localStorage within the context of the extension.\n  // Instead it relies on the extension to pass filters through.\n\n\n  if (window.__REACT_DEVTOOLS_COMPONENT_FILTERS__ != null) {\n    applyComponentFilters(window.__REACT_DEVTOOLS_COMPONENT_FILTERS__);\n  } else {\n    // Unfortunately this feature is not expected to work for React Native for now.\n    // It would be annoying for us to spam YellowBox warnings with unactionable stuff,\n    // so for now just skip this message...\n    //console.warn(' DevTools: Could not locate saved component filters');\n    // Fallback to assuming the default filters in this case.\n    applyComponentFilters(Object(utils[\"i\" /* getDefaultComponentFilters */])());\n  } // If necessary, we can revisit optimizing this operation.\n  // For example, we could add a new recursive unmount tree operation.\n  // The unmount operations are already significantly smaller than mount operations though.\n  // This is something to keep in mind for later.\n\n\n  function updateComponentFilters(componentFilters) {\n    if (isProfiling) {\n      // Re-mounting a tree while profiling is in progress might break a lot of assumptions.\n      // If necessary, we could support this- but it doesn't seem like a necessary use case.\n      throw Error('Cannot modify filter preferences while profiling');\n    } // Recursively unmount all roots.\n\n\n    hook.getFiberRoots(rendererID).forEach(root => {\n      currentRootID = getOrGenerateFiberID(root.current); // The TREE_OPERATION_REMOVE_ROOT operation serves two purposes:\n      // 1. It avoids sending unnecessary bridge traffic to clear a root.\n      // 2. It preserves Fiber IDs when remounting (below) which in turn ID to error/warning mapping.\n\n      pushOperation(constants[\"A\" /* TREE_OPERATION_REMOVE_ROOT */]);\n      flushPendingEvents(root);\n      currentRootID = -1;\n    });\n    applyComponentFilters(componentFilters); // Reset pseudo counters so that new path selections will be persisted.\n\n    rootDisplayNameCounter.clear(); // Recursively re-mount all roots with new filter criteria applied.\n\n    hook.getFiberRoots(rendererID).forEach(root => {\n      currentRootID = getOrGenerateFiberID(root.current);\n      setRootPseudoKey(currentRootID, root.current);\n      mountFiberRecursively(root.current, null, false, false);\n      flushPendingEvents(root);\n      currentRootID = -1;\n    }); // Also re-evaluate all error and warning counts given the new filters.\n\n    reevaluateErrorsAndWarnings();\n    flushPendingEvents();\n  } // NOTICE Keep in sync with get*ForFiber methods\n\n\n  function shouldFilterFiber(fiber) {\n    const {\n      _debugSource,\n      tag,\n      type,\n      key\n    } = fiber;\n\n    switch (tag) {\n      case DehydratedSuspenseComponent:\n        // TODO: ideally we would show dehydrated Suspense immediately.\n        // However, it has some special behavior (like disconnecting\n        // an alternate and turning into real Suspense) which breaks DevTools.\n        // For now, ignore it, and only show it once it gets hydrated.\n        // https://github.com/bvaughn/react-devtools-experimental/issues/197\n        return true;\n\n      case HostPortal:\n      case HostText:\n      case LegacyHiddenComponent:\n      case OffscreenComponent:\n        return true;\n\n      case HostRoot:\n        // It is never valid to filter the root element.\n        return false;\n\n      case Fragment:\n        return key === null;\n\n      default:\n        const typeSymbol = getTypeSymbol(type);\n\n        switch (typeSymbol) {\n          case ReactSymbols[\"a\" /* CONCURRENT_MODE_NUMBER */]:\n          case ReactSymbols[\"b\" /* CONCURRENT_MODE_SYMBOL_STRING */]:\n          case ReactSymbols[\"e\" /* DEPRECATED_ASYNC_MODE_SYMBOL_STRING */]:\n          case ReactSymbols[\"s\" /* STRICT_MODE_NUMBER */]:\n          case ReactSymbols[\"t\" /* STRICT_MODE_SYMBOL_STRING */]:\n            return true;\n\n          default:\n            break;\n        }\n\n    }\n\n    const elementType = getElementTypeForFiber(fiber);\n\n    if (hideElementsWithTypes.has(elementType)) {\n      return true;\n    }\n\n    if (hideElementsWithDisplayNames.size > 0) {\n      const displayName = getDisplayNameForFiber(fiber);\n\n      if (displayName != null) {\n        // eslint-disable-next-line no-for-of-loops/no-for-of-loops\n        for (const displayNameRegExp of hideElementsWithDisplayNames) {\n          if (displayNameRegExp.test(displayName)) {\n            return true;\n          }\n        }\n      }\n    }\n\n    if (_debugSource != null && hideElementsWithPaths.size > 0) {\n      const {\n        fileName\n      } = _debugSource; // eslint-disable-next-line no-for-of-loops/no-for-of-loops\n\n      for (const pathRegExp of hideElementsWithPaths) {\n        if (pathRegExp.test(fileName)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  } // NOTICE Keep in sync with shouldFilterFiber() and other get*ForFiber methods\n\n\n  function getElementTypeForFiber(fiber) {\n    const {\n      type,\n      tag\n    } = fiber;\n\n    switch (tag) {\n      case ClassComponent:\n      case IncompleteClassComponent:\n        return types[\"e\" /* ElementTypeClass */];\n\n      case FunctionComponent:\n      case IndeterminateComponent:\n        return types[\"h\" /* ElementTypeFunction */];\n\n      case ForwardRef:\n        return types[\"g\" /* ElementTypeForwardRef */];\n\n      case HostRoot:\n        return types[\"m\" /* ElementTypeRoot */];\n\n      case HostComponent:\n      case HostResource:\n      case HostSingleton:\n        return types[\"i\" /* ElementTypeHostComponent */];\n\n      case HostPortal:\n      case HostText:\n      case Fragment:\n        return types[\"k\" /* ElementTypeOtherOrUnknown */];\n\n      case MemoComponent:\n      case SimpleMemoComponent:\n        return types[\"j\" /* ElementTypeMemo */];\n\n      case SuspenseComponent:\n        return types[\"n\" /* ElementTypeSuspense */];\n\n      case SuspenseListComponent:\n        return types[\"o\" /* ElementTypeSuspenseList */];\n\n      case TracingMarkerComponent:\n        return types[\"p\" /* ElementTypeTracingMarker */];\n\n      default:\n        const typeSymbol = getTypeSymbol(type);\n\n        switch (typeSymbol) {\n          case ReactSymbols[\"a\" /* CONCURRENT_MODE_NUMBER */]:\n          case ReactSymbols[\"b\" /* CONCURRENT_MODE_SYMBOL_STRING */]:\n          case ReactSymbols[\"e\" /* DEPRECATED_ASYNC_MODE_SYMBOL_STRING */]:\n            return types[\"k\" /* ElementTypeOtherOrUnknown */];\n\n          case ReactSymbols[\"n\" /* PROVIDER_NUMBER */]:\n          case ReactSymbols[\"o\" /* PROVIDER_SYMBOL_STRING */]:\n            return types[\"f\" /* ElementTypeContext */];\n\n          case ReactSymbols[\"c\" /* CONTEXT_NUMBER */]:\n          case ReactSymbols[\"d\" /* CONTEXT_SYMBOL_STRING */]:\n            return types[\"f\" /* ElementTypeContext */];\n\n          case ReactSymbols[\"s\" /* STRICT_MODE_NUMBER */]:\n          case ReactSymbols[\"t\" /* STRICT_MODE_SYMBOL_STRING */]:\n            return types[\"k\" /* ElementTypeOtherOrUnknown */];\n\n          case ReactSymbols[\"l\" /* PROFILER_NUMBER */]:\n          case ReactSymbols[\"m\" /* PROFILER_SYMBOL_STRING */]:\n            return types[\"l\" /* ElementTypeProfiler */];\n\n          default:\n            return types[\"k\" /* ElementTypeOtherOrUnknown */];\n        }\n\n    }\n  } // When profiling is supported, we store the latest tree base durations for each Fiber.\n  // This is so that we can quickly capture a snapshot of those values if profiling starts.\n  // If we didn't store these values, we'd have to crawl the tree when profiling started,\n  // and use a slow path to find each of the current Fibers.\n\n\n  const idToTreeBaseDurationMap = new Map(); // When profiling is supported, we store the latest tree base durations for each Fiber.\n  // This map enables us to filter these times by root when sending them to the frontend.\n\n  const idToRootMap = new Map(); // When a mount or update is in progress, this value tracks the root that is being operated on.\n\n  let currentRootID = -1; // Returns the unique ID for a Fiber or generates and caches a new one if the Fiber hasn't been seen before.\n  // Once this method has been called for a Fiber, untrackFiberID() should always be called later to avoid leaking.\n\n  function getOrGenerateFiberID(fiber) {\n    let id = null;\n\n    if (fiberToIDMap.has(fiber)) {\n      id = fiberToIDMap.get(fiber);\n    } else {\n      const {\n        alternate\n      } = fiber;\n\n      if (alternate !== null && fiberToIDMap.has(alternate)) {\n        id = fiberToIDMap.get(alternate);\n      }\n    }\n\n    let didGenerateID = false;\n\n    if (id === null) {\n      didGenerateID = true;\n      id = Object(utils[\"r\" /* getUID */])();\n    } // This refinement is for Flow purposes only.\n\n\n    const refinedID = id; // Make sure we're tracking this Fiber\n    // e.g. if it just mounted or an error was logged during initial render.\n\n    if (!fiberToIDMap.has(fiber)) {\n      fiberToIDMap.set(fiber, refinedID);\n      idToArbitraryFiberMap.set(refinedID, fiber);\n    } // Also make sure we're tracking its alternate,\n    // e.g. in case this is the first update after mount.\n\n\n    const {\n      alternate\n    } = fiber;\n\n    if (alternate !== null) {\n      if (!fiberToIDMap.has(alternate)) {\n        fiberToIDMap.set(alternate, refinedID);\n      }\n    }\n\n    if (constants[\"G\" /* __DEBUG__ */]) {\n      if (didGenerateID) {\n        debug('getOrGenerateFiberID()', fiber, fiber.return, 'Generated a new UID');\n      }\n    }\n\n    return refinedID;\n  } // Returns an ID if one has already been generated for the Fiber or throws.\n\n\n  function getFiberIDThrows(fiber) {\n    const maybeID = getFiberIDUnsafe(fiber);\n\n    if (maybeID !== null) {\n      return maybeID;\n    }\n\n    throw Error(`Could not find ID for Fiber \"${getDisplayNameForFiber(fiber) || ''}\"`);\n  } // Returns an ID if one has already been generated for the Fiber or null if one has not been generated.\n  // Use this method while e.g. logging to avoid over-retaining Fibers.\n\n\n  function getFiberIDUnsafe(fiber) {\n    if (fiberToIDMap.has(fiber)) {\n      return fiberToIDMap.get(fiber);\n    } else {\n      const {\n        alternate\n      } = fiber;\n\n      if (alternate !== null && fiberToIDMap.has(alternate)) {\n        return fiberToIDMap.get(alternate);\n      }\n    }\n\n    return null;\n  } // Removes a Fiber (and its alternate) from the Maps used to track their id.\n  // This method should always be called when a Fiber is unmounting.\n\n\n  function untrackFiberID(fiber) {\n    if (constants[\"G\" /* __DEBUG__ */]) {\n      debug('untrackFiberID()', fiber, fiber.return, 'schedule after delay');\n    } // Untrack Fibers after a slight delay in order to support a Fast Refresh edge case:\n    // 1. Component type is updated and Fast Refresh schedules an update+remount.\n    // 2. flushPendingErrorsAndWarningsAfterDelay() runs, sees the old Fiber is no longer mounted\n    //    (it's been disconnected by Fast Refresh), and calls untrackFiberID() to clear it from the Map.\n    // 3. React flushes pending passive effects before it runs the next render,\n    //    which logs an error or warning, which causes a new ID to be generated for this Fiber.\n    // 4. DevTools now tries to unmount the old Component with the new ID.\n    //\n    // The underlying problem here is the premature clearing of the Fiber ID,\n    // but DevTools has no way to detect that a given Fiber has been scheduled for Fast Refresh.\n    // (The \"_debugNeedsRemount\" flag won't necessarily be set.)\n    //\n    // The best we can do is to delay untracking by a small amount,\n    // and give React time to process the Fast Refresh delay.\n\n\n    untrackFibersSet.add(fiber); // React may detach alternate pointers during unmount;\n    // Since our untracking code is async, we should explicily track the pending alternate here as well.\n\n    const alternate = fiber.alternate;\n\n    if (alternate !== null) {\n      untrackFibersSet.add(alternate);\n    }\n\n    if (untrackFibersTimeoutID === null) {\n      untrackFibersTimeoutID = setTimeout(untrackFibers, 1000);\n    }\n  }\n\n  const untrackFibersSet = new Set();\n  let untrackFibersTimeoutID = null;\n\n  function untrackFibers() {\n    if (untrackFibersTimeoutID !== null) {\n      clearTimeout(untrackFibersTimeoutID);\n      untrackFibersTimeoutID = null;\n    }\n\n    untrackFibersSet.forEach(fiber => {\n      const fiberID = getFiberIDUnsafe(fiber);\n\n      if (fiberID !== null) {\n        idToArbitraryFiberMap.delete(fiberID); // Also clear any errors/warnings associated with this fiber.\n\n        clearErrorsForFiberID(fiberID);\n        clearWarningsForFiberID(fiberID);\n      }\n\n      fiberToIDMap.delete(fiber);\n      const {\n        alternate\n      } = fiber;\n\n      if (alternate !== null) {\n        fiberToIDMap.delete(alternate);\n      }\n\n      if (forceErrorForFiberIDs.has(fiberID)) {\n        forceErrorForFiberIDs.delete(fiberID);\n\n        if (forceErrorForFiberIDs.size === 0 && setErrorHandler != null) {\n          setErrorHandler(shouldErrorFiberAlwaysNull);\n        }\n      }\n    });\n    untrackFibersSet.clear();\n  }\n\n  function getChangeDescription(prevFiber, nextFiber) {\n    switch (getElementTypeForFiber(nextFiber)) {\n      case types[\"e\" /* ElementTypeClass */]:\n      case types[\"h\" /* ElementTypeFunction */]:\n      case types[\"j\" /* ElementTypeMemo */]:\n      case types[\"g\" /* ElementTypeForwardRef */]:\n        if (prevFiber === null) {\n          return {\n            context: null,\n            didHooksChange: false,\n            isFirstMount: true,\n            props: null,\n            state: null\n          };\n        } else {\n          const data = {\n            context: getContextChangedKeys(nextFiber),\n            didHooksChange: false,\n            isFirstMount: false,\n            props: getChangedKeys(prevFiber.memoizedProps, nextFiber.memoizedProps),\n            state: getChangedKeys(prevFiber.memoizedState, nextFiber.memoizedState)\n          }; // Only traverse the hooks list once, depending on what info we're returning.\n\n          if (DevToolsFeatureFlags_default[\"d\" /* enableProfilerChangedHookIndices */]) {\n            const indices = getChangedHooksIndices(prevFiber.memoizedState, nextFiber.memoizedState);\n            data.hooks = indices;\n            data.didHooksChange = indices !== null && indices.length > 0;\n          } else {\n            data.didHooksChange = didHooksChange(prevFiber.memoizedState, nextFiber.memoizedState);\n          }\n\n          return data;\n        }\n\n      default:\n        return null;\n    }\n  }\n\n  function updateContextsForFiber(fiber) {\n    switch (getElementTypeForFiber(fiber)) {\n      case types[\"e\" /* ElementTypeClass */]:\n      case types[\"g\" /* ElementTypeForwardRef */]:\n      case types[\"h\" /* ElementTypeFunction */]:\n      case types[\"j\" /* ElementTypeMemo */]:\n        if (idToContextsMap !== null) {\n          const id = getFiberIDThrows(fiber);\n          const contexts = getContextsForFiber(fiber);\n\n          if (contexts !== null) {\n            // $FlowFixMe[incompatible-use] found when upgrading Flow\n            idToContextsMap.set(id, contexts);\n          }\n        }\n\n        break;\n\n      default:\n        break;\n    }\n  } // Differentiates between a null context value and no context.\n\n\n  const NO_CONTEXT = {};\n\n  function getContextsForFiber(fiber) {\n    let legacyContext = NO_CONTEXT;\n    let modernContext = NO_CONTEXT;\n\n    switch (getElementTypeForFiber(fiber)) {\n      case types[\"e\" /* ElementTypeClass */]:\n        const instance = fiber.stateNode;\n\n        if (instance != null) {\n          if (instance.constructor && instance.constructor.contextType != null) {\n            modernContext = instance.context;\n          } else {\n            legacyContext = instance.context;\n\n            if (legacyContext && Object.keys(legacyContext).length === 0) {\n              legacyContext = NO_CONTEXT;\n            }\n          }\n        }\n\n        return [legacyContext, modernContext];\n\n      case types[\"g\" /* ElementTypeForwardRef */]:\n      case types[\"h\" /* ElementTypeFunction */]:\n      case types[\"j\" /* ElementTypeMemo */]:\n        const dependencies = fiber.dependencies;\n\n        if (dependencies && dependencies.firstContext) {\n          modernContext = dependencies.firstContext;\n        }\n\n        return [legacyContext, modernContext];\n\n      default:\n        return null;\n    }\n  } // Record all contexts at the time profiling is started.\n  // Fibers only store the current context value,\n  // so we need to track them separately in order to determine changed keys.\n\n\n  function crawlToInitializeContextsMap(fiber) {\n    const id = getFiberIDUnsafe(fiber); // Not all Fibers in the subtree have mounted yet.\n    // For example, Offscreen (hidden) or Suspense (suspended) subtrees won't yet be tracked.\n    // We can safely skip these subtrees.\n\n    if (id !== null) {\n      updateContextsForFiber(fiber);\n      let current = fiber.child;\n\n      while (current !== null) {\n        crawlToInitializeContextsMap(current);\n        current = current.sibling;\n      }\n    }\n  }\n\n  function getContextChangedKeys(fiber) {\n    if (idToContextsMap !== null) {\n      const id = getFiberIDThrows(fiber); // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n      const prevContexts = idToContextsMap.has(id) ? // $FlowFixMe[incompatible-use] found when upgrading Flow\n      idToContextsMap.get(id) : null;\n      const nextContexts = getContextsForFiber(fiber);\n\n      if (prevContexts == null || nextContexts == null) {\n        return null;\n      }\n\n      const [prevLegacyContext, prevModernContext] = prevContexts;\n      const [nextLegacyContext, nextModernContext] = nextContexts;\n\n      switch (getElementTypeForFiber(fiber)) {\n        case types[\"e\" /* ElementTypeClass */]:\n          if (prevContexts && nextContexts) {\n            if (nextLegacyContext !== NO_CONTEXT) {\n              return getChangedKeys(prevLegacyContext, nextLegacyContext);\n            } else if (nextModernContext !== NO_CONTEXT) {\n              return prevModernContext !== nextModernContext;\n            }\n          }\n\n          break;\n\n        case types[\"g\" /* ElementTypeForwardRef */]:\n        case types[\"h\" /* ElementTypeFunction */]:\n        case types[\"j\" /* ElementTypeMemo */]:\n          if (nextModernContext !== NO_CONTEXT) {\n            let prevContext = prevModernContext;\n            let nextContext = nextModernContext;\n\n            while (prevContext && nextContext) {\n              // Note this only works for versions of React that support this key (e.v. 18+)\n              // For older versions, there's no good way to read the current context value after render has completed.\n              // This is because React maintains a stack of context values during render,\n              // but by the time DevTools is called, render has finished and the stack is empty.\n              if (!shared_objectIs(prevContext.memoizedValue, nextContext.memoizedValue)) {\n                return true;\n              }\n\n              prevContext = prevContext.next;\n              nextContext = nextContext.next;\n            }\n\n            return false;\n          }\n\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    return null;\n  }\n\n  function isHookThatCanScheduleUpdate(hookObject) {\n    const queue = hookObject.queue;\n\n    if (!queue) {\n      return false;\n    }\n\n    const boundHasOwnProperty = shared_hasOwnProperty[\"a\" /* default */].bind(queue); // Detect the shape of useState() or useReducer()\n    // using the attributes that are unique to these hooks\n    // but also stable (e.g. not tied to current Lanes implementation)\n\n    const isStateOrReducer = boundHasOwnProperty('pending') && boundHasOwnProperty('dispatch') && typeof queue.dispatch === 'function'; // Detect useSyncExternalStore()\n\n    const isSyncExternalStore = boundHasOwnProperty('value') && boundHasOwnProperty('getSnapshot') && typeof queue.getSnapshot === 'function'; // These are the only types of hooks that can schedule an update.\n\n    return isStateOrReducer || isSyncExternalStore;\n  }\n\n  function didStatefulHookChange(prev, next) {\n    const prevMemoizedState = prev.memoizedState;\n    const nextMemoizedState = next.memoizedState;\n\n    if (isHookThatCanScheduleUpdate(prev)) {\n      return prevMemoizedState !== nextMemoizedState;\n    }\n\n    return false;\n  }\n\n  function didHooksChange(prev, next) {\n    if (prev == null || next == null) {\n      return false;\n    } // We can't report anything meaningful for hooks changes.\n\n\n    if (next.hasOwnProperty('baseState') && next.hasOwnProperty('memoizedState') && next.hasOwnProperty('next') && next.hasOwnProperty('queue')) {\n      while (next !== null) {\n        if (didStatefulHookChange(prev, next)) {\n          return true;\n        } else {\n          next = next.next;\n          prev = prev.next;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  function getChangedHooksIndices(prev, next) {\n    if (DevToolsFeatureFlags_default[\"d\" /* enableProfilerChangedHookIndices */]) {\n      if (prev == null || next == null) {\n        return null;\n      }\n\n      const indices = [];\n      let index = 0;\n\n      if (next.hasOwnProperty('baseState') && next.hasOwnProperty('memoizedState') && next.hasOwnProperty('next') && next.hasOwnProperty('queue')) {\n        while (next !== null) {\n          if (didStatefulHookChange(prev, next)) {\n            indices.push(index);\n          }\n\n          next = next.next;\n          prev = prev.next;\n          index++;\n        }\n      }\n\n      return indices;\n    }\n\n    return null;\n  }\n\n  function getChangedKeys(prev, next) {\n    if (prev == null || next == null) {\n      return null;\n    } // We can't report anything meaningful for hooks changes.\n\n\n    if (next.hasOwnProperty('baseState') && next.hasOwnProperty('memoizedState') && next.hasOwnProperty('next') && next.hasOwnProperty('queue')) {\n      return null;\n    }\n\n    const keys = new Set([...Object.keys(prev), ...Object.keys(next)]);\n    const changedKeys = []; // eslint-disable-next-line no-for-of-loops/no-for-of-loops\n\n    for (const key of keys) {\n      if (prev[key] !== next[key]) {\n        changedKeys.push(key);\n      }\n    }\n\n    return changedKeys;\n  } // eslint-disable-next-line no-unused-vars\n\n\n  function didFiberRender(prevFiber, nextFiber) {\n    switch (nextFiber.tag) {\n      case ClassComponent:\n      case FunctionComponent:\n      case ContextConsumer:\n      case MemoComponent:\n      case SimpleMemoComponent:\n      case ForwardRef:\n        // For types that execute user code, we check PerformedWork effect.\n        // We don't reflect bailouts (either referential or sCU) in DevTools.\n        // eslint-disable-next-line no-bitwise\n        return (getFiberFlags(nextFiber) & PerformedWork) === PerformedWork;\n      // Note: ContextConsumer only gets PerformedWork effect in 16.3.3+\n      // so it won't get highlighted with React 16.3.0 to 16.3.2.\n\n      default:\n        // For host components and other types, we compare inputs\n        // to determine whether something is an update.\n        return prevFiber.memoizedProps !== nextFiber.memoizedProps || prevFiber.memoizedState !== nextFiber.memoizedState || prevFiber.ref !== nextFiber.ref;\n    }\n  }\n\n  const pendingOperations = [];\n  const pendingRealUnmountedIDs = [];\n  const pendingSimulatedUnmountedIDs = [];\n  let pendingOperationsQueue = [];\n  const pendingStringTable = new Map();\n  let pendingStringTableLength = 0;\n  let pendingUnmountedRootID = null;\n\n  function pushOperation(op) {\n    if (false) {}\n\n    pendingOperations.push(op);\n  }\n\n  function shouldBailoutWithPendingOperations() {\n    if (isProfiling) {\n      if (currentCommitProfilingMetadata != null && currentCommitProfilingMetadata.durations.length > 0) {\n        return false;\n      }\n    }\n\n    return pendingOperations.length === 0 && pendingRealUnmountedIDs.length === 0 && pendingSimulatedUnmountedIDs.length === 0 && pendingUnmountedRootID === null;\n  }\n\n  function flushOrQueueOperations(operations) {\n    if (shouldBailoutWithPendingOperations()) {\n      return;\n    }\n\n    if (pendingOperationsQueue !== null) {\n      pendingOperationsQueue.push(operations);\n    } else {\n      hook.emit('operations', operations);\n    }\n  }\n\n  let flushPendingErrorsAndWarningsAfterDelayTimeoutID = null;\n\n  function clearPendingErrorsAndWarningsAfterDelay() {\n    if (flushPendingErrorsAndWarningsAfterDelayTimeoutID !== null) {\n      clearTimeout(flushPendingErrorsAndWarningsAfterDelayTimeoutID);\n      flushPendingErrorsAndWarningsAfterDelayTimeoutID = null;\n    }\n  }\n\n  function flushPendingErrorsAndWarningsAfterDelay() {\n    clearPendingErrorsAndWarningsAfterDelay();\n    flushPendingErrorsAndWarningsAfterDelayTimeoutID = setTimeout(() => {\n      flushPendingErrorsAndWarningsAfterDelayTimeoutID = null;\n\n      if (pendingOperations.length > 0) {\n        // On the off chance that something else has pushed pending operations,\n        // we should bail on warnings; it's probably not safe to push midway.\n        return;\n      }\n\n      recordPendingErrorsAndWarnings();\n\n      if (shouldBailoutWithPendingOperations()) {\n        // No warnings or errors to flush; we can bail out early here too.\n        return;\n      } // We can create a smaller operations array than flushPendingEvents()\n      // because we only need to flush warning and error counts.\n      // Only a few pieces of fixed information are required up front.\n\n\n      const operations = new Array(3 + pendingOperations.length);\n      operations[0] = rendererID;\n      operations[1] = currentRootID;\n      operations[2] = 0; // String table size\n\n      for (let j = 0; j < pendingOperations.length; j++) {\n        operations[3 + j] = pendingOperations[j];\n      }\n\n      flushOrQueueOperations(operations);\n      pendingOperations.length = 0;\n    }, 1000);\n  }\n\n  function reevaluateErrorsAndWarnings() {\n    fibersWithChangedErrorOrWarningCounts.clear();\n    fiberIDToErrorsMap.forEach((countMap, fiberID) => {\n      const fiber = idToArbitraryFiberMap.get(fiberID);\n\n      if (fiber != null) {\n        fibersWithChangedErrorOrWarningCounts.add(fiber);\n      }\n    });\n    fiberIDToWarningsMap.forEach((countMap, fiberID) => {\n      const fiber = idToArbitraryFiberMap.get(fiberID);\n\n      if (fiber != null) {\n        fibersWithChangedErrorOrWarningCounts.add(fiber);\n      }\n    });\n    recordPendingErrorsAndWarnings();\n  }\n\n  function mergeMapsAndGetCountHelper(fiber, fiberID, pendingFiberToMessageCountMap, fiberIDToMessageCountMap) {\n    let newCount = 0;\n    let messageCountMap = fiberIDToMessageCountMap.get(fiberID);\n    const pendingMessageCountMap = pendingFiberToMessageCountMap.get(fiber);\n\n    if (pendingMessageCountMap != null) {\n      if (messageCountMap == null) {\n        messageCountMap = pendingMessageCountMap;\n        fiberIDToMessageCountMap.set(fiberID, pendingMessageCountMap);\n      } else {\n        // This Flow refinement should not be necessary and yet...\n        const refinedMessageCountMap = messageCountMap;\n        pendingMessageCountMap.forEach((pendingCount, message) => {\n          const previousCount = refinedMessageCountMap.get(message) || 0;\n          refinedMessageCountMap.set(message, previousCount + pendingCount);\n        });\n      }\n    }\n\n    if (!shouldFilterFiber(fiber)) {\n      if (messageCountMap != null) {\n        messageCountMap.forEach(count => {\n          newCount += count;\n        });\n      }\n    }\n\n    pendingFiberToMessageCountMap.delete(fiber);\n    return newCount;\n  }\n\n  function recordPendingErrorsAndWarnings() {\n    clearPendingErrorsAndWarningsAfterDelay();\n    fibersWithChangedErrorOrWarningCounts.forEach(fiber => {\n      const fiberID = getFiberIDUnsafe(fiber);\n\n      if (fiberID === null) {// Don't send updates for Fibers that didn't mount due to e.g. Suspense or an error boundary.\n      } else {\n        const errorCount = mergeMapsAndGetCountHelper(fiber, fiberID, pendingFiberToErrorsMap, fiberIDToErrorsMap);\n        const warningCount = mergeMapsAndGetCountHelper(fiber, fiberID, pendingFiberToWarningsMap, fiberIDToWarningsMap);\n        pushOperation(constants[\"D\" /* TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS */]);\n        pushOperation(fiberID);\n        pushOperation(errorCount);\n        pushOperation(warningCount);\n      } // Always clean up so that we don't leak.\n\n\n      pendingFiberToErrorsMap.delete(fiber);\n      pendingFiberToWarningsMap.delete(fiber);\n    });\n    fibersWithChangedErrorOrWarningCounts.clear();\n  }\n\n  function flushPendingEvents(root) {\n    // Add any pending errors and warnings to the operations array.\n    // We do this just before flushing, so we can ignore errors for no-longer-mounted Fibers.\n    recordPendingErrorsAndWarnings();\n\n    if (shouldBailoutWithPendingOperations()) {\n      // If we aren't profiling, we can just bail out here.\n      // No use sending an empty update over the bridge.\n      //\n      // The Profiler stores metadata for each commit and reconstructs the app tree per commit using:\n      // (1) an initial tree snapshot and\n      // (2) the operations array for each commit\n      // Because of this, it's important that the operations and metadata arrays align,\n      // So it's important not to omit even empty operations while profiling is active.\n      return;\n    }\n\n    const numUnmountIDs = pendingRealUnmountedIDs.length + pendingSimulatedUnmountedIDs.length + (pendingUnmountedRootID === null ? 0 : 1);\n    const operations = new Array( // Identify which renderer this update is coming from.\n    2 + // [rendererID, rootFiberID]\n    // How big is the string table?\n    1 + // [stringTableLength]\n    // Then goes the actual string table.\n    pendingStringTableLength + ( // All unmounts are batched in a single message.\n    // [TREE_OPERATION_REMOVE, removedIDLength, ...ids]\n    numUnmountIDs > 0 ? 2 + numUnmountIDs : 0) + // Regular operations\n    pendingOperations.length); // Identify which renderer this update is coming from.\n    // This enables roots to be mapped to renderers,\n    // Which in turn enables fiber props, states, and hooks to be inspected.\n\n    let i = 0;\n    operations[i++] = rendererID;\n    operations[i++] = currentRootID; // Now fill in the string table.\n    // [stringTableLength, str1Length, ...str1, str2Length, ...str2, ...]\n\n    operations[i++] = pendingStringTableLength;\n    pendingStringTable.forEach((entry, stringKey) => {\n      const encodedString = entry.encodedString; // Don't use the string length.\n      // It won't work for multibyte characters (like emoji).\n\n      const length = encodedString.length;\n      operations[i++] = length;\n\n      for (let j = 0; j < length; j++) {\n        operations[i + j] = encodedString[j];\n      }\n\n      i += length;\n    });\n\n    if (numUnmountIDs > 0) {\n      // All unmounts except roots are batched in a single message.\n      operations[i++] = constants[\"z\" /* TREE_OPERATION_REMOVE */]; // The first number is how many unmounted IDs we're gonna send.\n\n      operations[i++] = numUnmountIDs; // Fill in the real unmounts in the reverse order.\n      // They were inserted parents-first by React, but we want children-first.\n      // So we traverse our array backwards.\n\n      for (let j = pendingRealUnmountedIDs.length - 1; j >= 0; j--) {\n        operations[i++] = pendingRealUnmountedIDs[j];\n      } // Fill in the simulated unmounts (hidden Suspense subtrees) in their order.\n      // (We want children to go before parents.)\n      // They go *after* the real unmounts because we know for sure they won't be\n      // children of already pushed \"real\" IDs. If they were, we wouldn't be able\n      // to discover them during the traversal, as they would have been deleted.\n\n\n      for (let j = 0; j < pendingSimulatedUnmountedIDs.length; j++) {\n        operations[i + j] = pendingSimulatedUnmountedIDs[j];\n      }\n\n      i += pendingSimulatedUnmountedIDs.length; // The root ID should always be unmounted last.\n\n      if (pendingUnmountedRootID !== null) {\n        operations[i] = pendingUnmountedRootID;\n        i++;\n      }\n    } // Fill in the rest of the operations.\n\n\n    for (let j = 0; j < pendingOperations.length; j++) {\n      operations[i + j] = pendingOperations[j];\n    }\n\n    i += pendingOperations.length; // Let the frontend know about tree operations.\n\n    flushOrQueueOperations(operations); // Reset all of the pending state now that we've told the frontend about it.\n\n    pendingOperations.length = 0;\n    pendingRealUnmountedIDs.length = 0;\n    pendingSimulatedUnmountedIDs.length = 0;\n    pendingUnmountedRootID = null;\n    pendingStringTable.clear();\n    pendingStringTableLength = 0;\n  }\n\n  function getStringID(string) {\n    if (string === null) {\n      return 0;\n    }\n\n    const existingEntry = pendingStringTable.get(string);\n\n    if (existingEntry !== undefined) {\n      return existingEntry.id;\n    }\n\n    const id = pendingStringTable.size + 1;\n    const encodedString = Object(utils[\"A\" /* utfEncodeString */])(string);\n    pendingStringTable.set(string, {\n      encodedString,\n      id\n    }); // The string table total length needs to account both for the string length,\n    // and for the array item that contains the length itself.\n    //\n    // Don't use string length for this table.\n    // It won't work for multibyte characters (like emoji).\n\n    pendingStringTableLength += encodedString.length + 1;\n    return id;\n  }\n\n  function recordMount(fiber, parentFiber) {\n    const isRoot = fiber.tag === HostRoot;\n    const id = getOrGenerateFiberID(fiber);\n\n    if (constants[\"G\" /* __DEBUG__ */]) {\n      debug('recordMount()', fiber, parentFiber);\n    }\n\n    const hasOwnerMetadata = fiber.hasOwnProperty('_debugOwner');\n    const isProfilingSupported = fiber.hasOwnProperty('treeBaseDuration'); // Adding a new field here would require a bridge protocol version bump (a backwads breaking change).\n    // Instead let's re-purpose a pre-existing field to carry more information.\n\n    let profilingFlags = 0;\n\n    if (isProfilingSupported) {\n      profilingFlags = constants[\"r\" /* PROFILING_FLAG_BASIC_SUPPORT */];\n\n      if (typeof injectProfilingHooks === 'function') {\n        profilingFlags |= constants[\"s\" /* PROFILING_FLAG_TIMELINE_SUPPORT */];\n      }\n    }\n\n    if (isRoot) {\n      pushOperation(constants[\"y\" /* TREE_OPERATION_ADD */]);\n      pushOperation(id);\n      pushOperation(types[\"m\" /* ElementTypeRoot */]);\n      pushOperation((fiber.mode & StrictModeBits) !== 0 ? 1 : 0);\n      pushOperation(profilingFlags);\n      pushOperation(StrictModeBits !== 0 ? 1 : 0);\n      pushOperation(hasOwnerMetadata ? 1 : 0);\n\n      if (isProfiling) {\n        if (displayNamesByRootID !== null) {\n          displayNamesByRootID.set(id, getDisplayNameForRoot(fiber));\n        }\n      }\n    } else {\n      const {\n        key\n      } = fiber;\n      const displayName = getDisplayNameForFiber(fiber);\n      const elementType = getElementTypeForFiber(fiber);\n      const {\n        _debugOwner\n      } = fiber; // Ideally we should call getFiberIDThrows() for _debugOwner,\n      // since owners are almost always higher in the tree (and so have already been processed),\n      // but in some (rare) instances reported in open source, a descendant mounts before an owner.\n      // Since this is a DEV only field it's probably okay to also just lazily generate and ID here if needed.\n      // See https://github.com/facebook/react/issues/21445\n\n      const ownerID = _debugOwner != null ? getOrGenerateFiberID(_debugOwner) : 0;\n      const parentID = parentFiber ? getFiberIDThrows(parentFiber) : 0;\n      const displayNameStringID = getStringID(displayName); // This check is a guard to handle a React element that has been modified\n      // in such a way as to bypass the default stringification of the \"key\" property.\n\n      const keyString = key === null ? null : String(key);\n      const keyStringID = getStringID(keyString);\n      pushOperation(constants[\"y\" /* TREE_OPERATION_ADD */]);\n      pushOperation(id);\n      pushOperation(elementType);\n      pushOperation(parentID);\n      pushOperation(ownerID);\n      pushOperation(displayNameStringID);\n      pushOperation(keyStringID); // If this subtree has a new mode, let the frontend know.\n\n      if ((fiber.mode & StrictModeBits) !== 0 && (parentFiber.mode & StrictModeBits) === 0) {\n        pushOperation(constants[\"C\" /* TREE_OPERATION_SET_SUBTREE_MODE */]);\n        pushOperation(id);\n        pushOperation(types[\"q\" /* StrictMode */]);\n      }\n    }\n\n    if (isProfilingSupported) {\n      idToRootMap.set(id, currentRootID);\n      recordProfilingDurations(fiber);\n    }\n  }\n\n  function recordUnmount(fiber, isSimulated) {\n    if (constants[\"G\" /* __DEBUG__ */]) {\n      debug('recordUnmount()', fiber, null, isSimulated ? 'unmount is simulated' : '');\n    }\n\n    if (trackedPathMatchFiber !== null) {\n      // We're in the process of trying to restore previous selection.\n      // If this fiber matched but is being unmounted, there's no use trying.\n      // Reset the state so we don't keep holding onto it.\n      if (fiber === trackedPathMatchFiber || fiber === trackedPathMatchFiber.alternate) {\n        setTrackedPath(null);\n      }\n    }\n\n    const unsafeID = getFiberIDUnsafe(fiber);\n\n    if (unsafeID === null) {\n      // If we've never seen this Fiber, it might be inside of a legacy render Suspense fragment (so the store is not even aware of it).\n      // In that case we can just ignore it or it will cause errors later on.\n      // One example of this is a Lazy component that never resolves before being unmounted.\n      //\n      // This also might indicate a Fast Refresh force-remount scenario.\n      //\n      // TODO: This is fragile and can obscure actual bugs.\n      return;\n    } // Flow refinement.\n\n\n    const id = unsafeID;\n    const isRoot = fiber.tag === HostRoot;\n\n    if (isRoot) {\n      // Roots must be removed only after all children (pending and simulated) have been removed.\n      // So we track it separately.\n      pendingUnmountedRootID = id;\n    } else if (!shouldFilterFiber(fiber)) {\n      // To maintain child-first ordering,\n      // we'll push it into one of these queues,\n      // and later arrange them in the correct order.\n      if (isSimulated) {\n        pendingSimulatedUnmountedIDs.push(id);\n      } else {\n        pendingRealUnmountedIDs.push(id);\n      }\n    }\n\n    if (!fiber._debugNeedsRemount) {\n      untrackFiberID(fiber);\n      const isProfilingSupported = fiber.hasOwnProperty('treeBaseDuration');\n\n      if (isProfilingSupported) {\n        idToRootMap.delete(id);\n        idToTreeBaseDurationMap.delete(id);\n      }\n    }\n  }\n\n  function mountFiberRecursively(firstChild, parentFiber, traverseSiblings, traceNearestHostComponentUpdate) {\n    // Iterate over siblings rather than recursing.\n    // This reduces the chance of stack overflow for wide trees (e.g. lists with many items).\n    let fiber = firstChild;\n\n    while (fiber !== null) {\n      // Generate an ID even for filtered Fibers, in case it's needed later (e.g. for Profiling).\n      getOrGenerateFiberID(fiber);\n\n      if (constants[\"G\" /* __DEBUG__ */]) {\n        debug('mountFiberRecursively()', fiber, parentFiber);\n      } // If we have the tree selection from previous reload, try to match this Fiber.\n      // Also remember whether to do the same for siblings.\n\n\n      const mightSiblingsBeOnTrackedPath = updateTrackedPathStateBeforeMount(fiber);\n      const shouldIncludeInTree = !shouldFilterFiber(fiber);\n\n      if (shouldIncludeInTree) {\n        recordMount(fiber, parentFiber);\n      }\n\n      if (traceUpdatesEnabled) {\n        if (traceNearestHostComponentUpdate) {\n          const elementType = getElementTypeForFiber(fiber); // If an ancestor updated, we should mark the nearest host nodes for highlighting.\n\n          if (elementType === types[\"i\" /* ElementTypeHostComponent */]) {\n            traceUpdatesForNodes.add(fiber.stateNode);\n            traceNearestHostComponentUpdate = false;\n          }\n        } // We intentionally do not re-enable the traceNearestHostComponentUpdate flag in this branch,\n        // because we don't want to highlight every host node inside of a newly mounted subtree.\n\n      }\n\n      const isSuspense = fiber.tag === ReactTypeOfWork.SuspenseComponent;\n\n      if (isSuspense) {\n        const isTimedOut = fiber.memoizedState !== null;\n\n        if (isTimedOut) {\n          // Special case: if Suspense mounts in a timed-out state,\n          // get the fallback child from the inner fragment and mount\n          // it as if it was our own child. Updates handle this too.\n          const primaryChildFragment = fiber.child;\n          const fallbackChildFragment = primaryChildFragment ? primaryChildFragment.sibling : null;\n          const fallbackChild = fallbackChildFragment ? fallbackChildFragment.child : null;\n\n          if (fallbackChild !== null) {\n            mountFiberRecursively(fallbackChild, shouldIncludeInTree ? fiber : parentFiber, true, traceNearestHostComponentUpdate);\n          }\n        } else {\n          let primaryChild = null;\n          const areSuspenseChildrenConditionallyWrapped = OffscreenComponent === -1;\n\n          if (areSuspenseChildrenConditionallyWrapped) {\n            primaryChild = fiber.child;\n          } else if (fiber.child !== null) {\n            primaryChild = fiber.child.child;\n          }\n\n          if (primaryChild !== null) {\n            mountFiberRecursively(primaryChild, shouldIncludeInTree ? fiber : parentFiber, true, traceNearestHostComponentUpdate);\n          }\n        }\n      } else {\n        if (fiber.child !== null) {\n          mountFiberRecursively(fiber.child, shouldIncludeInTree ? fiber : parentFiber, true, traceNearestHostComponentUpdate);\n        }\n      } // We're exiting this Fiber now, and entering its siblings.\n      // If we have selection to restore, we might need to re-activate tracking.\n\n\n      updateTrackedPathStateAfterMount(mightSiblingsBeOnTrackedPath);\n      fiber = traverseSiblings ? fiber.sibling : null;\n    }\n  } // We use this to simulate unmounting for Suspense trees\n  // when we switch from primary to fallback.\n\n\n  function unmountFiberChildrenRecursively(fiber) {\n    if (constants[\"G\" /* __DEBUG__ */]) {\n      debug('unmountFiberChildrenRecursively()', fiber);\n    } // We might meet a nested Suspense on our way.\n\n\n    const isTimedOutSuspense = fiber.tag === ReactTypeOfWork.SuspenseComponent && fiber.memoizedState !== null;\n    let child = fiber.child;\n\n    if (isTimedOutSuspense) {\n      // If it's showing fallback tree, let's traverse it instead.\n      const primaryChildFragment = fiber.child;\n      const fallbackChildFragment = primaryChildFragment ? primaryChildFragment.sibling : null; // Skip over to the real Fiber child.\n\n      child = fallbackChildFragment ? fallbackChildFragment.child : null;\n    }\n\n    while (child !== null) {\n      // Record simulated unmounts children-first.\n      // We skip nodes without return because those are real unmounts.\n      if (child.return !== null) {\n        unmountFiberChildrenRecursively(child);\n        recordUnmount(child, true);\n      }\n\n      child = child.sibling;\n    }\n  }\n\n  function recordProfilingDurations(fiber) {\n    const id = getFiberIDThrows(fiber);\n    const {\n      actualDuration,\n      treeBaseDuration\n    } = fiber;\n    idToTreeBaseDurationMap.set(id, treeBaseDuration || 0);\n\n    if (isProfiling) {\n      const {\n        alternate\n      } = fiber; // It's important to update treeBaseDuration even if the current Fiber did not render,\n      // because it's possible that one of its descendants did.\n\n      if (alternate == null || treeBaseDuration !== alternate.treeBaseDuration) {\n        // Tree base duration updates are included in the operations typed array.\n        // So we have to convert them from milliseconds to microseconds so we can send them as ints.\n        const convertedTreeBaseDuration = Math.floor((treeBaseDuration || 0) * 1000);\n        pushOperation(constants[\"E\" /* TREE_OPERATION_UPDATE_TREE_BASE_DURATION */]);\n        pushOperation(id);\n        pushOperation(convertedTreeBaseDuration);\n      }\n\n      if (alternate == null || didFiberRender(alternate, fiber)) {\n        if (actualDuration != null) {\n          // The actual duration reported by React includes time spent working on children.\n          // This is useful information, but it's also useful to be able to exclude child durations.\n          // The frontend can't compute this, since the immediate children may have been filtered out.\n          // So we need to do this on the backend.\n          // Note that this calculated self duration is not the same thing as the base duration.\n          // The two are calculated differently (tree duration does not accumulate).\n          let selfDuration = actualDuration;\n          let child = fiber.child;\n\n          while (child !== null) {\n            selfDuration -= child.actualDuration || 0;\n            child = child.sibling;\n          } // If profiling is active, store durations for elements that were rendered during the commit.\n          // Note that we should do this for any fiber we performed work on, regardless of its actualDuration value.\n          // In some cases actualDuration might be 0 for fibers we worked on (particularly if we're using Date.now)\n          // In other cases (e.g. Memo) actualDuration might be greater than 0 even if we \"bailed out\".\n\n\n          const metadata = currentCommitProfilingMetadata;\n          metadata.durations.push(id, actualDuration, selfDuration);\n          metadata.maxActualDuration = Math.max(metadata.maxActualDuration, actualDuration);\n\n          if (recordChangeDescriptions) {\n            const changeDescription = getChangeDescription(alternate, fiber);\n\n            if (changeDescription !== null) {\n              if (metadata.changeDescriptions !== null) {\n                metadata.changeDescriptions.set(id, changeDescription);\n              }\n            }\n\n            updateContextsForFiber(fiber);\n          }\n        }\n      }\n    }\n  }\n\n  function recordResetChildren(fiber, childSet) {\n    if (constants[\"G\" /* __DEBUG__ */]) {\n      debug('recordResetChildren()', childSet, fiber);\n    } // The frontend only really cares about the displayName, key, and children.\n    // The first two don't really change, so we are only concerned with the order of children here.\n    // This is trickier than a simple comparison though, since certain types of fibers are filtered.\n\n\n    const nextChildren = []; // This is a naive implementation that shallowly recourses children.\n    // We might want to revisit this if it proves to be too inefficient.\n\n    let child = childSet;\n\n    while (child !== null) {\n      findReorderedChildrenRecursively(child, nextChildren);\n      child = child.sibling;\n    }\n\n    const numChildren = nextChildren.length;\n\n    if (numChildren < 2) {\n      // No need to reorder.\n      return;\n    }\n\n    pushOperation(constants[\"B\" /* TREE_OPERATION_REORDER_CHILDREN */]);\n    pushOperation(getFiberIDThrows(fiber));\n    pushOperation(numChildren);\n\n    for (let i = 0; i < nextChildren.length; i++) {\n      pushOperation(nextChildren[i]);\n    }\n  }\n\n  function findReorderedChildrenRecursively(fiber, nextChildren) {\n    if (!shouldFilterFiber(fiber)) {\n      nextChildren.push(getFiberIDThrows(fiber));\n    } else {\n      let child = fiber.child;\n      const isTimedOutSuspense = fiber.tag === SuspenseComponent && fiber.memoizedState !== null;\n\n      if (isTimedOutSuspense) {\n        // Special case: if Suspense mounts in a timed-out state,\n        // get the fallback child from the inner fragment,\n        // and skip over the primary child.\n        const primaryChildFragment = fiber.child;\n        const fallbackChildFragment = primaryChildFragment ? primaryChildFragment.sibling : null;\n        const fallbackChild = fallbackChildFragment ? fallbackChildFragment.child : null;\n\n        if (fallbackChild !== null) {\n          child = fallbackChild;\n        }\n      }\n\n      while (child !== null) {\n        findReorderedChildrenRecursively(child, nextChildren);\n        child = child.sibling;\n      }\n    }\n  } // Returns whether closest unfiltered fiber parent needs to reset its child list.\n\n\n  function updateFiberRecursively(nextFiber, prevFiber, parentFiber, traceNearestHostComponentUpdate) {\n    const id = getOrGenerateFiberID(nextFiber);\n\n    if (constants[\"G\" /* __DEBUG__ */]) {\n      debug('updateFiberRecursively()', nextFiber, parentFiber);\n    }\n\n    if (traceUpdatesEnabled) {\n      const elementType = getElementTypeForFiber(nextFiber);\n\n      if (traceNearestHostComponentUpdate) {\n        // If an ancestor updated, we should mark the nearest host nodes for highlighting.\n        if (elementType === types[\"i\" /* ElementTypeHostComponent */]) {\n          traceUpdatesForNodes.add(nextFiber.stateNode);\n          traceNearestHostComponentUpdate = false;\n        }\n      } else {\n        if (elementType === types[\"h\" /* ElementTypeFunction */] || elementType === types[\"e\" /* ElementTypeClass */] || elementType === types[\"f\" /* ElementTypeContext */] || elementType === types[\"j\" /* ElementTypeMemo */] || elementType === types[\"g\" /* ElementTypeForwardRef */]) {\n          // Otherwise if this is a traced ancestor, flag for the nearest host descendant(s).\n          traceNearestHostComponentUpdate = didFiberRender(prevFiber, nextFiber);\n        }\n      }\n    }\n\n    if (mostRecentlyInspectedElement !== null && mostRecentlyInspectedElement.id === id && didFiberRender(prevFiber, nextFiber)) {\n      // If this Fiber has updated, clear cached inspected data.\n      // If it is inspected again, it may need to be re-run to obtain updated hooks values.\n      hasElementUpdatedSinceLastInspected = true;\n    }\n\n    const shouldIncludeInTree = !shouldFilterFiber(nextFiber);\n    const isSuspense = nextFiber.tag === SuspenseComponent;\n    let shouldResetChildren = false; // The behavior of timed-out Suspense trees is unique.\n    // Rather than unmount the timed out content (and possibly lose important state),\n    // React re-parents this content within a hidden Fragment while the fallback is showing.\n    // This behavior doesn't need to be observable in the DevTools though.\n    // It might even result in a bad user experience for e.g. node selection in the Elements panel.\n    // The easiest fix is to strip out the intermediate Fragment fibers,\n    // so the Elements panel and Profiler don't need to special case them.\n    // Suspense components only have a non-null memoizedState if they're timed-out.\n\n    const prevDidTimeout = isSuspense && prevFiber.memoizedState !== null;\n    const nextDidTimeOut = isSuspense && nextFiber.memoizedState !== null; // The logic below is inspired by the code paths in updateSuspenseComponent()\n    // inside ReactFiberBeginWork in the React source code.\n\n    if (prevDidTimeout && nextDidTimeOut) {\n      // Fallback -> Fallback:\n      // 1. Reconcile fallback set.\n      const nextFiberChild = nextFiber.child;\n      const nextFallbackChildSet = nextFiberChild ? nextFiberChild.sibling : null; // Note: We can't use nextFiber.child.sibling.alternate\n      // because the set is special and alternate may not exist.\n\n      const prevFiberChild = prevFiber.child;\n      const prevFallbackChildSet = prevFiberChild ? prevFiberChild.sibling : null;\n\n      if (nextFallbackChildSet != null && prevFallbackChildSet != null && updateFiberRecursively(nextFallbackChildSet, prevFallbackChildSet, nextFiber, traceNearestHostComponentUpdate)) {\n        shouldResetChildren = true;\n      }\n    } else if (prevDidTimeout && !nextDidTimeOut) {\n      // Fallback -> Primary:\n      // 1. Unmount fallback set\n      // Note: don't emulate fallback unmount because React actually did it.\n      // 2. Mount primary set\n      const nextPrimaryChildSet = nextFiber.child;\n\n      if (nextPrimaryChildSet !== null) {\n        mountFiberRecursively(nextPrimaryChildSet, shouldIncludeInTree ? nextFiber : parentFiber, true, traceNearestHostComponentUpdate);\n      }\n\n      shouldResetChildren = true;\n    } else if (!prevDidTimeout && nextDidTimeOut) {\n      // Primary -> Fallback:\n      // 1. Hide primary set\n      // This is not a real unmount, so it won't get reported by React.\n      // We need to manually walk the previous tree and record unmounts.\n      unmountFiberChildrenRecursively(prevFiber); // 2. Mount fallback set\n\n      const nextFiberChild = nextFiber.child;\n      const nextFallbackChildSet = nextFiberChild ? nextFiberChild.sibling : null;\n\n      if (nextFallbackChildSet != null) {\n        mountFiberRecursively(nextFallbackChildSet, shouldIncludeInTree ? nextFiber : parentFiber, true, traceNearestHostComponentUpdate);\n        shouldResetChildren = true;\n      }\n    } else {\n      // Common case: Primary -> Primary.\n      // This is the same code path as for non-Suspense fibers.\n      if (nextFiber.child !== prevFiber.child) {\n        // If the first child is different, we need to traverse them.\n        // Each next child will be either a new child (mount) or an alternate (update).\n        let nextChild = nextFiber.child;\n        let prevChildAtSameIndex = prevFiber.child;\n\n        while (nextChild) {\n          // We already know children will be referentially different because\n          // they are either new mounts or alternates of previous children.\n          // Schedule updates and mounts depending on whether alternates exist.\n          // We don't track deletions here because they are reported separately.\n          if (nextChild.alternate) {\n            const prevChild = nextChild.alternate;\n\n            if (updateFiberRecursively(nextChild, prevChild, shouldIncludeInTree ? nextFiber : parentFiber, traceNearestHostComponentUpdate)) {\n              // If a nested tree child order changed but it can't handle its own\n              // child order invalidation (e.g. because it's filtered out like host nodes),\n              // propagate the need to reset child order upwards to this Fiber.\n              shouldResetChildren = true;\n            } // However we also keep track if the order of the children matches\n            // the previous order. They are always different referentially, but\n            // if the instances line up conceptually we'll want to know that.\n\n\n            if (prevChild !== prevChildAtSameIndex) {\n              shouldResetChildren = true;\n            }\n          } else {\n            mountFiberRecursively(nextChild, shouldIncludeInTree ? nextFiber : parentFiber, false, traceNearestHostComponentUpdate);\n            shouldResetChildren = true;\n          } // Try the next child.\n\n\n          nextChild = nextChild.sibling; // Advance the pointer in the previous list so that we can\n          // keep comparing if they line up.\n\n          if (!shouldResetChildren && prevChildAtSameIndex !== null) {\n            prevChildAtSameIndex = prevChildAtSameIndex.sibling;\n          }\n        } // If we have no more children, but used to, they don't line up.\n\n\n        if (prevChildAtSameIndex !== null) {\n          shouldResetChildren = true;\n        }\n      } else {\n        if (traceUpdatesEnabled) {\n          // If we're tracing updates and we've bailed out before reaching a host node,\n          // we should fall back to recursively marking the nearest host descendants for highlight.\n          if (traceNearestHostComponentUpdate) {\n            const hostFibers = findAllCurrentHostFibers(getFiberIDThrows(nextFiber));\n            hostFibers.forEach(hostFiber => {\n              traceUpdatesForNodes.add(hostFiber.stateNode);\n            });\n          }\n        }\n      }\n    }\n\n    if (shouldIncludeInTree) {\n      const isProfilingSupported = nextFiber.hasOwnProperty('treeBaseDuration');\n\n      if (isProfilingSupported) {\n        recordProfilingDurations(nextFiber);\n      }\n    }\n\n    if (shouldResetChildren) {\n      // We need to crawl the subtree for closest non-filtered Fibers\n      // so that we can display them in a flat children set.\n      if (shouldIncludeInTree) {\n        // Normally, search for children from the rendered child.\n        let nextChildSet = nextFiber.child;\n\n        if (nextDidTimeOut) {\n          // Special case: timed-out Suspense renders the fallback set.\n          const nextFiberChild = nextFiber.child;\n          nextChildSet = nextFiberChild ? nextFiberChild.sibling : null;\n        }\n\n        if (nextChildSet != null) {\n          recordResetChildren(nextFiber, nextChildSet);\n        } // We've handled the child order change for this Fiber.\n        // Since it's included, there's no need to invalidate parent child order.\n\n\n        return false;\n      } else {\n        // Let the closest unfiltered parent Fiber reset its child order instead.\n        return true;\n      }\n    } else {\n      return false;\n    }\n  }\n\n  function cleanup() {// We don't patch any methods so there is no cleanup.\n  }\n\n  function rootSupportsProfiling(root) {\n    if (root.memoizedInteractions != null) {\n      // v16 builds include this field for the scheduler/tracing API.\n      return true;\n    } else if (root.current != null && root.current.hasOwnProperty('treeBaseDuration')) {\n      // The scheduler/tracing API was removed in v17 though\n      // so we need to check a non-root Fiber.\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  function flushInitialOperations() {\n    const localPendingOperationsQueue = pendingOperationsQueue;\n    pendingOperationsQueue = null;\n\n    if (localPendingOperationsQueue !== null && localPendingOperationsQueue.length > 0) {\n      // We may have already queued up some operations before the frontend connected\n      // If so, let the frontend know about them.\n      localPendingOperationsQueue.forEach(operations => {\n        hook.emit('operations', operations);\n      });\n    } else {\n      // Before the traversals, remember to start tracking\n      // our path in case we have selection to restore.\n      if (trackedPath !== null) {\n        mightBeOnTrackedPath = true;\n      } // If we have not been profiling, then we can just walk the tree and build up its current state as-is.\n\n\n      hook.getFiberRoots(rendererID).forEach(root => {\n        currentRootID = getOrGenerateFiberID(root.current);\n        setRootPseudoKey(currentRootID, root.current); // Handle multi-renderer edge-case where only some v16 renderers support profiling.\n\n        if (isProfiling && rootSupportsProfiling(root)) {\n          // If profiling is active, store commit time and duration.\n          // The frontend may request this information after profiling has stopped.\n          currentCommitProfilingMetadata = {\n            changeDescriptions: recordChangeDescriptions ? new Map() : null,\n            durations: [],\n            commitTime: renderer_getCurrentTime() - profilingStartTime,\n            maxActualDuration: 0,\n            priorityLevel: null,\n            updaters: getUpdatersList(root),\n            effectDuration: null,\n            passiveEffectDuration: null\n          };\n        }\n\n        mountFiberRecursively(root.current, null, false, false);\n        flushPendingEvents(root);\n        currentRootID = -1;\n      });\n    }\n  }\n\n  function getUpdatersList(root) {\n    return root.memoizedUpdaters != null ? Array.from(root.memoizedUpdaters).filter(fiber => getFiberIDUnsafe(fiber) !== null).map(fiberToSerializedElement) : null;\n  }\n\n  function handleCommitFiberUnmount(fiber) {\n    // If the untrackFiberSet already has the unmounted Fiber, this means we've already\n    // recordedUnmount, so we don't need to do it again. If we don't do this, we might\n    // end up double-deleting Fibers in some cases (like Legacy Suspense).\n    if (!untrackFibersSet.has(fiber)) {\n      // This is not recursive.\n      // We can't traverse fibers after unmounting so instead\n      // we rely on React telling us about each unmount.\n      recordUnmount(fiber, false);\n    }\n  }\n\n  function handlePostCommitFiberRoot(root) {\n    if (isProfiling && rootSupportsProfiling(root)) {\n      if (currentCommitProfilingMetadata !== null) {\n        const {\n          effectDuration,\n          passiveEffectDuration\n        } = Object(backend_utils[\"h\" /* getEffectDurations */])(root); // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n        currentCommitProfilingMetadata.effectDuration = effectDuration; // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n        currentCommitProfilingMetadata.passiveEffectDuration = passiveEffectDuration;\n      }\n    }\n  }\n\n  function handleCommitFiberRoot(root, priorityLevel) {\n    const current = root.current;\n    const alternate = current.alternate; // Flush any pending Fibers that we are untracking before processing the new commit.\n    // If we don't do this, we might end up double-deleting Fibers in some cases (like Legacy Suspense).\n\n    untrackFibers();\n    currentRootID = getOrGenerateFiberID(current); // Before the traversals, remember to start tracking\n    // our path in case we have selection to restore.\n\n    if (trackedPath !== null) {\n      mightBeOnTrackedPath = true;\n    }\n\n    if (traceUpdatesEnabled) {\n      traceUpdatesForNodes.clear();\n    } // Handle multi-renderer edge-case where only some v16 renderers support profiling.\n\n\n    const isProfilingSupported = rootSupportsProfiling(root);\n\n    if (isProfiling && isProfilingSupported) {\n      // If profiling is active, store commit time and duration.\n      // The frontend may request this information after profiling has stopped.\n      currentCommitProfilingMetadata = {\n        changeDescriptions: recordChangeDescriptions ? new Map() : null,\n        durations: [],\n        commitTime: renderer_getCurrentTime() - profilingStartTime,\n        maxActualDuration: 0,\n        priorityLevel: priorityLevel == null ? null : formatPriorityLevel(priorityLevel),\n        updaters: getUpdatersList(root),\n        // Initialize to null; if new enough React version is running,\n        // these values will be read during separate handlePostCommitFiberRoot() call.\n        effectDuration: null,\n        passiveEffectDuration: null\n      };\n    }\n\n    if (alternate) {\n      // TODO: relying on this seems a bit fishy.\n      const wasMounted = alternate.memoizedState != null && alternate.memoizedState.element != null && // A dehydrated root is not considered mounted\n      alternate.memoizedState.isDehydrated !== true;\n      const isMounted = current.memoizedState != null && current.memoizedState.element != null && // A dehydrated root is not considered mounted\n      current.memoizedState.isDehydrated !== true;\n\n      if (!wasMounted && isMounted) {\n        // Mount a new root.\n        setRootPseudoKey(currentRootID, current);\n        mountFiberRecursively(current, null, false, false);\n      } else if (wasMounted && isMounted) {\n        // Update an existing root.\n        updateFiberRecursively(current, alternate, null, false);\n      } else if (wasMounted && !isMounted) {\n        // Unmount an existing root.\n        removeRootPseudoKey(currentRootID);\n        recordUnmount(current, false);\n      }\n    } else {\n      // Mount a new root.\n      setRootPseudoKey(currentRootID, current);\n      mountFiberRecursively(current, null, false, false);\n    }\n\n    if (isProfiling && isProfilingSupported) {\n      if (!shouldBailoutWithPendingOperations()) {\n        const commitProfilingMetadata = rootToCommitProfilingMetadataMap.get(currentRootID);\n\n        if (commitProfilingMetadata != null) {\n          commitProfilingMetadata.push(currentCommitProfilingMetadata);\n        } else {\n          rootToCommitProfilingMetadataMap.set(currentRootID, [currentCommitProfilingMetadata]);\n        }\n      }\n    } // We're done here.\n\n\n    flushPendingEvents(root);\n\n    if (traceUpdatesEnabled) {\n      hook.emit('traceUpdates', traceUpdatesForNodes);\n    }\n\n    currentRootID = -1;\n  }\n\n  function findAllCurrentHostFibers(id) {\n    const fibers = [];\n    const fiber = findCurrentFiberUsingSlowPathById(id);\n\n    if (!fiber) {\n      return fibers;\n    } // Next we'll drill down this component to find all HostComponent/Text.\n\n\n    let node = fiber;\n\n    while (true) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        fibers.push(node);\n      } else if (node.child) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n\n      if (node === fiber) {\n        return fibers;\n      }\n\n      while (!node.sibling) {\n        if (!node.return || node.return === fiber) {\n          return fibers;\n        }\n\n        node = node.return;\n      }\n\n      node.sibling.return = node.return;\n      node = node.sibling;\n    } // Flow needs the return here, but ESLint complains about it.\n    // eslint-disable-next-line no-unreachable\n\n\n    return fibers;\n  }\n\n  function findNativeNodesForFiberID(id) {\n    try {\n      let fiber = findCurrentFiberUsingSlowPathById(id);\n\n      if (fiber === null) {\n        return null;\n      } // Special case for a timed-out Suspense.\n\n\n      const isTimedOutSuspense = fiber.tag === SuspenseComponent && fiber.memoizedState !== null;\n\n      if (isTimedOutSuspense) {\n        // A timed-out Suspense's findDOMNode is useless.\n        // Try our best to find the fallback directly.\n        const maybeFallbackFiber = fiber.child && fiber.child.sibling;\n\n        if (maybeFallbackFiber != null) {\n          fiber = maybeFallbackFiber;\n        }\n      }\n\n      const hostFibers = findAllCurrentHostFibers(id);\n      return hostFibers.map(hostFiber => hostFiber.stateNode).filter(Boolean);\n    } catch (err) {\n      // The fiber might have unmounted by now.\n      return null;\n    }\n  }\n\n  function getDisplayNameForFiberID(id) {\n    const fiber = idToArbitraryFiberMap.get(id);\n    return fiber != null ? getDisplayNameForFiber(fiber) : null;\n  }\n\n  function getFiberForNative(hostInstance) {\n    return renderer.findFiberByHostInstance(hostInstance);\n  }\n\n  function getFiberIDForNative(hostInstance, findNearestUnfilteredAncestor = false) {\n    let fiber = renderer.findFiberByHostInstance(hostInstance);\n\n    if (fiber != null) {\n      if (findNearestUnfilteredAncestor) {\n        while (fiber !== null && shouldFilterFiber(fiber)) {\n          fiber = fiber.return;\n        }\n      }\n\n      return getFiberIDThrows(fiber);\n    }\n\n    return null;\n  } // This function is copied from React and should be kept in sync:\n  // https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberTreeReflection.js\n\n\n  function assertIsMounted(fiber) {\n    if (getNearestMountedFiber(fiber) !== fiber) {\n      throw new Error('Unable to find node on an unmounted component.');\n    }\n  } // This function is copied from React and should be kept in sync:\n  // https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberTreeReflection.js\n\n\n  function getNearestMountedFiber(fiber) {\n    let node = fiber;\n    let nearestMounted = fiber;\n\n    if (!fiber.alternate) {\n      // If there is no alternate, this might be a new tree that isn't inserted\n      // yet. If it is, then it will have a pending insertion effect on it.\n      let nextNode = node;\n\n      do {\n        node = nextNode;\n\n        if ((node.flags & (Placement | Hydrating)) !== NoFlags) {\n          // This is an insertion or in-progress hydration. The nearest possible\n          // mounted fiber is the parent but we need to continue to figure out\n          // if that one is still mounted.\n          nearestMounted = node.return;\n        } // $FlowFixMe[incompatible-type] we bail out when we get a null\n\n\n        nextNode = node.return;\n      } while (nextNode);\n    } else {\n      while (node.return) {\n        node = node.return;\n      }\n    }\n\n    if (node.tag === HostRoot) {\n      // TODO: Check if this was a nested HostRoot when used with\n      // renderContainerIntoSubtree.\n      return nearestMounted;\n    } // If we didn't hit the root, that means that we're in an disconnected tree\n    // that has been unmounted.\n\n\n    return null;\n  } // This function is copied from React and should be kept in sync:\n  // https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberTreeReflection.js\n  // It would be nice if we updated React to inject this function directly (vs just indirectly via findDOMNode).\n  // BEGIN copied code\n\n\n  function findCurrentFiberUsingSlowPathById(id) {\n    const fiber = idToArbitraryFiberMap.get(id);\n\n    if (fiber == null) {\n      console.warn(`Could not find Fiber with id \"${id}\"`);\n      return null;\n    }\n\n    const alternate = fiber.alternate;\n\n    if (!alternate) {\n      // If there is no alternate, then we only need to check if it is mounted.\n      const nearestMounted = getNearestMountedFiber(fiber);\n\n      if (nearestMounted === null) {\n        throw new Error('Unable to find node on an unmounted component.');\n      }\n\n      if (nearestMounted !== fiber) {\n        return null;\n      }\n\n      return fiber;\n    } // If we have two possible branches, we'll walk backwards up to the root\n    // to see what path the root points to. On the way we may hit one of the\n    // special cases and we'll deal with them.\n\n\n    let a = fiber;\n    let b = alternate;\n\n    while (true) {\n      const parentA = a.return;\n\n      if (parentA === null) {\n        // We're at the root.\n        break;\n      }\n\n      const parentB = parentA.alternate;\n\n      if (parentB === null) {\n        // There is no alternate. This is an unusual case. Currently, it only\n        // happens when a Suspense component is hidden. An extra fragment fiber\n        // is inserted in between the Suspense fiber and its children. Skip\n        // over this extra fragment fiber and proceed to the next parent.\n        const nextParent = parentA.return;\n\n        if (nextParent !== null) {\n          a = b = nextParent;\n          continue;\n        } // If there's no parent, we're at the root.\n\n\n        break;\n      } // If both copies of the parent fiber point to the same child, we can\n      // assume that the child is current. This happens when we bailout on low\n      // priority: the bailed out fiber's child reuses the current child.\n\n\n      if (parentA.child === parentB.child) {\n        let child = parentA.child;\n\n        while (child) {\n          if (child === a) {\n            // We've determined that A is the current branch.\n            assertIsMounted(parentA);\n            return fiber;\n          }\n\n          if (child === b) {\n            // We've determined that B is the current branch.\n            assertIsMounted(parentA);\n            return alternate;\n          }\n\n          child = child.sibling;\n        } // We should never have an alternate for any mounting node. So the only\n        // way this could possibly happen is if this was unmounted, if at all.\n\n\n        throw new Error('Unable to find node on an unmounted component.');\n      }\n\n      if (a.return !== b.return) {\n        // The return pointer of A and the return pointer of B point to different\n        // fibers. We assume that return pointers never criss-cross, so A must\n        // belong to the child set of A.return, and B must belong to the child\n        // set of B.return.\n        a = parentA;\n        b = parentB;\n      } else {\n        // The return pointers point to the same fiber. We'll have to use the\n        // default, slow path: scan the child sets of each parent alternate to see\n        // which child belongs to which set.\n        //\n        // Search parent A's child set\n        let didFindChild = false;\n        let child = parentA.child;\n\n        while (child) {\n          if (child === a) {\n            didFindChild = true;\n            a = parentA;\n            b = parentB;\n            break;\n          }\n\n          if (child === b) {\n            didFindChild = true;\n            b = parentA;\n            a = parentB;\n            break;\n          }\n\n          child = child.sibling;\n        }\n\n        if (!didFindChild) {\n          // Search parent B's child set\n          child = parentB.child;\n\n          while (child) {\n            if (child === a) {\n              didFindChild = true;\n              a = parentB;\n              b = parentA;\n              break;\n            }\n\n            if (child === b) {\n              didFindChild = true;\n              b = parentB;\n              a = parentA;\n              break;\n            }\n\n            child = child.sibling;\n          }\n\n          if (!didFindChild) {\n            throw new Error('Child was not found in either parent set. This indicates a bug ' + 'in React related to the return pointer. Please file an issue.');\n          }\n        }\n      }\n\n      if (a.alternate !== b) {\n        throw new Error(\"Return fibers should always be each others' alternates. \" + 'This error is likely caused by a bug in React. Please file an issue.');\n      }\n    } // If the root is not a host container, we're in a disconnected tree. I.e.\n    // unmounted.\n\n\n    if (a.tag !== HostRoot) {\n      throw new Error('Unable to find node on an unmounted component.');\n    }\n\n    if (a.stateNode.current === a) {\n      // We've determined that A is the current branch.\n      return fiber;\n    } // Otherwise B has to be current branch.\n\n\n    return alternate;\n  } // END copied code\n\n\n  function prepareViewAttributeSource(id, path) {\n    if (isMostRecentlyInspectedElement(id)) {\n      window.$attribute = Object(utils[\"n\" /* getInObject */])(mostRecentlyInspectedElement, path);\n    }\n  }\n\n  function prepareViewElementSource(id) {\n    const fiber = idToArbitraryFiberMap.get(id);\n\n    if (fiber == null) {\n      console.warn(`Could not find Fiber with id \"${id}\"`);\n      return;\n    }\n\n    const {\n      elementType,\n      tag,\n      type\n    } = fiber;\n\n    switch (tag) {\n      case ClassComponent:\n      case IncompleteClassComponent:\n      case IndeterminateComponent:\n      case FunctionComponent:\n        global.$type = type;\n        break;\n\n      case ForwardRef:\n        global.$type = type.render;\n        break;\n\n      case MemoComponent:\n      case SimpleMemoComponent:\n        global.$type = elementType != null && elementType.type != null ? elementType.type : type;\n        break;\n\n      default:\n        global.$type = null;\n        break;\n    }\n  }\n\n  function fiberToSerializedElement(fiber) {\n    return {\n      displayName: getDisplayNameForFiber(fiber) || 'Anonymous',\n      id: getFiberIDThrows(fiber),\n      key: fiber.key,\n      type: getElementTypeForFiber(fiber)\n    };\n  }\n\n  function getOwnersList(id) {\n    const fiber = findCurrentFiberUsingSlowPathById(id);\n\n    if (fiber == null) {\n      return null;\n    }\n\n    const {\n      _debugOwner\n    } = fiber;\n    const owners = [fiberToSerializedElement(fiber)];\n\n    if (_debugOwner) {\n      let owner = _debugOwner;\n\n      while (owner !== null) {\n        owners.unshift(fiberToSerializedElement(owner));\n        owner = owner._debugOwner || null;\n      }\n    }\n\n    return owners;\n  } // Fast path props lookup for React Native style editor.\n  // Could use inspectElementRaw() but that would require shallow rendering hooks components,\n  // and could also mess with memoization.\n\n\n  function getInstanceAndStyle(id) {\n    let instance = null;\n    let style = null;\n    const fiber = findCurrentFiberUsingSlowPathById(id);\n\n    if (fiber !== null) {\n      instance = fiber.stateNode;\n\n      if (fiber.memoizedProps !== null) {\n        style = fiber.memoizedProps.style;\n      }\n    }\n\n    return {\n      instance,\n      style\n    };\n  }\n\n  function isErrorBoundary(fiber) {\n    const {\n      tag,\n      type\n    } = fiber;\n\n    switch (tag) {\n      case ClassComponent:\n      case IncompleteClassComponent:\n        const instance = fiber.stateNode;\n        return typeof type.getDerivedStateFromError === 'function' || instance !== null && typeof instance.componentDidCatch === 'function';\n\n      default:\n        return false;\n    }\n  }\n\n  function getNearestErrorBoundaryID(fiber) {\n    let parent = fiber.return;\n\n    while (parent !== null) {\n      if (isErrorBoundary(parent)) {\n        return getFiberIDUnsafe(parent);\n      }\n\n      parent = parent.return;\n    }\n\n    return null;\n  }\n\n  function inspectElementRaw(id) {\n    const fiber = findCurrentFiberUsingSlowPathById(id);\n\n    if (fiber == null) {\n      return null;\n    }\n\n    const {\n      _debugOwner,\n      _debugSource,\n      stateNode,\n      key,\n      memoizedProps,\n      memoizedState,\n      dependencies,\n      tag,\n      type\n    } = fiber;\n    const elementType = getElementTypeForFiber(fiber);\n    const usesHooks = (tag === FunctionComponent || tag === SimpleMemoComponent || tag === ForwardRef) && (!!memoizedState || !!dependencies); // TODO Show custom UI for Cache like we do for Suspense\n    // For now, just hide state data entirely since it's not meant to be inspected.\n\n    const showState = !usesHooks && tag !== CacheComponent;\n    const typeSymbol = getTypeSymbol(type);\n    let canViewSource = false;\n    let context = null;\n\n    if (tag === ClassComponent || tag === FunctionComponent || tag === IncompleteClassComponent || tag === IndeterminateComponent || tag === MemoComponent || tag === ForwardRef || tag === SimpleMemoComponent) {\n      canViewSource = true;\n\n      if (stateNode && stateNode.context != null) {\n        // Don't show an empty context object for class components that don't use the context API.\n        const shouldHideContext = elementType === types[\"e\" /* ElementTypeClass */] && !(type.contextTypes || type.contextType);\n\n        if (!shouldHideContext) {\n          context = stateNode.context;\n        }\n      }\n    } else if (typeSymbol === ReactSymbols[\"c\" /* CONTEXT_NUMBER */] || typeSymbol === ReactSymbols[\"d\" /* CONTEXT_SYMBOL_STRING */]) {\n      // 16.3-16.5 read from \"type\" because the Consumer is the actual context object.\n      // 16.6+ should read from \"type._context\" because Consumer can be different (in DEV).\n      // NOTE Keep in sync with getDisplayNameForFiber()\n      const consumerResolvedContext = type._context || type; // Global context value.\n\n      context = consumerResolvedContext._currentValue || null; // Look for overridden value.\n\n      let current = fiber.return;\n\n      while (current !== null) {\n        const currentType = current.type;\n        const currentTypeSymbol = getTypeSymbol(currentType);\n\n        if (currentTypeSymbol === ReactSymbols[\"n\" /* PROVIDER_NUMBER */] || currentTypeSymbol === ReactSymbols[\"o\" /* PROVIDER_SYMBOL_STRING */]) {\n          // 16.3.0 exposed the context object as \"context\"\n          // PR #12501 changed it to \"_context\" for 16.3.1+\n          // NOTE Keep in sync with getDisplayNameForFiber()\n          const providerResolvedContext = currentType._context || currentType.context;\n\n          if (providerResolvedContext === consumerResolvedContext) {\n            context = current.memoizedProps.value;\n            break;\n          }\n        }\n\n        current = current.return;\n      }\n    }\n\n    let hasLegacyContext = false;\n\n    if (context !== null) {\n      hasLegacyContext = !!type.contextTypes; // To simplify hydration and display logic for context, wrap in a value object.\n      // Otherwise simple values (e.g. strings, booleans) become harder to handle.\n\n      context = {\n        value: context\n      };\n    }\n\n    let owners = null;\n\n    if (_debugOwner) {\n      owners = [];\n      let owner = _debugOwner;\n\n      while (owner !== null) {\n        owners.push(fiberToSerializedElement(owner));\n        owner = owner._debugOwner || null;\n      }\n    }\n\n    const isTimedOutSuspense = tag === SuspenseComponent && memoizedState !== null;\n    let hooks = null;\n\n    if (usesHooks) {\n      const originalConsoleMethods = {}; // Temporarily disable all console logging before re-running the hook.\n\n      for (const method in console) {\n        try {\n          originalConsoleMethods[method] = console[method]; // $FlowFixMe[prop-missing]\n\n          console[method] = () => {};\n        } catch (error) {}\n      }\n\n      try {\n        hooks = inspectHooksOfFiber(fiber, renderer.currentDispatcherRef, true // Include source location info for hooks\n        );\n      } finally {\n        // Restore original console functionality.\n        for (const method in originalConsoleMethods) {\n          try {\n            // $FlowFixMe[prop-missing]\n            console[method] = originalConsoleMethods[method];\n          } catch (error) {}\n        }\n      }\n    }\n\n    let rootType = null;\n    let current = fiber;\n\n    while (current.return !== null) {\n      current = current.return;\n    }\n\n    const fiberRoot = current.stateNode;\n\n    if (fiberRoot != null && fiberRoot._debugRootType !== null) {\n      rootType = fiberRoot._debugRootType;\n    }\n\n    const errors = fiberIDToErrorsMap.get(id) || new Map();\n    const warnings = fiberIDToWarningsMap.get(id) || new Map();\n    const isErrored = (fiber.flags & DidCapture) !== NoFlags || forceErrorForFiberIDs.get(id) === true;\n    let targetErrorBoundaryID;\n\n    if (isErrorBoundary(fiber)) {\n      // if the current inspected element is an error boundary,\n      // either that we want to use it to toggle off error state\n      // or that we allow to force error state on it if it's within another\n      // error boundary\n      targetErrorBoundaryID = isErrored ? id : getNearestErrorBoundaryID(fiber);\n    } else {\n      targetErrorBoundaryID = getNearestErrorBoundaryID(fiber);\n    }\n\n    const plugins = {\n      stylex: null\n    };\n\n    if (DevToolsFeatureFlags_default[\"f\" /* enableStyleXFeatures */]) {\n      if (memoizedProps.hasOwnProperty('xstyle')) {\n        plugins.stylex = getStyleXData(memoizedProps.xstyle);\n      }\n    }\n\n    return {\n      id,\n      // Does the current renderer support editable hooks and function props?\n      canEditHooks: typeof overrideHookState === 'function',\n      canEditFunctionProps: typeof overrideProps === 'function',\n      // Does the current renderer support advanced editing interface?\n      canEditHooksAndDeletePaths: typeof overrideHookStateDeletePath === 'function',\n      canEditHooksAndRenamePaths: typeof overrideHookStateRenamePath === 'function',\n      canEditFunctionPropsDeletePaths: typeof overridePropsDeletePath === 'function',\n      canEditFunctionPropsRenamePaths: typeof overridePropsRenamePath === 'function',\n      canToggleError: supportsTogglingError && targetErrorBoundaryID != null,\n      // Is this error boundary in error state.\n      isErrored,\n      targetErrorBoundaryID,\n      canToggleSuspense: supportsTogglingSuspense && ( // If it's showing the real content, we can always flip fallback.\n      !isTimedOutSuspense || // If it's showing fallback because we previously forced it to,\n      // allow toggling it back to remove the fallback override.\n      forceFallbackForSuspenseIDs.has(id)),\n      // Can view component source location.\n      canViewSource,\n      // Does the component have legacy context attached to it.\n      hasLegacyContext,\n      key: key != null ? key : null,\n      displayName: getDisplayNameForFiber(fiber),\n      type: elementType,\n      // Inspectable properties.\n      // TODO Review sanitization approach for the below inspectable values.\n      context,\n      hooks,\n      props: memoizedProps,\n      state: showState ? memoizedState : null,\n      errors: Array.from(errors.entries()),\n      warnings: Array.from(warnings.entries()),\n      // List of owners\n      owners,\n      // Location of component in source code.\n      source: _debugSource || null,\n      rootType,\n      rendererPackageName: renderer.rendererPackageName,\n      rendererVersion: renderer.version,\n      plugins\n    };\n  }\n\n  let mostRecentlyInspectedElement = null;\n  let hasElementUpdatedSinceLastInspected = false;\n  let currentlyInspectedPaths = {};\n\n  function isMostRecentlyInspectedElement(id) {\n    return mostRecentlyInspectedElement !== null && mostRecentlyInspectedElement.id === id;\n  }\n\n  function isMostRecentlyInspectedElementCurrent(id) {\n    return isMostRecentlyInspectedElement(id) && !hasElementUpdatedSinceLastInspected;\n  } // Track the intersection of currently inspected paths,\n  // so that we can send their data along if the element is re-rendered.\n\n\n  function mergeInspectedPaths(path) {\n    let current = currentlyInspectedPaths;\n    path.forEach(key => {\n      if (!current[key]) {\n        current[key] = {};\n      }\n\n      current = current[key];\n    });\n  }\n\n  function createIsPathAllowed(key, secondaryCategory) {\n    // This function helps prevent previously-inspected paths from being dehydrated in updates.\n    // This is important to avoid a bad user experience where expanded toggles collapse on update.\n    return function isPathAllowed(path) {\n      switch (secondaryCategory) {\n        case 'hooks':\n          if (path.length === 1) {\n            // Never dehydrate the \"hooks\" object at the top levels.\n            return true;\n          }\n\n          if (path[path.length - 2] === 'hookSource' && path[path.length - 1] === 'fileName') {\n            // It's important to preserve the full file name (URL) for hook sources\n            // in case the user has enabled the named hooks feature.\n            // Otherwise the frontend may end up with a partial URL which it can't load.\n            return true;\n          }\n\n          if (path[path.length - 1] === 'subHooks' || path[path.length - 2] === 'subHooks') {\n            // Dehydrating the 'subHooks' property makes the HooksTree UI a lot more complicated,\n            // so it's easiest for now if we just don't break on this boundary.\n            // We can always dehydrate a level deeper (in the value object).\n            return true;\n          }\n\n          break;\n\n        default:\n          break;\n      }\n\n      let current = key === null ? currentlyInspectedPaths : currentlyInspectedPaths[key];\n\n      if (!current) {\n        return false;\n      }\n\n      for (let i = 0; i < path.length; i++) {\n        current = current[path[i]];\n\n        if (!current) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n  }\n\n  function updateSelectedElement(inspectedElement) {\n    const {\n      hooks,\n      id,\n      props\n    } = inspectedElement;\n    const fiber = idToArbitraryFiberMap.get(id);\n\n    if (fiber == null) {\n      console.warn(`Could not find Fiber with id \"${id}\"`);\n      return;\n    }\n\n    const {\n      elementType,\n      stateNode,\n      tag,\n      type\n    } = fiber;\n\n    switch (tag) {\n      case ClassComponent:\n      case IncompleteClassComponent:\n      case IndeterminateComponent:\n        global.$r = stateNode;\n        break;\n\n      case FunctionComponent:\n        global.$r = {\n          hooks,\n          props,\n          type\n        };\n        break;\n\n      case ForwardRef:\n        global.$r = {\n          hooks,\n          props,\n          type: type.render\n        };\n        break;\n\n      case MemoComponent:\n      case SimpleMemoComponent:\n        global.$r = {\n          hooks,\n          props,\n          type: elementType != null && elementType.type != null ? elementType.type : type\n        };\n        break;\n\n      default:\n        global.$r = null;\n        break;\n    }\n  }\n\n  function storeAsGlobal(id, path, count) {\n    if (isMostRecentlyInspectedElement(id)) {\n      const value = Object(utils[\"n\" /* getInObject */])(mostRecentlyInspectedElement, path);\n      const key = `$reactTemp${count}`;\n      window[key] = value;\n      console.log(key);\n      console.log(value);\n    }\n  }\n\n  function copyElementPath(id, path) {\n    if (isMostRecentlyInspectedElement(id)) {\n      Object(backend_utils[\"b\" /* copyToClipboard */])(Object(utils[\"n\" /* getInObject */])(mostRecentlyInspectedElement, path));\n    }\n  }\n\n  function inspectElement(requestID, id, path, forceFullData) {\n    if (path !== null) {\n      mergeInspectedPaths(path);\n    }\n\n    if (isMostRecentlyInspectedElement(id) && !forceFullData) {\n      if (!hasElementUpdatedSinceLastInspected) {\n        if (path !== null) {\n          let secondaryCategory = null;\n\n          if (path[0] === 'hooks') {\n            secondaryCategory = 'hooks';\n          } // If this element has not been updated since it was last inspected,\n          // we can just return the subset of data in the newly-inspected path.\n\n\n          return {\n            id,\n            responseID: requestID,\n            type: 'hydrated-path',\n            path,\n            value: Object(backend_utils[\"a\" /* cleanForBridge */])(Object(utils[\"n\" /* getInObject */])(mostRecentlyInspectedElement, path), createIsPathAllowed(null, secondaryCategory), path)\n          };\n        } else {\n          // If this element has not been updated since it was last inspected, we don't need to return it.\n          // Instead we can just return the ID to indicate that it has not changed.\n          return {\n            id,\n            responseID: requestID,\n            type: 'no-change'\n          };\n        }\n      }\n    } else {\n      currentlyInspectedPaths = {};\n    }\n\n    hasElementUpdatedSinceLastInspected = false;\n\n    try {\n      mostRecentlyInspectedElement = inspectElementRaw(id);\n    } catch (error) {\n      // the error name is synced with ReactDebugHooks\n      if (error.name === 'ReactDebugToolsRenderError') {\n        let message = 'Error rendering inspected element.';\n        let stack; // Log error & cause for user to debug\n\n        console.error(message + '\\n\\n', error);\n\n        if (error.cause != null) {\n          const fiber = findCurrentFiberUsingSlowPathById(id);\n          const componentName = fiber != null ? getDisplayNameForFiber(fiber) : null;\n          console.error('React DevTools encountered an error while trying to inspect hooks. ' + 'This is most likely caused by an error in current inspected component' + (componentName != null ? `: \"${componentName}\".` : '.') + '\\nThe error thrown in the component is: \\n\\n', error.cause);\n\n          if (error.cause instanceof Error) {\n            message = error.cause.message || message;\n            stack = error.cause.stack;\n          }\n        }\n\n        return {\n          type: 'error',\n          errorType: 'user',\n          id,\n          responseID: requestID,\n          message,\n          stack\n        };\n      } // the error name is synced with ReactDebugHooks\n\n\n      if (error.name === 'ReactDebugToolsUnsupportedHookError') {\n        return {\n          type: 'error',\n          errorType: 'unknown-hook',\n          id,\n          responseID: requestID,\n          message: 'Unsupported hook in the react-debug-tools package: ' + error.message\n        };\n      } // Log Uncaught Error\n\n\n      console.error('Error inspecting element.\\n\\n', error);\n      return {\n        type: 'error',\n        errorType: 'uncaught',\n        id,\n        responseID: requestID,\n        message: error.message,\n        stack: error.stack\n      };\n    }\n\n    if (mostRecentlyInspectedElement === null) {\n      return {\n        id,\n        responseID: requestID,\n        type: 'not-found'\n      };\n    } // Any time an inspected element has an update,\n    // we should update the selected $r value as wel.\n    // Do this before dehydration (cleanForBridge).\n\n\n    updateSelectedElement(mostRecentlyInspectedElement); // Clone before cleaning so that we preserve the full data.\n    // This will enable us to send patches without re-inspecting if hydrated paths are requested.\n    // (Reducing how often we shallow-render is a better DX for function components that use hooks.)\n\n    const cleanedInspectedElement = { ...mostRecentlyInspectedElement\n    }; // $FlowFixMe[prop-missing] found when upgrading Flow\n\n    cleanedInspectedElement.context = Object(backend_utils[\"a\" /* cleanForBridge */])(cleanedInspectedElement.context, createIsPathAllowed('context', null)); // $FlowFixMe[prop-missing] found when upgrading Flow\n\n    cleanedInspectedElement.hooks = Object(backend_utils[\"a\" /* cleanForBridge */])(cleanedInspectedElement.hooks, createIsPathAllowed('hooks', 'hooks')); // $FlowFixMe[prop-missing] found when upgrading Flow\n\n    cleanedInspectedElement.props = Object(backend_utils[\"a\" /* cleanForBridge */])(cleanedInspectedElement.props, createIsPathAllowed('props', null)); // $FlowFixMe[prop-missing] found when upgrading Flow\n\n    cleanedInspectedElement.state = Object(backend_utils[\"a\" /* cleanForBridge */])(cleanedInspectedElement.state, createIsPathAllowed('state', null));\n    return {\n      id,\n      responseID: requestID,\n      type: 'full-data',\n      // $FlowFixMe[prop-missing] found when upgrading Flow\n      value: cleanedInspectedElement\n    };\n  }\n\n  function logElementToConsole(id) {\n    const result = isMostRecentlyInspectedElementCurrent(id) ? mostRecentlyInspectedElement : inspectElementRaw(id);\n\n    if (result === null) {\n      console.warn(`Could not find Fiber with id \"${id}\"`);\n      return;\n    }\n\n    const supportsGroup = typeof console.groupCollapsed === 'function';\n\n    if (supportsGroup) {\n      console.groupCollapsed(`[Click to expand] %c<${result.displayName || 'Component'} />`, // --dom-tag-name-color is the CSS variable Chrome styles HTML elements with in the console.\n      'color: var(--dom-tag-name-color); font-weight: normal;');\n    }\n\n    if (result.props !== null) {\n      console.log('Props:', result.props);\n    }\n\n    if (result.state !== null) {\n      console.log('State:', result.state);\n    }\n\n    if (result.hooks !== null) {\n      console.log('Hooks:', result.hooks);\n    }\n\n    const nativeNodes = findNativeNodesForFiberID(id);\n\n    if (nativeNodes !== null) {\n      console.log('Nodes:', nativeNodes);\n    }\n\n    if (result.source !== null) {\n      console.log('Location:', result.source);\n    }\n\n    if (window.chrome || /firefox/i.test(navigator.userAgent)) {\n      console.log('Right-click any value to save it as a global variable for further inspection.');\n    }\n\n    if (supportsGroup) {\n      console.groupEnd();\n    }\n  }\n\n  function deletePath(type, id, hookID, path) {\n    const fiber = findCurrentFiberUsingSlowPathById(id);\n\n    if (fiber !== null) {\n      const instance = fiber.stateNode;\n\n      switch (type) {\n        case 'context':\n          // To simplify hydration and display of primitive context values (e.g. number, string)\n          // the inspectElement() method wraps context in a {value: ...} object.\n          // We need to remove the first part of the path (the \"value\") before continuing.\n          path = path.slice(1);\n\n          switch (fiber.tag) {\n            case ClassComponent:\n              if (path.length === 0) {// Simple context value (noop)\n              } else {\n                Object(utils[\"c\" /* deletePathInObject */])(instance.context, path);\n              }\n\n              instance.forceUpdate();\n              break;\n\n            case FunctionComponent:\n              // Function components using legacy context are not editable\n              // because there's no instance on which to create a cloned, mutated context.\n              break;\n          }\n\n          break;\n\n        case 'hooks':\n          if (typeof overrideHookStateDeletePath === 'function') {\n            overrideHookStateDeletePath(fiber, hookID, path);\n          }\n\n          break;\n\n        case 'props':\n          if (instance === null) {\n            if (typeof overridePropsDeletePath === 'function') {\n              overridePropsDeletePath(fiber, path);\n            }\n          } else {\n            fiber.pendingProps = Object(backend_utils[\"c\" /* copyWithDelete */])(instance.props, path);\n            instance.forceUpdate();\n          }\n\n          break;\n\n        case 'state':\n          Object(utils[\"c\" /* deletePathInObject */])(instance.state, path);\n          instance.forceUpdate();\n          break;\n      }\n    }\n  }\n\n  function renamePath(type, id, hookID, oldPath, newPath) {\n    const fiber = findCurrentFiberUsingSlowPathById(id);\n\n    if (fiber !== null) {\n      const instance = fiber.stateNode;\n\n      switch (type) {\n        case 'context':\n          // To simplify hydration and display of primitive context values (e.g. number, string)\n          // the inspectElement() method wraps context in a {value: ...} object.\n          // We need to remove the first part of the path (the \"value\") before continuing.\n          oldPath = oldPath.slice(1);\n          newPath = newPath.slice(1);\n\n          switch (fiber.tag) {\n            case ClassComponent:\n              if (oldPath.length === 0) {// Simple context value (noop)\n              } else {\n                Object(utils[\"u\" /* renamePathInObject */])(instance.context, oldPath, newPath);\n              }\n\n              instance.forceUpdate();\n              break;\n\n            case FunctionComponent:\n              // Function components using legacy context are not editable\n              // because there's no instance on which to create a cloned, mutated context.\n              break;\n          }\n\n          break;\n\n        case 'hooks':\n          if (typeof overrideHookStateRenamePath === 'function') {\n            overrideHookStateRenamePath(fiber, hookID, oldPath, newPath);\n          }\n\n          break;\n\n        case 'props':\n          if (instance === null) {\n            if (typeof overridePropsRenamePath === 'function') {\n              overridePropsRenamePath(fiber, oldPath, newPath);\n            }\n          } else {\n            fiber.pendingProps = Object(backend_utils[\"d\" /* copyWithRename */])(instance.props, oldPath, newPath);\n            instance.forceUpdate();\n          }\n\n          break;\n\n        case 'state':\n          Object(utils[\"u\" /* renamePathInObject */])(instance.state, oldPath, newPath);\n          instance.forceUpdate();\n          break;\n      }\n    }\n  }\n\n  function overrideValueAtPath(type, id, hookID, path, value) {\n    const fiber = findCurrentFiberUsingSlowPathById(id);\n\n    if (fiber !== null) {\n      const instance = fiber.stateNode;\n\n      switch (type) {\n        case 'context':\n          // To simplify hydration and display of primitive context values (e.g. number, string)\n          // the inspectElement() method wraps context in a {value: ...} object.\n          // We need to remove the first part of the path (the \"value\") before continuing.\n          path = path.slice(1);\n\n          switch (fiber.tag) {\n            case ClassComponent:\n              if (path.length === 0) {\n                // Simple context value\n                instance.context = value;\n              } else {\n                Object(utils[\"w\" /* setInObject */])(instance.context, path, value);\n              }\n\n              instance.forceUpdate();\n              break;\n\n            case FunctionComponent:\n              // Function components using legacy context are not editable\n              // because there's no instance on which to create a cloned, mutated context.\n              break;\n          }\n\n          break;\n\n        case 'hooks':\n          if (typeof overrideHookState === 'function') {\n            overrideHookState(fiber, hookID, path, value);\n          }\n\n          break;\n\n        case 'props':\n          switch (fiber.tag) {\n            case ClassComponent:\n              fiber.pendingProps = Object(backend_utils[\"e\" /* copyWithSet */])(instance.props, path, value);\n              instance.forceUpdate();\n              break;\n\n            default:\n              if (typeof overrideProps === 'function') {\n                overrideProps(fiber, path, value);\n              }\n\n              break;\n          }\n\n          break;\n\n        case 'state':\n          switch (fiber.tag) {\n            case ClassComponent:\n              Object(utils[\"w\" /* setInObject */])(instance.state, path, value);\n              instance.forceUpdate();\n              break;\n          }\n\n          break;\n      }\n    }\n  }\n\n  let currentCommitProfilingMetadata = null;\n  let displayNamesByRootID = null;\n  let idToContextsMap = null;\n  let initialTreeBaseDurationsMap = null;\n  let initialIDToRootMap = null;\n  let isProfiling = false;\n  let profilingStartTime = 0;\n  let recordChangeDescriptions = false;\n  let rootToCommitProfilingMetadataMap = null;\n\n  function getProfilingData() {\n    const dataForRoots = [];\n\n    if (rootToCommitProfilingMetadataMap === null) {\n      throw Error('getProfilingData() called before any profiling data was recorded');\n    }\n\n    rootToCommitProfilingMetadataMap.forEach((commitProfilingMetadata, rootID) => {\n      const commitData = [];\n      const initialTreeBaseDurations = [];\n      const displayName = displayNamesByRootID !== null && displayNamesByRootID.get(rootID) || 'Unknown';\n\n      if (initialTreeBaseDurationsMap != null) {\n        initialTreeBaseDurationsMap.forEach((treeBaseDuration, id) => {\n          if (initialIDToRootMap != null && initialIDToRootMap.get(id) === rootID) {\n            // We don't need to convert milliseconds to microseconds in this case,\n            // because the profiling summary is JSON serialized.\n            initialTreeBaseDurations.push([id, treeBaseDuration]);\n          }\n        });\n      }\n\n      commitProfilingMetadata.forEach((commitProfilingData, commitIndex) => {\n        const {\n          changeDescriptions,\n          durations,\n          effectDuration,\n          maxActualDuration,\n          passiveEffectDuration,\n          priorityLevel,\n          commitTime,\n          updaters\n        } = commitProfilingData;\n        const fiberActualDurations = [];\n        const fiberSelfDurations = [];\n\n        for (let i = 0; i < durations.length; i += 3) {\n          const fiberID = durations[i];\n          fiberActualDurations.push([fiberID, durations[i + 1]]);\n          fiberSelfDurations.push([fiberID, durations[i + 2]]);\n        }\n\n        commitData.push({\n          changeDescriptions: changeDescriptions !== null ? Array.from(changeDescriptions.entries()) : null,\n          duration: maxActualDuration,\n          effectDuration,\n          fiberActualDurations,\n          fiberSelfDurations,\n          passiveEffectDuration,\n          priorityLevel,\n          timestamp: commitTime,\n          updaters\n        });\n      });\n      dataForRoots.push({\n        commitData,\n        displayName,\n        initialTreeBaseDurations,\n        rootID\n      });\n    });\n    let timelineData = null;\n\n    if (typeof getTimelineData === 'function') {\n      const currentTimelineData = getTimelineData();\n\n      if (currentTimelineData) {\n        const {\n          batchUIDToMeasuresMap,\n          internalModuleSourceToRanges,\n          laneToLabelMap,\n          laneToReactMeasureMap,\n          ...rest\n        } = currentTimelineData;\n        timelineData = { ...rest,\n          // Most of the data is safe to parse as-is,\n          // but we need to convert the nested Arrays back to Maps.\n          // Most of the data is safe to serialize as-is,\n          // but we need to convert the Maps to nested Arrays.\n          batchUIDToMeasuresKeyValueArray: Array.from(batchUIDToMeasuresMap.entries()),\n          internalModuleSourceToRanges: Array.from(internalModuleSourceToRanges.entries()),\n          laneToLabelKeyValueArray: Array.from(laneToLabelMap.entries()),\n          laneToReactMeasureKeyValueArray: Array.from(laneToReactMeasureMap.entries())\n        };\n      }\n    }\n\n    return {\n      dataForRoots,\n      rendererID,\n      timelineData\n    };\n  }\n\n  function startProfiling(shouldRecordChangeDescriptions) {\n    if (isProfiling) {\n      return;\n    }\n\n    recordChangeDescriptions = shouldRecordChangeDescriptions; // Capture initial values as of the time profiling starts.\n    // It's important we snapshot both the durations and the id-to-root map,\n    // since either of these may change during the profiling session\n    // (e.g. when a fiber is re-rendered or when a fiber gets removed).\n\n    displayNamesByRootID = new Map();\n    initialTreeBaseDurationsMap = new Map(idToTreeBaseDurationMap);\n    initialIDToRootMap = new Map(idToRootMap);\n    idToContextsMap = new Map();\n    hook.getFiberRoots(rendererID).forEach(root => {\n      const rootID = getFiberIDThrows(root.current);\n      displayNamesByRootID.set(rootID, getDisplayNameForRoot(root.current));\n\n      if (shouldRecordChangeDescriptions) {\n        // Record all contexts at the time profiling is started.\n        // Fibers only store the current context value,\n        // so we need to track them separately in order to determine changed keys.\n        crawlToInitializeContextsMap(root.current);\n      }\n    });\n    isProfiling = true;\n    profilingStartTime = renderer_getCurrentTime();\n    rootToCommitProfilingMetadataMap = new Map();\n\n    if (toggleProfilingStatus !== null) {\n      toggleProfilingStatus(true);\n    }\n  }\n\n  function stopProfiling() {\n    isProfiling = false;\n    recordChangeDescriptions = false;\n\n    if (toggleProfilingStatus !== null) {\n      toggleProfilingStatus(false);\n    }\n  } // Automatically start profiling so that we don't miss timing info from initial \"mount\".\n\n\n  if (Object(storage[\"c\" /* sessionStorageGetItem */])(constants[\"w\" /* SESSION_STORAGE_RELOAD_AND_PROFILE_KEY */]) === 'true') {\n    startProfiling(Object(storage[\"c\" /* sessionStorageGetItem */])(constants[\"v\" /* SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY */]) === 'true');\n  } // React will switch between these implementations depending on whether\n  // we have any manually suspended/errored-out Fibers or not.\n\n\n  function shouldErrorFiberAlwaysNull() {\n    return null;\n  } // Map of id and its force error status: true (error), false (toggled off),\n  // null (do nothing)\n\n\n  const forceErrorForFiberIDs = new Map();\n\n  function shouldErrorFiberAccordingToMap(fiber) {\n    if (typeof setErrorHandler !== 'function') {\n      throw new Error('Expected overrideError() to not get called for earlier React versions.');\n    }\n\n    const id = getFiberIDUnsafe(fiber);\n\n    if (id === null) {\n      return null;\n    }\n\n    let status = null;\n\n    if (forceErrorForFiberIDs.has(id)) {\n      status = forceErrorForFiberIDs.get(id);\n\n      if (status === false) {\n        // TRICKY overrideError adds entries to this Map,\n        // so ideally it would be the method that clears them too,\n        // but that would break the functionality of the feature,\n        // since DevTools needs to tell React to act differently than it normally would\n        // (don't just re-render the failed boundary, but reset its errored state too).\n        // So we can only clear it after telling React to reset the state.\n        // Technically this is premature and we should schedule it for later,\n        // since the render could always fail without committing the updated error boundary,\n        // but since this is a DEV-only feature, the simplicity is worth the trade off.\n        forceErrorForFiberIDs.delete(id);\n\n        if (forceErrorForFiberIDs.size === 0) {\n          // Last override is gone. Switch React back to fast path.\n          setErrorHandler(shouldErrorFiberAlwaysNull);\n        }\n      }\n    }\n\n    return status;\n  }\n\n  function overrideError(id, forceError) {\n    if (typeof setErrorHandler !== 'function' || typeof scheduleUpdate !== 'function') {\n      throw new Error('Expected overrideError() to not get called for earlier React versions.');\n    }\n\n    forceErrorForFiberIDs.set(id, forceError);\n\n    if (forceErrorForFiberIDs.size === 1) {\n      // First override is added. Switch React to slower path.\n      setErrorHandler(shouldErrorFiberAccordingToMap);\n    }\n\n    const fiber = idToArbitraryFiberMap.get(id);\n\n    if (fiber != null) {\n      scheduleUpdate(fiber);\n    }\n  }\n\n  function shouldSuspendFiberAlwaysFalse() {\n    return false;\n  }\n\n  const forceFallbackForSuspenseIDs = new Set();\n\n  function shouldSuspendFiberAccordingToSet(fiber) {\n    const maybeID = getFiberIDUnsafe(fiber);\n    return maybeID !== null && forceFallbackForSuspenseIDs.has(maybeID);\n  }\n\n  function overrideSuspense(id, forceFallback) {\n    if (typeof setSuspenseHandler !== 'function' || typeof scheduleUpdate !== 'function') {\n      throw new Error('Expected overrideSuspense() to not get called for earlier React versions.');\n    }\n\n    if (forceFallback) {\n      forceFallbackForSuspenseIDs.add(id);\n\n      if (forceFallbackForSuspenseIDs.size === 1) {\n        // First override is added. Switch React to slower path.\n        setSuspenseHandler(shouldSuspendFiberAccordingToSet);\n      }\n    } else {\n      forceFallbackForSuspenseIDs.delete(id);\n\n      if (forceFallbackForSuspenseIDs.size === 0) {\n        // Last override is gone. Switch React back to fast path.\n        setSuspenseHandler(shouldSuspendFiberAlwaysFalse);\n      }\n    }\n\n    const fiber = idToArbitraryFiberMap.get(id);\n\n    if (fiber != null) {\n      scheduleUpdate(fiber);\n    }\n  } // Remember if we're trying to restore the selection after reload.\n  // In that case, we'll do some extra checks for matching mounts.\n\n\n  let trackedPath = null;\n  let trackedPathMatchFiber = null;\n  let trackedPathMatchDepth = -1;\n  let mightBeOnTrackedPath = false;\n\n  function setTrackedPath(path) {\n    if (path === null) {\n      trackedPathMatchFiber = null;\n      trackedPathMatchDepth = -1;\n      mightBeOnTrackedPath = false;\n    }\n\n    trackedPath = path;\n  } // We call this before traversing a new mount.\n  // It remembers whether this Fiber is the next best match for tracked path.\n  // The return value signals whether we should keep matching siblings or not.\n\n\n  function updateTrackedPathStateBeforeMount(fiber) {\n    if (trackedPath === null || !mightBeOnTrackedPath) {\n      // Fast path: there's nothing to track so do nothing and ignore siblings.\n      return false;\n    }\n\n    const returnFiber = fiber.return;\n    const returnAlternate = returnFiber !== null ? returnFiber.alternate : null; // By now we know there's some selection to restore, and this is a new Fiber.\n    // Is this newly mounted Fiber a direct child of the current best match?\n    // (This will also be true for new roots if we haven't matched anything yet.)\n\n    if (trackedPathMatchFiber === returnFiber || trackedPathMatchFiber === returnAlternate && returnAlternate !== null) {\n      // Is this the next Fiber we should select? Let's compare the frames.\n      const actualFrame = getPathFrame(fiber); // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n      const expectedFrame = trackedPath[trackedPathMatchDepth + 1];\n\n      if (expectedFrame === undefined) {\n        throw new Error('Expected to see a frame at the next depth.');\n      }\n\n      if (actualFrame.index === expectedFrame.index && actualFrame.key === expectedFrame.key && actualFrame.displayName === expectedFrame.displayName) {\n        // We have our next match.\n        trackedPathMatchFiber = fiber;\n        trackedPathMatchDepth++; // Are we out of frames to match?\n        // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n        if (trackedPathMatchDepth === trackedPath.length - 1) {\n          // There's nothing that can possibly match afterwards.\n          // Don't check the children.\n          mightBeOnTrackedPath = false;\n        } else {\n          // Check the children, as they might reveal the next match.\n          mightBeOnTrackedPath = true;\n        } // In either case, since we have a match, we don't need\n        // to check the siblings. They'll never match.\n\n\n        return false;\n      }\n    } // This Fiber's parent is on the path, but this Fiber itself isn't.\n    // There's no need to check its children--they won't be on the path either.\n\n\n    mightBeOnTrackedPath = false; // However, one of its siblings may be on the path so keep searching.\n\n    return true;\n  }\n\n  function updateTrackedPathStateAfterMount(mightSiblingsBeOnTrackedPath) {\n    // updateTrackedPathStateBeforeMount() told us whether to match siblings.\n    // Now that we're entering siblings, let's use that information.\n    mightBeOnTrackedPath = mightSiblingsBeOnTrackedPath;\n  } // Roots don't have a real persistent identity.\n  // A root's \"pseudo key\" is \"childDisplayName:indexWithThatName\".\n  // For example, \"App:0\" or, in case of similar roots, \"Story:0\", \"Story:1\", etc.\n  // We will use this to try to disambiguate roots when restoring selection between reloads.\n\n\n  const rootPseudoKeys = new Map();\n  const rootDisplayNameCounter = new Map();\n\n  function setRootPseudoKey(id, fiber) {\n    const name = getDisplayNameForRoot(fiber);\n    const counter = rootDisplayNameCounter.get(name) || 0;\n    rootDisplayNameCounter.set(name, counter + 1);\n    const pseudoKey = `${name}:${counter}`;\n    rootPseudoKeys.set(id, pseudoKey);\n  }\n\n  function removeRootPseudoKey(id) {\n    const pseudoKey = rootPseudoKeys.get(id);\n\n    if (pseudoKey === undefined) {\n      throw new Error('Expected root pseudo key to be known.');\n    }\n\n    const name = pseudoKey.substring(0, pseudoKey.lastIndexOf(':'));\n    const counter = rootDisplayNameCounter.get(name);\n\n    if (counter === undefined) {\n      throw new Error('Expected counter to be known.');\n    }\n\n    if (counter > 1) {\n      rootDisplayNameCounter.set(name, counter - 1);\n    } else {\n      rootDisplayNameCounter.delete(name);\n    }\n\n    rootPseudoKeys.delete(id);\n  }\n\n  function getDisplayNameForRoot(fiber) {\n    let preferredDisplayName = null;\n    let fallbackDisplayName = null;\n    let child = fiber.child; // Go at most three levels deep into direct children\n    // while searching for a child that has a displayName.\n\n    for (let i = 0; i < 3; i++) {\n      if (child === null) {\n        break;\n      }\n\n      const displayName = getDisplayNameForFiber(child);\n\n      if (displayName !== null) {\n        // Prefer display names that we get from user-defined components.\n        // We want to avoid using e.g. 'Suspense' unless we find nothing else.\n        if (typeof child.type === 'function') {\n          // There's a few user-defined tags, but we'll prefer the ones\n          // that are usually explicitly named (function or class components).\n          preferredDisplayName = displayName;\n        } else if (fallbackDisplayName === null) {\n          fallbackDisplayName = displayName;\n        }\n      }\n\n      if (preferredDisplayName !== null) {\n        break;\n      }\n\n      child = child.child;\n    }\n\n    return preferredDisplayName || fallbackDisplayName || 'Anonymous';\n  }\n\n  function getPathFrame(fiber) {\n    const {\n      key\n    } = fiber;\n    let displayName = getDisplayNameForFiber(fiber);\n    const index = fiber.index;\n\n    switch (fiber.tag) {\n      case HostRoot:\n        // Roots don't have a real displayName, index, or key.\n        // Instead, we'll use the pseudo key (childDisplayName:indexWithThatName).\n        const id = getFiberIDThrows(fiber);\n        const pseudoKey = rootPseudoKeys.get(id);\n\n        if (pseudoKey === undefined) {\n          throw new Error('Expected mounted root to have known pseudo key.');\n        }\n\n        displayName = pseudoKey;\n        break;\n\n      case HostComponent:\n        displayName = fiber.type;\n        break;\n\n      default:\n        break;\n    }\n\n    return {\n      displayName,\n      key,\n      index\n    };\n  } // Produces a serializable representation that does a best effort\n  // of identifying a particular Fiber between page reloads.\n  // The return path will contain Fibers that are \"invisible\" to the store\n  // because their keys and indexes are important to restoring the selection.\n\n\n  function getPathForElement(id) {\n    let fiber = idToArbitraryFiberMap.get(id);\n\n    if (fiber == null) {\n      return null;\n    }\n\n    const keyPath = [];\n\n    while (fiber !== null) {\n      // $FlowFixMe[incompatible-call] found when upgrading Flow\n      keyPath.push(getPathFrame(fiber)); // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n      fiber = fiber.return;\n    }\n\n    keyPath.reverse();\n    return keyPath;\n  }\n\n  function getBestMatchForTrackedPath() {\n    if (trackedPath === null) {\n      // Nothing to match.\n      return null;\n    }\n\n    if (trackedPathMatchFiber === null) {\n      // We didn't find anything.\n      return null;\n    } // Find the closest Fiber store is aware of.\n\n\n    let fiber = trackedPathMatchFiber;\n\n    while (fiber !== null && shouldFilterFiber(fiber)) {\n      fiber = fiber.return;\n    }\n\n    if (fiber === null) {\n      return null;\n    }\n\n    return {\n      id: getFiberIDThrows(fiber),\n      // $FlowFixMe[incompatible-use] found when upgrading Flow\n      isFullMatch: trackedPathMatchDepth === trackedPath.length - 1\n    };\n  }\n\n  const formatPriorityLevel = priorityLevel => {\n    if (priorityLevel == null) {\n      return 'Unknown';\n    }\n\n    switch (priorityLevel) {\n      case ImmediatePriority:\n        return 'Immediate';\n\n      case UserBlockingPriority:\n        return 'User-Blocking';\n\n      case NormalPriority:\n        return 'Normal';\n\n      case LowPriority:\n        return 'Low';\n\n      case IdlePriority:\n        return 'Idle';\n\n      case NoPriority:\n      default:\n        return 'Unknown';\n    }\n  };\n\n  function setTraceUpdatesEnabled(isEnabled) {\n    traceUpdatesEnabled = isEnabled;\n  }\n\n  return {\n    cleanup,\n    clearErrorsAndWarnings,\n    clearErrorsForFiberID,\n    clearWarningsForFiberID,\n    copyElementPath,\n    deletePath,\n    findNativeNodesForFiberID,\n    flushInitialOperations,\n    getBestMatchForTrackedPath,\n    getDisplayNameForFiberID,\n    getFiberForNative,\n    getFiberIDForNative,\n    getInstanceAndStyle,\n    getOwnersList,\n    getPathForElement,\n    getProfilingData,\n    handleCommitFiberRoot,\n    handleCommitFiberUnmount,\n    handlePostCommitFiberRoot,\n    inspectElement,\n    logElementToConsole,\n    patchConsoleForStrictMode: backend_console[\"c\" /* patchForStrictMode */],\n    prepareViewAttributeSource,\n    prepareViewElementSource,\n    overrideError,\n    overrideSuspense,\n    overrideValueAtPath,\n    renamePath,\n    renderer,\n    setTraceUpdatesEnabled,\n    setTrackedPath,\n    startProfiling,\n    stopProfiling,\n    storeAsGlobal,\n    unpatchConsoleForStrictMode: backend_console[\"e\" /* unpatchForStrictMode */],\n    updateComponentFilters\n  };\n}\n\n/***/ }),\n\n/***/ 71:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"a\", function() { return /* binding */ describeFiber; });\n__webpack_require__.d(__webpack_exports__, \"b\", function() { return /* binding */ getStackByFiberInDevAndProd; });\n\n// EXTERNAL MODULE: ../react-devtools-shared/src/backend/ReactSymbols.js\nvar ReactSymbols = __webpack_require__(8);\n\n// CONCATENATED MODULE: ../react-devtools-shared/src/backend/DevToolsConsolePatching.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// This is a DevTools fork of shared/ConsolePatchingDev.\n// The shared console patching code is DEV-only.\n// We can't use it since DevTools only ships production builds.\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nlet disabledDepth = 0;\nlet prevLog;\nlet prevInfo;\nlet prevWarn;\nlet prevError;\nlet prevGroup;\nlet prevGroupCollapsed;\nlet prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  if (disabledDepth === 0) {\n    /* eslint-disable react-internal/no-production-logging */\n    prevLog = console.log;\n    prevInfo = console.info;\n    prevWarn = console.warn;\n    prevError = console.error;\n    prevGroup = console.group;\n    prevGroupCollapsed = console.groupCollapsed;\n    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n    const props = {\n      configurable: true,\n      enumerable: true,\n      value: disabledLog,\n      writable: true\n    }; // $FlowFixMe Flow thinks console is immutable.\n\n    Object.defineProperties(console, {\n      info: props,\n      log: props,\n      warn: props,\n      error: props,\n      group: props,\n      groupCollapsed: props,\n      groupEnd: props\n    });\n    /* eslint-enable react-internal/no-production-logging */\n  }\n\n  disabledDepth++;\n}\nfunction reenableLogs() {\n  disabledDepth--;\n\n  if (disabledDepth === 0) {\n    /* eslint-disable react-internal/no-production-logging */\n    const props = {\n      configurable: true,\n      enumerable: true,\n      writable: true\n    }; // $FlowFixMe Flow thinks console is immutable.\n\n    Object.defineProperties(console, {\n      log: { ...props,\n        value: prevLog\n      },\n      info: { ...props,\n        value: prevInfo\n      },\n      warn: { ...props,\n        value: prevWarn\n      },\n      error: { ...props,\n        value: prevError\n      },\n      group: { ...props,\n        value: prevGroup\n      },\n      groupCollapsed: { ...props,\n        value: prevGroupCollapsed\n      },\n      groupEnd: { ...props,\n        value: prevGroupEnd\n      }\n    });\n    /* eslint-enable react-internal/no-production-logging */\n  }\n\n  if (disabledDepth < 0) {\n    console.error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n  }\n}\n// CONCATENATED MODULE: ../react-devtools-shared/src/backend/DevToolsComponentStackFrame.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// This is a DevTools fork of ReactComponentStackFrame.\n// This fork enables DevTools to use the same \"native\" component stack format,\n// while still maintaining support for multiple renderer versions\n// (which use different values for ReactTypeOfWork).\n // The shared console patching code is DEV-only.\n// We can't use it since DevTools only ships production builds.\n\n\nlet prefix;\nfunction describeBuiltInComponentFrame(name, ownerFn) {\n  if (prefix === undefined) {\n    // Extract the VM specific prefix used by each line.\n    try {\n      throw Error();\n    } catch (x) {\n      const match = x.stack.trim().match(/\\n( *(at )?)/);\n      prefix = match && match[1] || '';\n    }\n  } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n  return '\\n' + prefix + name;\n}\nlet reentry = false;\nlet componentFrameCache;\n\nif (false) {}\n\nfunction describeNativeComponentFrame(fn, construct, currentDispatcherRef) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  if (false) {}\n\n  let control;\n  const previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  reentry = true; // Override the dispatcher so effects scheduled by this shallow render are thrown away.\n  //\n  // Note that unlike the code this was forked from (in ReactComponentStackFrame)\n  // DevTools should override the dispatcher even when DevTools is compiled in production mode,\n  // because the app itself may be in development mode and log errors/warnings.\n\n  const previousDispatcher = currentDispatcherRef.current;\n  currentDispatcherRef.current = null;\n  disableLogs();\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      const Fake = function () {\n        throw Error();\n      }; // $FlowFixMe\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      }\n\n      fn();\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      const sampleLines = sample.stack.split('\\n');\n      const controlLines = control.stack.split('\\n');\n      let s = sampleLines.length - 1;\n      let c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                const frame = '\\n' + sampleLines[s].replace(' at new ', ' at ');\n\n                if (false) {} // Return the line we found.\n\n\n                return frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n    Error.prepareStackTrace = previousPrepareStackTrace;\n    currentDispatcherRef.current = previousDispatcher;\n    reenableLogs();\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  const name = fn ? fn.displayName || fn.name : '';\n  const syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  if (false) {}\n\n  return syntheticFrame;\n}\nfunction describeClassComponentFrame(ctor, ownerFn, currentDispatcherRef) {\n  return describeNativeComponentFrame(ctor, true, currentDispatcherRef);\n}\nfunction describeFunctionComponentFrame(fn, ownerFn, currentDispatcherRef) {\n  return describeNativeComponentFrame(fn, false, currentDispatcherRef);\n}\n\nfunction shouldConstruct(Component) {\n  const prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, ownerFn, currentDispatcherRef) {\n  if (true) {\n    return '';\n  }\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    return describeNativeComponentFrame(type, shouldConstruct(type), currentDispatcherRef);\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type, ownerFn);\n  }\n\n  switch (type) {\n    case ReactSymbols[\"w\" /* SUSPENSE_NUMBER */]:\n    case ReactSymbols[\"x\" /* SUSPENSE_SYMBOL_STRING */]:\n      return describeBuiltInComponentFrame('Suspense', ownerFn);\n\n    case ReactSymbols[\"u\" /* SUSPENSE_LIST_NUMBER */]:\n    case ReactSymbols[\"v\" /* SUSPENSE_LIST_SYMBOL_STRING */]:\n      return describeBuiltInComponentFrame('SuspenseList', ownerFn);\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case ReactSymbols[\"f\" /* FORWARD_REF_NUMBER */]:\n      case ReactSymbols[\"g\" /* FORWARD_REF_SYMBOL_STRING */]:\n        return describeFunctionComponentFrame(type.render, ownerFn, currentDispatcherRef);\n\n      case ReactSymbols[\"j\" /* MEMO_NUMBER */]:\n      case ReactSymbols[\"k\" /* MEMO_SYMBOL_STRING */]:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, ownerFn, currentDispatcherRef);\n\n      case ReactSymbols[\"h\" /* LAZY_NUMBER */]:\n      case ReactSymbols[\"i\" /* LAZY_SYMBOL_STRING */]:\n        {\n          const lazyComponent = type;\n          const payload = lazyComponent._payload;\n          const init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), ownerFn, currentDispatcherRef);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n// CONCATENATED MODULE: ../react-devtools-shared/src/backend/DevToolsFiberComponentStack.js\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// This is a DevTools fork of ReactFiberComponentStack.\n// This fork enables DevTools to use the same \"native\" component stack format,\n// while still maintaining support for multiple renderer versions\n// (which use different values for ReactTypeOfWork).\n\nfunction describeFiber(workTagMap, workInProgress, currentDispatcherRef) {\n  const {\n    HostComponent,\n    LazyComponent,\n    SuspenseComponent,\n    SuspenseListComponent,\n    FunctionComponent,\n    IndeterminateComponent,\n    SimpleMemoComponent,\n    ForwardRef,\n    ClassComponent\n  } = workTagMap;\n  const owner =  false ? undefined : null;\n\n  switch (workInProgress.tag) {\n    case HostComponent:\n      return describeBuiltInComponentFrame(workInProgress.type, owner);\n\n    case LazyComponent:\n      return describeBuiltInComponentFrame('Lazy', owner);\n\n    case SuspenseComponent:\n      return describeBuiltInComponentFrame('Suspense', owner);\n\n    case SuspenseListComponent:\n      return describeBuiltInComponentFrame('SuspenseList', owner);\n\n    case FunctionComponent:\n    case IndeterminateComponent:\n    case SimpleMemoComponent:\n      return describeFunctionComponentFrame(workInProgress.type, owner, currentDispatcherRef);\n\n    case ForwardRef:\n      return describeFunctionComponentFrame(workInProgress.type.render, owner, currentDispatcherRef);\n\n    case ClassComponent:\n      return describeClassComponentFrame(workInProgress.type, owner, currentDispatcherRef);\n\n    default:\n      return '';\n  }\n}\nfunction getStackByFiberInDevAndProd(workTagMap, workInProgress, currentDispatcherRef) {\n  try {\n    let info = '';\n    let node = workInProgress;\n\n    do {\n      info += describeFiber(workTagMap, node, currentDispatcherRef); // $FlowFixMe[incompatible-type] we bail out when we get a null\n\n      node = node.return;\n    } while (node);\n\n    return info;\n  } catch (x) {\n    return '\\nError generating stack: ' + x.message + '\\n' + x.stack;\n  }\n}\n\n/***/ }),\n\n/***/ 8:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return CONCURRENT_MODE_NUMBER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return CONCURRENT_MODE_SYMBOL_STRING; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return CONTEXT_NUMBER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return CONTEXT_SYMBOL_STRING; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"r\", function() { return SERVER_CONTEXT_SYMBOL_STRING; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return DEPRECATED_ASYNC_MODE_SYMBOL_STRING; });\n/* unused harmony export ELEMENT_NUMBER */\n/* unused harmony export ELEMENT_SYMBOL_STRING */\n/* unused harmony export DEBUG_TRACING_MODE_NUMBER */\n/* unused harmony export DEBUG_TRACING_MODE_SYMBOL_STRING */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return FORWARD_REF_NUMBER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"g\", function() { return FORWARD_REF_SYMBOL_STRING; });\n/* unused harmony export FRAGMENT_NUMBER */\n/* unused harmony export FRAGMENT_SYMBOL_STRING */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return LAZY_NUMBER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"i\", function() { return LAZY_SYMBOL_STRING; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"j\", function() { return MEMO_NUMBER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"k\", function() { return MEMO_SYMBOL_STRING; });\n/* unused harmony export PORTAL_NUMBER */\n/* unused harmony export PORTAL_SYMBOL_STRING */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"l\", function() { return PROFILER_NUMBER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"m\", function() { return PROFILER_SYMBOL_STRING; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"n\", function() { return PROVIDER_NUMBER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"o\", function() { return PROVIDER_SYMBOL_STRING; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"p\", function() { return SCOPE_NUMBER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"q\", function() { return SCOPE_SYMBOL_STRING; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"s\", function() { return STRICT_MODE_NUMBER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"t\", function() { return STRICT_MODE_SYMBOL_STRING; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"w\", function() { return SUSPENSE_NUMBER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"x\", function() { return SUSPENSE_SYMBOL_STRING; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"u\", function() { return SUSPENSE_LIST_NUMBER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"v\", function() { return SUSPENSE_LIST_SYMBOL_STRING; });\n/* unused harmony export SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED_SYMBOL_STRING */\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// This list should be kept updated to reflect additions to 'shared/ReactSymbols'.\n// DevTools can't import symbols from 'shared/ReactSymbols' directly for two reasons:\n// 1. DevTools requires symbols which may have been deleted in more recent versions (e.g. concurrent mode)\n// 2. DevTools must support both Symbol and numeric forms of each symbol;\n//    Since e.g. standalone DevTools runs in a separate process, it can't rely on its own ES capabilities.\nconst CONCURRENT_MODE_NUMBER = 0xeacf;\nconst CONCURRENT_MODE_SYMBOL_STRING = 'Symbol(react.concurrent_mode)';\nconst CONTEXT_NUMBER = 0xeace;\nconst CONTEXT_SYMBOL_STRING = 'Symbol(react.context)';\nconst SERVER_CONTEXT_SYMBOL_STRING = 'Symbol(react.server_context)';\nconst DEPRECATED_ASYNC_MODE_SYMBOL_STRING = 'Symbol(react.async_mode)';\nconst ELEMENT_NUMBER = 0xeac7;\nconst ELEMENT_SYMBOL_STRING = 'Symbol(react.element)';\nconst DEBUG_TRACING_MODE_NUMBER = 0xeae1;\nconst DEBUG_TRACING_MODE_SYMBOL_STRING = 'Symbol(react.debug_trace_mode)';\nconst FORWARD_REF_NUMBER = 0xead0;\nconst FORWARD_REF_SYMBOL_STRING = 'Symbol(react.forward_ref)';\nconst FRAGMENT_NUMBER = 0xeacb;\nconst FRAGMENT_SYMBOL_STRING = 'Symbol(react.fragment)';\nconst LAZY_NUMBER = 0xead4;\nconst LAZY_SYMBOL_STRING = 'Symbol(react.lazy)';\nconst MEMO_NUMBER = 0xead3;\nconst MEMO_SYMBOL_STRING = 'Symbol(react.memo)';\nconst PORTAL_NUMBER = 0xeaca;\nconst PORTAL_SYMBOL_STRING = 'Symbol(react.portal)';\nconst PROFILER_NUMBER = 0xead2;\nconst PROFILER_SYMBOL_STRING = 'Symbol(react.profiler)';\nconst PROVIDER_NUMBER = 0xeacd;\nconst PROVIDER_SYMBOL_STRING = 'Symbol(react.provider)';\nconst SCOPE_NUMBER = 0xead7;\nconst SCOPE_SYMBOL_STRING = 'Symbol(react.scope)';\nconst STRICT_MODE_NUMBER = 0xeacc;\nconst STRICT_MODE_SYMBOL_STRING = 'Symbol(react.strict_mode)';\nconst SUSPENSE_NUMBER = 0xead1;\nconst SUSPENSE_SYMBOL_STRING = 'Symbol(react.suspense)';\nconst SUSPENSE_LIST_NUMBER = 0xead8;\nconst SUSPENSE_LIST_SYMBOL_STRING = 'Symbol(react.suspense_list)';\nconst SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED_SYMBOL_STRING = 'Symbol(react.server_context.defaultValue)';\n\n/***/ }),\n\n/***/ 80:\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {var scope = typeof global !== \"undefined\" && global || typeof self !== \"undefined\" && self || window;\nvar apply = Function.prototype.apply; // DOM APIs, for completeness\n\nexports.setTimeout = function () {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\n\nexports.setInterval = function () {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\n\nexports.clearTimeout = exports.clearInterval = function (timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\n\nTimeout.prototype.unref = Timeout.prototype.ref = function () {};\n\nTimeout.prototype.close = function () {\n  this._clearFn.call(scope, this._id);\n}; // Does not start the time, just sets up the members needed.\n\n\nexports.enroll = function (item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function (item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function (item) {\n  clearTimeout(item._idleTimeoutId);\n  var msecs = item._idleTimeout;\n\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout) item._onTimeout();\n    }, msecs);\n  }\n}; // setimmediate attaches itself to the global object\n\n\n__webpack_require__(81); // On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\n\n\nexports.setImmediate = typeof self !== \"undefined\" && self.setImmediate || typeof global !== \"undefined\" && global.setImmediate || this && this.setImmediate;\nexports.clearImmediate = typeof self !== \"undefined\" && self.clearImmediate || typeof global !== \"undefined\" && global.clearImmediate || this && this.clearImmediate;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(40)))\n\n/***/ }),\n\n/***/ 81:\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n  \"use strict\";\n\n  if (global.setImmediate) {\n    return;\n  }\n\n  var nextHandle = 1; // Spec says greater than zero\n\n  var tasksByHandle = {};\n  var currentlyRunningATask = false;\n  var doc = global.document;\n  var registerImmediate;\n\n  function setImmediate(callback) {\n    // Callback can either be a function or a string\n    if (typeof callback !== \"function\") {\n      callback = new Function(\"\" + callback);\n    } // Copy function arguments\n\n\n    var args = new Array(arguments.length - 1);\n\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i + 1];\n    } // Store and register the task\n\n\n    var task = {\n      callback: callback,\n      args: args\n    };\n    tasksByHandle[nextHandle] = task;\n    registerImmediate(nextHandle);\n    return nextHandle++;\n  }\n\n  function clearImmediate(handle) {\n    delete tasksByHandle[handle];\n  }\n\n  function run(task) {\n    var callback = task.callback;\n    var args = task.args;\n\n    switch (args.length) {\n      case 0:\n        callback();\n        break;\n\n      case 1:\n        callback(args[0]);\n        break;\n\n      case 2:\n        callback(args[0], args[1]);\n        break;\n\n      case 3:\n        callback(args[0], args[1], args[2]);\n        break;\n\n      default:\n        callback.apply(undefined, args);\n        break;\n    }\n  }\n\n  function runIfPresent(handle) {\n    // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n    // So if we're currently running a task, we'll need to delay this invocation.\n    if (currentlyRunningATask) {\n      // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n      // \"too much recursion\" error.\n      setTimeout(runIfPresent, 0, handle);\n    } else {\n      var task = tasksByHandle[handle];\n\n      if (task) {\n        currentlyRunningATask = true;\n\n        try {\n          run(task);\n        } finally {\n          clearImmediate(handle);\n          currentlyRunningATask = false;\n        }\n      }\n    }\n  }\n\n  function installNextTickImplementation() {\n    registerImmediate = function (handle) {\n      process.nextTick(function () {\n        runIfPresent(handle);\n      });\n    };\n  }\n\n  function canUsePostMessage() {\n    // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n    // where `global.postMessage` means something completely different and can't be used for this purpose.\n    if (global.postMessage && !global.importScripts) {\n      var postMessageIsAsynchronous = true;\n      var oldOnMessage = global.onmessage;\n\n      global.onmessage = function () {\n        postMessageIsAsynchronous = false;\n      };\n\n      global.postMessage(\"\", \"*\");\n      global.onmessage = oldOnMessage;\n      return postMessageIsAsynchronous;\n    }\n  }\n\n  function installPostMessageImplementation() {\n    // Installs an event handler on `global` for the `message` event: see\n    // * https://developer.mozilla.org/en/DOM/window.postMessage\n    // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n    var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n\n    var onGlobalMessage = function (event) {\n      if (event.source === global && typeof event.data === \"string\" && event.data.indexOf(messagePrefix) === 0) {\n        runIfPresent(+event.data.slice(messagePrefix.length));\n      }\n    };\n\n    if (global.addEventListener) {\n      global.addEventListener(\"message\", onGlobalMessage, false);\n    } else {\n      global.attachEvent(\"onmessage\", onGlobalMessage);\n    }\n\n    registerImmediate = function (handle) {\n      global.postMessage(messagePrefix + handle, \"*\");\n    };\n  }\n\n  function installMessageChannelImplementation() {\n    var channel = new MessageChannel();\n\n    channel.port1.onmessage = function (event) {\n      var handle = event.data;\n      runIfPresent(handle);\n    };\n\n    registerImmediate = function (handle) {\n      channel.port2.postMessage(handle);\n    };\n  }\n\n  function installReadyStateChangeImplementation() {\n    var html = doc.documentElement;\n\n    registerImmediate = function (handle) {\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var script = doc.createElement(\"script\");\n\n      script.onreadystatechange = function () {\n        runIfPresent(handle);\n        script.onreadystatechange = null;\n        html.removeChild(script);\n        script = null;\n      };\n\n      html.appendChild(script);\n    };\n  }\n\n  function installSetTimeoutImplementation() {\n    registerImmediate = function (handle) {\n      setTimeout(runIfPresent, 0, handle);\n    };\n  } // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n\n\n  var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n  attachTo = attachTo && attachTo.setTimeout ? attachTo : global; // Don't get fooled by e.g. browserify environments.\n\n  if ({}.toString.call(global.process) === \"[object process]\") {\n    // For Node.js before 0.9\n    installNextTickImplementation();\n  } else if (canUsePostMessage()) {\n    // For non-IE10 modern browsers\n    installPostMessageImplementation();\n  } else if (global.MessageChannel) {\n    // For web workers, where supported\n    installMessageChannelImplementation();\n  } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n    // For IE 68\n    installReadyStateChangeImplementation();\n  } else {\n    // For older browsers\n    installSetTimeoutImplementation();\n  }\n\n  attachTo.setImmediate = setImmediate;\n  attachTo.clearImmediate = clearImmediate;\n})(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(40), __webpack_require__(67)))\n\n/***/ }),\n\n/***/ 82:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = Yallist;\nYallist.Node = Node;\nYallist.create = Yallist;\n\nfunction Yallist(list) {\n  var self = this;\n\n  if (!(self instanceof Yallist)) {\n    self = new Yallist();\n  }\n\n  self.tail = null;\n  self.head = null;\n  self.length = 0;\n\n  if (list && typeof list.forEach === 'function') {\n    list.forEach(function (item) {\n      self.push(item);\n    });\n  } else if (arguments.length > 0) {\n    for (var i = 0, l = arguments.length; i < l; i++) {\n      self.push(arguments[i]);\n    }\n  }\n\n  return self;\n}\n\nYallist.prototype.removeNode = function (node) {\n  if (node.list !== this) {\n    throw new Error('removing node which does not belong to this list');\n  }\n\n  var next = node.next;\n  var prev = node.prev;\n\n  if (next) {\n    next.prev = prev;\n  }\n\n  if (prev) {\n    prev.next = next;\n  }\n\n  if (node === this.head) {\n    this.head = next;\n  }\n\n  if (node === this.tail) {\n    this.tail = prev;\n  }\n\n  node.list.length--;\n  node.next = null;\n  node.prev = null;\n  node.list = null;\n  return next;\n};\n\nYallist.prototype.unshiftNode = function (node) {\n  if (node === this.head) {\n    return;\n  }\n\n  if (node.list) {\n    node.list.removeNode(node);\n  }\n\n  var head = this.head;\n  node.list = this;\n  node.next = head;\n\n  if (head) {\n    head.prev = node;\n  }\n\n  this.head = node;\n\n  if (!this.tail) {\n    this.tail = node;\n  }\n\n  this.length++;\n};\n\nYallist.prototype.pushNode = function (node) {\n  if (node === this.tail) {\n    return;\n  }\n\n  if (node.list) {\n    node.list.removeNode(node);\n  }\n\n  var tail = this.tail;\n  node.list = this;\n  node.prev = tail;\n\n  if (tail) {\n    tail.next = node;\n  }\n\n  this.tail = node;\n\n  if (!this.head) {\n    this.head = node;\n  }\n\n  this.length++;\n};\n\nYallist.prototype.push = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    push(this, arguments[i]);\n  }\n\n  return this.length;\n};\n\nYallist.prototype.unshift = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    unshift(this, arguments[i]);\n  }\n\n  return this.length;\n};\n\nYallist.prototype.pop = function () {\n  if (!this.tail) {\n    return undefined;\n  }\n\n  var res = this.tail.value;\n  this.tail = this.tail.prev;\n\n  if (this.tail) {\n    this.tail.next = null;\n  } else {\n    this.head = null;\n  }\n\n  this.length--;\n  return res;\n};\n\nYallist.prototype.shift = function () {\n  if (!this.head) {\n    return undefined;\n  }\n\n  var res = this.head.value;\n  this.head = this.head.next;\n\n  if (this.head) {\n    this.head.prev = null;\n  } else {\n    this.tail = null;\n  }\n\n  this.length--;\n  return res;\n};\n\nYallist.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this;\n\n  for (var walker = this.head, i = 0; walker !== null; i++) {\n    fn.call(thisp, walker.value, i, this);\n    walker = walker.next;\n  }\n};\n\nYallist.prototype.forEachReverse = function (fn, thisp) {\n  thisp = thisp || this;\n\n  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {\n    fn.call(thisp, walker.value, i, this);\n    walker = walker.prev;\n  }\n};\n\nYallist.prototype.get = function (n) {\n  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.next;\n  }\n\n  if (i === n && walker !== null) {\n    return walker.value;\n  }\n};\n\nYallist.prototype.getReverse = function (n) {\n  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.prev;\n  }\n\n  if (i === n && walker !== null) {\n    return walker.value;\n  }\n};\n\nYallist.prototype.map = function (fn, thisp) {\n  thisp = thisp || this;\n  var res = new Yallist();\n\n  for (var walker = this.head; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this));\n    walker = walker.next;\n  }\n\n  return res;\n};\n\nYallist.prototype.mapReverse = function (fn, thisp) {\n  thisp = thisp || this;\n  var res = new Yallist();\n\n  for (var walker = this.tail; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this));\n    walker = walker.prev;\n  }\n\n  return res;\n};\n\nYallist.prototype.reduce = function (fn, initial) {\n  var acc;\n  var walker = this.head;\n\n  if (arguments.length > 1) {\n    acc = initial;\n  } else if (this.head) {\n    walker = this.head.next;\n    acc = this.head.value;\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value');\n  }\n\n  for (var i = 0; walker !== null; i++) {\n    acc = fn(acc, walker.value, i);\n    walker = walker.next;\n  }\n\n  return acc;\n};\n\nYallist.prototype.reduceReverse = function (fn, initial) {\n  var acc;\n  var walker = this.tail;\n\n  if (arguments.length > 1) {\n    acc = initial;\n  } else if (this.tail) {\n    walker = this.tail.prev;\n    acc = this.tail.value;\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value');\n  }\n\n  for (var i = this.length - 1; walker !== null; i--) {\n    acc = fn(acc, walker.value, i);\n    walker = walker.prev;\n  }\n\n  return acc;\n};\n\nYallist.prototype.toArray = function () {\n  var arr = new Array(this.length);\n\n  for (var i = 0, walker = this.head; walker !== null; i++) {\n    arr[i] = walker.value;\n    walker = walker.next;\n  }\n\n  return arr;\n};\n\nYallist.prototype.toArrayReverse = function () {\n  var arr = new Array(this.length);\n\n  for (var i = 0, walker = this.tail; walker !== null; i++) {\n    arr[i] = walker.value;\n    walker = walker.prev;\n  }\n\n  return arr;\n};\n\nYallist.prototype.slice = function (from, to) {\n  to = to || this.length;\n\n  if (to < 0) {\n    to += this.length;\n  }\n\n  from = from || 0;\n\n  if (from < 0) {\n    from += this.length;\n  }\n\n  var ret = new Yallist();\n\n  if (to < from || to < 0) {\n    return ret;\n  }\n\n  if (from < 0) {\n    from = 0;\n  }\n\n  if (to > this.length) {\n    to = this.length;\n  }\n\n  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {\n    walker = walker.next;\n  }\n\n  for (; walker !== null && i < to; i++, walker = walker.next) {\n    ret.push(walker.value);\n  }\n\n  return ret;\n};\n\nYallist.prototype.sliceReverse = function (from, to) {\n  to = to || this.length;\n\n  if (to < 0) {\n    to += this.length;\n  }\n\n  from = from || 0;\n\n  if (from < 0) {\n    from += this.length;\n  }\n\n  var ret = new Yallist();\n\n  if (to < from || to < 0) {\n    return ret;\n  }\n\n  if (from < 0) {\n    from = 0;\n  }\n\n  if (to > this.length) {\n    to = this.length;\n  }\n\n  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {\n    walker = walker.prev;\n  }\n\n  for (; walker !== null && i > from; i--, walker = walker.prev) {\n    ret.push(walker.value);\n  }\n\n  return ret;\n};\n\nYallist.prototype.splice = function (start, deleteCount\n/*, ...nodes */\n) {\n  if (start > this.length) {\n    start = this.length - 1;\n  }\n\n  if (start < 0) {\n    start = this.length + start;\n  }\n\n  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {\n    walker = walker.next;\n  }\n\n  var ret = [];\n\n  for (var i = 0; walker && i < deleteCount; i++) {\n    ret.push(walker.value);\n    walker = this.removeNode(walker);\n  }\n\n  if (walker === null) {\n    walker = this.tail;\n  }\n\n  if (walker !== this.head && walker !== this.tail) {\n    walker = walker.prev;\n  }\n\n  for (var i = 2; i < arguments.length; i++) {\n    walker = insert(this, walker, arguments[i]);\n  }\n\n  return ret;\n};\n\nYallist.prototype.reverse = function () {\n  var head = this.head;\n  var tail = this.tail;\n\n  for (var walker = head; walker !== null; walker = walker.prev) {\n    var p = walker.prev;\n    walker.prev = walker.next;\n    walker.next = p;\n  }\n\n  this.head = tail;\n  this.tail = head;\n  return this;\n};\n\nfunction insert(self, node, value) {\n  var inserted = node === self.head ? new Node(value, null, node, self) : new Node(value, node, node.next, self);\n\n  if (inserted.next === null) {\n    self.tail = inserted;\n  }\n\n  if (inserted.prev === null) {\n    self.head = inserted;\n  }\n\n  self.length++;\n  return inserted;\n}\n\nfunction push(self, item) {\n  self.tail = new Node(item, self.tail, null, self);\n\n  if (!self.head) {\n    self.head = self.tail;\n  }\n\n  self.length++;\n}\n\nfunction unshift(self, item) {\n  self.head = new Node(item, null, self.head, self);\n\n  if (!self.tail) {\n    self.tail = self.head;\n  }\n\n  self.length++;\n}\n\nfunction Node(value, prev, next, list) {\n  if (!(this instanceof Node)) {\n    return new Node(value, prev, next, list);\n  }\n\n  this.list = list;\n  this.value = value;\n\n  if (prev) {\n    prev.next = this;\n    this.prev = prev;\n  } else {\n    this.prev = null;\n  }\n\n  if (next) {\n    next.prev = this;\n    this.next = next;\n  } else {\n    this.next = null;\n  }\n}\n\ntry {\n  // add if support for Symbol.iterator is present\n  __webpack_require__(83)(Yallist);\n} catch (er) {}\n\n/***/ }),\n\n/***/ 83:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function (Yallist) {\n  Yallist.prototype[Symbol.iterator] = function* () {\n    for (let walker = this.head; walker; walker = walker.next) {\n      yield walker.value;\n    }\n  };\n};\n\n/***/ }),\n\n/***/ 84:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {\n  'use strict'; // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n  /* istanbul ignore next */\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(this, function () {\n  'use strict';\n\n  function _isNumber(n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n  }\n\n  function _capitalize(str) {\n    return str.charAt(0).toUpperCase() + str.substring(1);\n  }\n\n  function _getter(p) {\n    return function () {\n      return this[p];\n    };\n  }\n\n  var booleanProps = ['isConstructor', 'isEval', 'isNative', 'isToplevel'];\n  var numericProps = ['columnNumber', 'lineNumber'];\n  var stringProps = ['fileName', 'functionName', 'source'];\n  var arrayProps = ['args'];\n  var props = booleanProps.concat(numericProps, stringProps, arrayProps);\n\n  function StackFrame(obj) {\n    if (!obj) return;\n\n    for (var i = 0; i < props.length; i++) {\n      if (obj[props[i]] !== undefined) {\n        this['set' + _capitalize(props[i])](obj[props[i]]);\n      }\n    }\n  }\n\n  StackFrame.prototype = {\n    getArgs: function () {\n      return this.args;\n    },\n    setArgs: function (v) {\n      if (Object.prototype.toString.call(v) !== '[object Array]') {\n        throw new TypeError('Args must be an Array');\n      }\n\n      this.args = v;\n    },\n    getEvalOrigin: function () {\n      return this.evalOrigin;\n    },\n    setEvalOrigin: function (v) {\n      if (v instanceof StackFrame) {\n        this.evalOrigin = v;\n      } else if (v instanceof Object) {\n        this.evalOrigin = new StackFrame(v);\n      } else {\n        throw new TypeError('Eval Origin must be an Object or StackFrame');\n      }\n    },\n    toString: function () {\n      var fileName = this.getFileName() || '';\n      var lineNumber = this.getLineNumber() || '';\n      var columnNumber = this.getColumnNumber() || '';\n      var functionName = this.getFunctionName() || '';\n\n      if (this.getIsEval()) {\n        if (fileName) {\n          return '[eval] (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';\n        }\n\n        return '[eval]:' + lineNumber + ':' + columnNumber;\n      }\n\n      if (functionName) {\n        return functionName + ' (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';\n      }\n\n      return fileName + ':' + lineNumber + ':' + columnNumber;\n    }\n  };\n\n  StackFrame.fromString = function StackFrame$$fromString(str) {\n    var argsStartIndex = str.indexOf('(');\n    var argsEndIndex = str.lastIndexOf(')');\n    var functionName = str.substring(0, argsStartIndex);\n    var args = str.substring(argsStartIndex + 1, argsEndIndex).split(',');\n    var locationString = str.substring(argsEndIndex + 1);\n\n    if (locationString.indexOf('@') === 0) {\n      var parts = /@(.+?)(?::(\\d+))?(?::(\\d+))?$/.exec(locationString, '');\n      var fileName = parts[1];\n      var lineNumber = parts[2];\n      var columnNumber = parts[3];\n    }\n\n    return new StackFrame({\n      functionName: functionName,\n      args: args || undefined,\n      fileName: fileName,\n      lineNumber: lineNumber || undefined,\n      columnNumber: columnNumber || undefined\n    });\n  };\n\n  for (var i = 0; i < booleanProps.length; i++) {\n    StackFrame.prototype['get' + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);\n\n    StackFrame.prototype['set' + _capitalize(booleanProps[i])] = function (p) {\n      return function (v) {\n        this[p] = Boolean(v);\n      };\n    }(booleanProps[i]);\n  }\n\n  for (var j = 0; j < numericProps.length; j++) {\n    StackFrame.prototype['get' + _capitalize(numericProps[j])] = _getter(numericProps[j]);\n\n    StackFrame.prototype['set' + _capitalize(numericProps[j])] = function (p) {\n      return function (v) {\n        if (!_isNumber(v)) {\n          throw new TypeError(p + ' must be a Number');\n        }\n\n        this[p] = Number(v);\n      };\n    }(numericProps[j]);\n  }\n\n  for (var k = 0; k < stringProps.length; k++) {\n    StackFrame.prototype['get' + _capitalize(stringProps[k])] = _getter(stringProps[k]);\n\n    StackFrame.prototype['set' + _capitalize(stringProps[k])] = function (p) {\n      return function (v) {\n        this[p] = String(v);\n      };\n    }(stringProps[k]);\n  }\n\n  return StackFrame;\n});\n\n/***/ })\n\n/******/ });\n//# sourceMappingURL=backend.js.map"},98024:(e,n,t)=>{"use strict";t.d(n,{Z:()=>r});const r="/**\n * @license React\n * react-is.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\nvar REACT_MODULE_REFERENCE;\n\n{\n  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');\n}\n\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction typeOf(object) {\n  if (typeof object === 'object' && object !== null) {\n    var $$typeof = object.$$typeof;\n\n    switch ($$typeof) {\n      case REACT_ELEMENT_TYPE:\n        var type = object.type;\n\n        switch (type) {\n          case REACT_FRAGMENT_TYPE:\n          case REACT_PROFILER_TYPE:\n          case REACT_STRICT_MODE_TYPE:\n          case REACT_SUSPENSE_TYPE:\n          case REACT_SUSPENSE_LIST_TYPE:\n            return type;\n\n          default:\n            var $$typeofType = type && type.$$typeof;\n\n            switch ($$typeofType) {\n              case REACT_SERVER_CONTEXT_TYPE:\n              case REACT_CONTEXT_TYPE:\n              case REACT_FORWARD_REF_TYPE:\n              case REACT_LAZY_TYPE:\n              case REACT_MEMO_TYPE:\n              case REACT_PROVIDER_TYPE:\n                return $$typeofType;\n\n              default:\n                return $$typeof;\n            }\n\n        }\n\n      case REACT_PORTAL_TYPE:\n        return $$typeof;\n    }\n  }\n\n  return undefined;\n}\nvar ContextConsumer = REACT_CONTEXT_TYPE;\nvar ContextProvider = REACT_PROVIDER_TYPE;\nvar Element = REACT_ELEMENT_TYPE;\nvar ForwardRef = REACT_FORWARD_REF_TYPE;\nvar Fragment = REACT_FRAGMENT_TYPE;\nvar Lazy = REACT_LAZY_TYPE;\nvar Memo = REACT_MEMO_TYPE;\nvar Portal = REACT_PORTAL_TYPE;\nvar Profiler = REACT_PROFILER_TYPE;\nvar StrictMode = REACT_STRICT_MODE_TYPE;\nvar Suspense = REACT_SUSPENSE_TYPE;\nvar SuspenseList = REACT_SUSPENSE_LIST_TYPE;\nvar hasWarnedAboutDeprecatedIsAsyncMode = false;\nvar hasWarnedAboutDeprecatedIsConcurrentMode = false; // AsyncMode should be deprecated\n\nfunction isAsyncMode(object) {\n  {\n    if (!hasWarnedAboutDeprecatedIsAsyncMode) {\n      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint\n\n      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 18+.');\n    }\n  }\n\n  return false;\n}\nfunction isConcurrentMode(object) {\n  {\n    if (!hasWarnedAboutDeprecatedIsConcurrentMode) {\n      hasWarnedAboutDeprecatedIsConcurrentMode = true; // Using console['warn'] to evade Babel and ESLint\n\n      console['warn']('The ReactIs.isConcurrentMode() alias has been deprecated, ' + 'and will be removed in React 18+.');\n    }\n  }\n\n  return false;\n}\nfunction isContextConsumer(object) {\n  return typeOf(object) === REACT_CONTEXT_TYPE;\n}\nfunction isContextProvider(object) {\n  return typeOf(object) === REACT_PROVIDER_TYPE;\n}\nfunction isElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nfunction isForwardRef(object) {\n  return typeOf(object) === REACT_FORWARD_REF_TYPE;\n}\nfunction isFragment(object) {\n  return typeOf(object) === REACT_FRAGMENT_TYPE;\n}\nfunction isLazy(object) {\n  return typeOf(object) === REACT_LAZY_TYPE;\n}\nfunction isMemo(object) {\n  return typeOf(object) === REACT_MEMO_TYPE;\n}\nfunction isPortal(object) {\n  return typeOf(object) === REACT_PORTAL_TYPE;\n}\nfunction isProfiler(object) {\n  return typeOf(object) === REACT_PROFILER_TYPE;\n}\nfunction isStrictMode(object) {\n  return typeOf(object) === REACT_STRICT_MODE_TYPE;\n}\nfunction isSuspense(object) {\n  return typeOf(object) === REACT_SUSPENSE_TYPE;\n}\nfunction isSuspenseList(object) {\n  return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;\n}\n\nexports.ContextConsumer = ContextConsumer;\nexports.ContextProvider = ContextProvider;\nexports.Element = Element;\nexports.ForwardRef = ForwardRef;\nexports.Fragment = Fragment;\nexports.Lazy = Lazy;\nexports.Memo = Memo;\nexports.Portal = Portal;\nexports.Profiler = Profiler;\nexports.StrictMode = StrictMode;\nexports.Suspense = Suspense;\nexports.SuspenseList = SuspenseList;\nexports.isAsyncMode = isAsyncMode;\nexports.isConcurrentMode = isConcurrentMode;\nexports.isContextConsumer = isContextConsumer;\nexports.isContextProvider = isContextProvider;\nexports.isElement = isElement;\nexports.isForwardRef = isForwardRef;\nexports.isFragment = isFragment;\nexports.isLazy = isLazy;\nexports.isMemo = isMemo;\nexports.isPortal = isPortal;\nexports.isProfiler = isProfiler;\nexports.isStrictMode = isStrictMode;\nexports.isSuspense = isSuspense;\nexports.isSuspenseList = isSuspenseList;\nexports.isValidElementType = isValidElementType;\nexports.typeOf = typeOf;\n  })();\n}\n"},51544:(e,n,t)=>{"use strict";t.d(n,{Z:()=>r});const r="/**\n * @license React\n * react-refresh-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\n// ATTENTION\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\n\nvar PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map; // We never remove these associations.\n// It's OK to reference families, but use WeakMap/Set for types.\n\nvar allFamiliesByID = new Map();\nvar allFamiliesByType = new PossiblyWeakMap();\nvar allSignaturesByType = new PossiblyWeakMap(); // This WeakMap is read by React, so we only put families\n// that have actually been edited here. This keeps checks fast.\n// $FlowIssue\n\nvar updatedFamiliesByType = new PossiblyWeakMap(); // This is cleared on every performReactRefresh() call.\n// It is an array of [Family, NextType] tuples.\n\nvar pendingUpdates = []; // This is injected by the renderer via DevTools global hook.\n\nvar helpersByRendererID = new Map();\nvar helpersByRoot = new Map(); // We keep track of mounted roots so we can schedule updates.\n\nvar mountedRoots = new Set(); // If a root captures an error, we remember it so we can retry on edit.\n\nvar failedRoots = new Set(); // In environments that support WeakMap, we also remember the last element for every root.\n// It needs to be weak because we do this even for roots that failed to mount.\n// If there is no WeakMap, we won't attempt to do retrying.\n// $FlowIssue\n\nvar rootElements = // $FlowIssue\ntypeof WeakMap === 'function' ? new WeakMap() : null;\nvar isPerformingRefresh = false;\n\nfunction computeFullKey(signature) {\n  if (signature.fullKey !== null) {\n    return signature.fullKey;\n  }\n\n  var fullKey = signature.ownKey;\n  var hooks;\n\n  try {\n    hooks = signature.getCustomHooks();\n  } catch (err) {\n    // This can happen in an edge case, e.g. if expression like Foo.useSomething\n    // depends on Foo which is lazily initialized during rendering.\n    // In that case just assume we'll have to remount.\n    signature.forceReset = true;\n    signature.fullKey = fullKey;\n    return fullKey;\n  }\n\n  for (var i = 0; i < hooks.length; i++) {\n    var hook = hooks[i];\n\n    if (typeof hook !== 'function') {\n      // Something's wrong. Assume we need to remount.\n      signature.forceReset = true;\n      signature.fullKey = fullKey;\n      return fullKey;\n    }\n\n    var nestedHookSignature = allSignaturesByType.get(hook);\n\n    if (nestedHookSignature === undefined) {\n      // No signature means Hook wasn't in the source code, e.g. in a library.\n      // We'll skip it because we can assume it won't change during this session.\n      continue;\n    }\n\n    var nestedHookKey = computeFullKey(nestedHookSignature);\n\n    if (nestedHookSignature.forceReset) {\n      signature.forceReset = true;\n    }\n\n    fullKey += '\\n---\\n' + nestedHookKey;\n  }\n\n  signature.fullKey = fullKey;\n  return fullKey;\n}\n\nfunction haveEqualSignatures(prevType, nextType) {\n  var prevSignature = allSignaturesByType.get(prevType);\n  var nextSignature = allSignaturesByType.get(nextType);\n\n  if (prevSignature === undefined && nextSignature === undefined) {\n    return true;\n  }\n\n  if (prevSignature === undefined || nextSignature === undefined) {\n    return false;\n  }\n\n  if (computeFullKey(prevSignature) !== computeFullKey(nextSignature)) {\n    return false;\n  }\n\n  if (nextSignature.forceReset) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction isReactClass(type) {\n  return type.prototype && type.prototype.isReactComponent;\n}\n\nfunction canPreserveStateBetween(prevType, nextType) {\n  if (isReactClass(prevType) || isReactClass(nextType)) {\n    return false;\n  }\n\n  if (haveEqualSignatures(prevType, nextType)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction resolveFamily(type) {\n  // Only check updated types to keep lookups fast.\n  return updatedFamiliesByType.get(type);\n} // If we didn't care about IE11, we could use new Map/Set(iterable).\n\n\nfunction cloneMap(map) {\n  var clone = new Map();\n  map.forEach(function (value, key) {\n    clone.set(key, value);\n  });\n  return clone;\n}\n\nfunction cloneSet(set) {\n  var clone = new Set();\n  set.forEach(function (value) {\n    clone.add(value);\n  });\n  return clone;\n} // This is a safety mechanism to protect against rogue getters and Proxies.\n\n\nfunction getProperty(object, property) {\n  try {\n    return object[property];\n  } catch (err) {\n    // Intentionally ignore.\n    return undefined;\n  }\n}\n\nfunction performReactRefresh() {\n\n  if (pendingUpdates.length === 0) {\n    return null;\n  }\n\n  if (isPerformingRefresh) {\n    return null;\n  }\n\n  isPerformingRefresh = true;\n\n  try {\n    var staleFamilies = new Set();\n    var updatedFamilies = new Set();\n    var updates = pendingUpdates;\n    pendingUpdates = [];\n    updates.forEach(function (_ref) {\n      var family = _ref[0],\n          nextType = _ref[1];\n      // Now that we got a real edit, we can create associations\n      // that will be read by the React reconciler.\n      var prevType = family.current;\n      updatedFamiliesByType.set(prevType, family);\n      updatedFamiliesByType.set(nextType, family);\n      family.current = nextType; // Determine whether this should be a re-render or a re-mount.\n\n      if (canPreserveStateBetween(prevType, nextType)) {\n        updatedFamilies.add(family);\n      } else {\n        staleFamilies.add(family);\n      }\n    }); // TODO: rename these fields to something more meaningful.\n\n    var update = {\n      updatedFamilies: updatedFamilies,\n      // Families that will re-render preserving state\n      staleFamilies: staleFamilies // Families that will be remounted\n\n    };\n    helpersByRendererID.forEach(function (helpers) {\n      // Even if there are no roots, set the handler on first update.\n      // This ensures that if *new* roots are mounted, they'll use the resolve handler.\n      helpers.setRefreshHandler(resolveFamily);\n    });\n    var didError = false;\n    var firstError = null; // We snapshot maps and sets that are mutated during commits.\n    // If we don't do this, there is a risk they will be mutated while\n    // we iterate over them. For example, trying to recover a failed root\n    // may cause another root to be added to the failed list -- an infinite loop.\n\n    var failedRootsSnapshot = cloneSet(failedRoots);\n    var mountedRootsSnapshot = cloneSet(mountedRoots);\n    var helpersByRootSnapshot = cloneMap(helpersByRoot);\n    failedRootsSnapshot.forEach(function (root) {\n      var helpers = helpersByRootSnapshot.get(root);\n\n      if (helpers === undefined) {\n        throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');\n      }\n\n      if (!failedRoots.has(root)) {// No longer failed.\n      }\n\n      if (rootElements === null) {\n        return;\n      }\n\n      if (!rootElements.has(root)) {\n        return;\n      }\n\n      var element = rootElements.get(root);\n\n      try {\n        helpers.scheduleRoot(root, element);\n      } catch (err) {\n        if (!didError) {\n          didError = true;\n          firstError = err;\n        } // Keep trying other roots.\n\n      }\n    });\n    mountedRootsSnapshot.forEach(function (root) {\n      var helpers = helpersByRootSnapshot.get(root);\n\n      if (helpers === undefined) {\n        throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');\n      }\n\n      if (!mountedRoots.has(root)) {// No longer mounted.\n      }\n\n      try {\n        helpers.scheduleRefresh(root, update);\n      } catch (err) {\n        if (!didError) {\n          didError = true;\n          firstError = err;\n        } // Keep trying other roots.\n\n      }\n    });\n\n    if (didError) {\n      throw firstError;\n    }\n\n    return update;\n  } finally {\n    isPerformingRefresh = false;\n  }\n}\nfunction register(type, id) {\n  {\n    if (type === null) {\n      return;\n    }\n\n    if (typeof type !== 'function' && typeof type !== 'object') {\n      return;\n    } // This can happen in an edge case, e.g. if we register\n    // return value of a HOC but it returns a cached component.\n    // Ignore anything but the first registration for each type.\n\n\n    if (allFamiliesByType.has(type)) {\n      return;\n    } // Create family or remember to update it.\n    // None of this bookkeeping affects reconciliation\n    // until the first performReactRefresh() call above.\n\n\n    var family = allFamiliesByID.get(id);\n\n    if (family === undefined) {\n      family = {\n        current: type\n      };\n      allFamiliesByID.set(id, family);\n    } else {\n      pendingUpdates.push([family, type]);\n    }\n\n    allFamiliesByType.set(type, family); // Visit inner types because we might not have registered them.\n\n    if (typeof type === 'object' && type !== null) {\n      switch (getProperty(type, '$$typeof')) {\n        case REACT_FORWARD_REF_TYPE:\n          register(type.render, id + '$render');\n          break;\n\n        case REACT_MEMO_TYPE:\n          register(type.type, id + '$type');\n          break;\n      }\n    }\n  }\n}\nfunction setSignature(type, key) {\n  var forceReset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var getCustomHooks = arguments.length > 3 ? arguments[3] : undefined;\n\n  {\n    if (!allSignaturesByType.has(type)) {\n      allSignaturesByType.set(type, {\n        forceReset: forceReset,\n        ownKey: key,\n        fullKey: null,\n        getCustomHooks: getCustomHooks || function () {\n          return [];\n        }\n      });\n    } // Visit inner types because we might not have signed them.\n\n\n    if (typeof type === 'object' && type !== null) {\n      switch (getProperty(type, '$$typeof')) {\n        case REACT_FORWARD_REF_TYPE:\n          setSignature(type.render, key, forceReset, getCustomHooks);\n          break;\n\n        case REACT_MEMO_TYPE:\n          setSignature(type.type, key, forceReset, getCustomHooks);\n          break;\n      }\n    }\n  }\n} // This is lazily called during first render for a type.\n// It captures Hook list at that time so inline requires don't break comparisons.\n\nfunction collectCustomHooksForSignature(type) {\n  {\n    var signature = allSignaturesByType.get(type);\n\n    if (signature !== undefined) {\n      computeFullKey(signature);\n    }\n  }\n}\nfunction getFamilyByID(id) {\n  {\n    return allFamiliesByID.get(id);\n  }\n}\nfunction getFamilyByType(type) {\n  {\n    return allFamiliesByType.get(type);\n  }\n}\nfunction findAffectedHostInstances(families) {\n  {\n    var affectedInstances = new Set();\n    mountedRoots.forEach(function (root) {\n      var helpers = helpersByRoot.get(root);\n\n      if (helpers === undefined) {\n        throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');\n      }\n\n      var instancesForRoot = helpers.findHostInstancesForRefresh(root, families);\n      instancesForRoot.forEach(function (inst) {\n        affectedInstances.add(inst);\n      });\n    });\n    return affectedInstances;\n  }\n}\nfunction injectIntoGlobalHook(globalObject) {\n  {\n    // For React Native, the global hook will be set up by require('react-devtools-core').\n    // That code will run before us. So we need to monkeypatch functions on existing hook.\n    // For React Web, the global hook will be set up by the extension.\n    // This will also run before us.\n    var hook = globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__;\n\n    if (hook === undefined) {\n      // However, if there is no DevTools extension, we'll need to set up the global hook ourselves.\n      // Note that in this case it's important that renderer code runs *after* this method call.\n      // Otherwise, the renderer will think that there is no global hook, and won't do the injection.\n      var nextID = 0;\n      globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__ = hook = {\n        renderers: new Map(),\n        supportsFiber: true,\n        inject: function (injected) {\n          return nextID++;\n        },\n        onScheduleFiberRoot: function (id, root, children) {},\n        onCommitFiberRoot: function (id, root, maybePriorityLevel, didError) {},\n        onCommitFiberUnmount: function () {}\n      };\n    }\n\n    if (hook.isDisabled) {\n      // This isn't a real property on the hook, but it can be set to opt out\n      // of DevTools integration and associated warnings and logs.\n      // Using console['warn'] to evade Babel and ESLint\n      console['warn']('Something has shimmed the React DevTools global hook (__REACT_DEVTOOLS_GLOBAL_HOOK__). ' + 'Fast Refresh is not compatible with this shim and will be disabled.');\n      return;\n    } // Here, we just want to get a reference to scheduleRefresh.\n\n\n    var oldInject = hook.inject;\n\n    hook.inject = function (injected) {\n      var id = oldInject.apply(this, arguments);\n\n      if (typeof injected.scheduleRefresh === 'function' && typeof injected.setRefreshHandler === 'function') {\n        // This version supports React Refresh.\n        helpersByRendererID.set(id, injected);\n      }\n\n      return id;\n    }; // Do the same for any already injected roots.\n    // This is useful if ReactDOM has already been initialized.\n    // https://github.com/facebook/react/issues/17626\n\n\n    hook.renderers.forEach(function (injected, id) {\n      if (typeof injected.scheduleRefresh === 'function' && typeof injected.setRefreshHandler === 'function') {\n        // This version supports React Refresh.\n        helpersByRendererID.set(id, injected);\n      }\n    }); // We also want to track currently mounted roots.\n\n    var oldOnCommitFiberRoot = hook.onCommitFiberRoot;\n\n    var oldOnScheduleFiberRoot = hook.onScheduleFiberRoot || function () {};\n\n    hook.onScheduleFiberRoot = function (id, root, children) {\n      if (!isPerformingRefresh) {\n        // If it was intentionally scheduled, don't attempt to restore.\n        // This includes intentionally scheduled unmounts.\n        failedRoots.delete(root);\n\n        if (rootElements !== null) {\n          rootElements.set(root, children);\n        }\n      }\n\n      return oldOnScheduleFiberRoot.apply(this, arguments);\n    };\n\n    hook.onCommitFiberRoot = function (id, root, maybePriorityLevel, didError) {\n      var helpers = helpersByRendererID.get(id);\n\n      if (helpers !== undefined) {\n        helpersByRoot.set(root, helpers);\n        var current = root.current;\n        var alternate = current.alternate; // We need to determine whether this root has just (un)mounted.\n        // This logic is copy-pasted from similar logic in the DevTools backend.\n        // If this breaks with some refactoring, you'll want to update DevTools too.\n\n        if (alternate !== null) {\n          var wasMounted = alternate.memoizedState != null && alternate.memoizedState.element != null && mountedRoots.has(root);\n          var isMounted = current.memoizedState != null && current.memoizedState.element != null;\n\n          if (!wasMounted && isMounted) {\n            // Mount a new root.\n            mountedRoots.add(root);\n            failedRoots.delete(root);\n          } else if (wasMounted && isMounted) ; else if (wasMounted && !isMounted) {\n            // Unmount an existing root.\n            mountedRoots.delete(root);\n\n            if (didError) {\n              // We'll remount it on future edits.\n              failedRoots.add(root);\n            } else {\n              helpersByRoot.delete(root);\n            }\n          } else if (!wasMounted && !isMounted) {\n            if (didError) {\n              // We'll remount it on future edits.\n              failedRoots.add(root);\n            }\n          }\n        } else {\n          // Mount a new root.\n          mountedRoots.add(root);\n        }\n      } // Always call the decorated DevTools hook.\n\n\n      return oldOnCommitFiberRoot.apply(this, arguments);\n    };\n  }\n}\nfunction hasUnrecoverableErrors() {\n  // TODO: delete this after removing dependency in RN.\n  return false;\n} // Exposed for testing.\n\nfunction _getMountedRootCount() {\n  {\n    return mountedRoots.size;\n  }\n} // This is a wrapper over more primitive functions for setting signature.\n// Signatures let us decide whether the Hook order has changed on refresh.\n//\n// This function is intended to be used as a transform target, e.g.:\n// var _s = createSignatureFunctionForTransform()\n//\n// function Hello() {\n//   const [foo, setFoo] = useState(0);\n//   const value = useCustomHook();\n//   _s(); /* Call without arguments triggers collecting the custom Hook list.\n//          * This doesn't happen during the module evaluation because we\n//          * don't want to change the module order with inline requires.\n//          * Next calls are noops. */\n//   return <h1>Hi</h1>;\n// }\n//\n// /* Call with arguments attaches the signature to the type: */\n// _s(\n//   Hello,\n//   'useState{[foo, setFoo]}(0)',\n//   () => [useCustomHook], /* Lazy to avoid triggering inline requires */\n// );\n\nfunction createSignatureFunctionForTransform() {\n  {\n    var savedType;\n    var hasCustomHooks;\n    var didCollectHooks = false;\n    return function (type, key, forceReset, getCustomHooks) {\n      if (typeof key === 'string') {\n        // We're in the initial phase that associates signatures\n        // with the functions. Note this may be called multiple times\n        // in HOC chains like _s(hoc1(_s(hoc2(_s(actualFunction))))).\n        if (!savedType) {\n          // We're in the innermost call, so this is the actual type.\n          savedType = type;\n          hasCustomHooks = typeof getCustomHooks === 'function';\n        } // Set the signature for all types (even wrappers!) in case\n        // they have no signatures of their own. This is to prevent\n        // problems like https://github.com/facebook/react/issues/20417.\n\n\n        if (type != null && (typeof type === 'function' || typeof type === 'object')) {\n          setSignature(type, key, forceReset, getCustomHooks);\n        }\n\n        return type;\n      } else {\n        // We're in the _s() call without arguments, which means\n        // this is the time to collect custom Hook signatures.\n        // Only do this once. This path is hot and runs *inside* every render!\n        if (!didCollectHooks && hasCustomHooks) {\n          didCollectHooks = true;\n          collectCustomHooksForSignature(savedType);\n        }\n      }\n    };\n  }\n}\nfunction isLikelyComponentType(type) {\n  {\n    switch (typeof type) {\n      case 'function':\n        {\n          // First, deal with classes.\n          if (type.prototype != null) {\n            if (type.prototype.isReactComponent) {\n              // React class.\n              return true;\n            }\n\n            var ownNames = Object.getOwnPropertyNames(type.prototype);\n\n            if (ownNames.length > 1 || ownNames[0] !== 'constructor') {\n              // This looks like a class.\n              return false;\n            } // eslint-disable-next-line no-proto\n\n\n            if (type.prototype.__proto__ !== Object.prototype) {\n              // It has a superclass.\n              return false;\n            } // Pass through.\n            // This looks like a regular function with empty prototype.\n\n          } // For plain functions and arrows, use name as a heuristic.\n\n\n          var name = type.name || type.displayName;\n          return typeof name === 'string' && /^[A-Z]/.test(name);\n        }\n\n      case 'object':\n        {\n          if (type != null) {\n            switch (getProperty(type, '$$typeof')) {\n              case REACT_FORWARD_REF_TYPE:\n              case REACT_MEMO_TYPE:\n                // Definitely React components.\n                return true;\n\n              default:\n                return false;\n            }\n          }\n\n          return false;\n        }\n\n      default:\n        {\n          return false;\n        }\n    }\n  }\n}\n\nexports._getMountedRootCount = _getMountedRootCount;\nexports.collectCustomHooksForSignature = collectCustomHooksForSignature;\nexports.createSignatureFunctionForTransform = createSignatureFunctionForTransform;\nexports.findAffectedHostInstances = findAffectedHostInstances;\nexports.getFamilyByID = getFamilyByID;\nexports.getFamilyByType = getFamilyByType;\nexports.hasUnrecoverableErrors = hasUnrecoverableErrors;\nexports.injectIntoGlobalHook = injectIntoGlobalHook;\nexports.isLikelyComponentType = isLikelyComponentType;\nexports.performReactRefresh = performReactRefresh;\nexports.register = register;\nexports.setSignature = setSignature;\n  })();\n}\n"},78435:e=>{var n="undefined"!=typeof Element,t="function"==typeof Map,r="function"==typeof Set,o="function"==typeof ArrayBuffer&&!!ArrayBuffer.isView;function i(e,s){if(e===s)return!0;if(e&&s&&"object"==typeof e&&"object"==typeof s){if(e.constructor!==s.constructor)return!1;var a,c,l,d;if(Array.isArray(e)){if((a=e.length)!=s.length)return!1;for(c=a;0!=c--;)if(!i(e[c],s[c]))return!1;return!0}if(t&&e instanceof Map&&s instanceof Map){if(e.size!==s.size)return!1;for(d=e.entries();!(c=d.next()).done;)if(!s.has(c.value[0]))return!1;for(d=e.entries();!(c=d.next()).done;)if(!i(c.value[1],s.get(c.value[0])))return!1;return!0}if(r&&e instanceof Set&&s instanceof Set){if(e.size!==s.size)return!1;for(d=e.entries();!(c=d.next()).done;)if(!s.has(c.value[0]))return!1;return!0}if(o&&ArrayBuffer.isView(e)&&ArrayBuffer.isView(s)){if((a=e.length)!=s.length)return!1;for(c=a;0!=c--;)if(e[c]!==s[c])return!1;return!0}if(e.constructor===RegExp)return e.source===s.source&&e.flags===s.flags;if(e.valueOf!==Object.prototype.valueOf)return e.valueOf()===s.valueOf();if(e.toString!==Object.prototype.toString)return e.toString()===s.toString();if((a=(l=Object.keys(e)).length)!==Object.keys(s).length)return!1;for(c=a;0!=c--;)if(!Object.prototype.hasOwnProperty.call(s,l[c]))return!1;if(n&&e instanceof Element)return!1;for(c=a;0!=c--;)if(("_owner"!==l[c]&&"__v"!==l[c]&&"__o"!==l[c]||!e.$$typeof)&&!i(e[l[c]],s[l[c]]))return!1;return!0}return e!=e&&s!=s}e.exports=function(e,n){try{return i(e,n)}catch(e){if((e.message||"").match(/stack|recursion/i))return console.warn("react-fast-compare cannot handle circular refs"),!1;throw e}}},64049:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163),o=t(93849),i=t(5689),s=r.__importDefault(t(7967)),a=r.__importStar(t(32510));n.default=new o.Feature({id:"shortcuts",dependencies:[s.default.asDependency,a.default.asDependency],api:{shortcutService:o.Service.withType().defineEntity(i.mainEnv),actionsService:o.Service.withType().defineEntity(i.mainEnv).allowRemoteAccess(),scopesService:o.Service.withType().defineEntity(i.mainEnv).allowRemoteAccess(),shortcutStrategyManager:(0,a.defineOneWayResource)().defineEntity(i.mainEnv)}})},24577:function(e,n,t){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;var o=t(64049);Object.defineProperty(n,"default",{enumerable:!0,get:function(){return r(o).default}})},20329:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.universalCtrl=n.DUPLICATE_ACTION_ID=n.DELETE_ACTION_IDS=n.ACTIONS=n.MODIFIERS=n.KEYBOARD=void 0;const r=t(91570);n.KEYBOARD={UNIDENTIFIED:"Unidentified",ESCAPE:"Escape",MINUS:"Minus",DASH:"Minus",EQUALS:"Equal",BACK_SPACE:"Backspace",TAB:"Tab",ENTER:"Enter",RETURN:"Enter",SHIFT:"Shift",CONTROL:"Control",ALT:"Alt",PAUSE:"Pause",CAPS_LOCK:"CapsLock",SPACE:"Space",PAGE_UP:"PageUp",PAGE_DOWN:"PageDown",END:"End",HOME:"Home",LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",DOWN:"ArrowDown",PRINTSCREEN:"PrintScreen",INSERT:"Insert",DELETE:"Delete",0:"Digit0",1:"Digit1",2:"Digit2",3:"Digit3",4:"Digit4",5:"Digit5",6:"Digit6",7:"Digit7",8:"Digit8",9:"Digit9",A:"KeyA",B:"KeyB",C:"KeyC",D:"KeyD",E:"KeyE",F:"KeyF",G:"KeyG",H:"KeyH",I:"KeyI",J:"KeyJ",K:"KeyK",L:"KeyL",M:"KeyM",N:"KeyN",O:"KeyO",P:"KeyP",Q:"KeyQ",R:"KeyR",S:"KeyS",T:"KeyT",U:"KeyU",V:"KeyV",W:"KeyW",X:"KeyX",Y:"KeyY",Z:"KeyZ",META:"Meta",OS_LEFT:"OSLeft",CONTEXT_MENU:"ContextMenu",NUMPAD0:"Numpad0",NUMPAD1:"Numpad1",NUMPAD2:"Numpad2",NUMPAD3:"Numpad3",NUMPAD4:"Numpad4",NUMPAD5:"Numpad5",NUMPAD6:"Numpad6",NUMPAD7:"Numpad7",NUMPAD8:"Numpad8",NUMPAD9:"Numpad9",NUMPAD_MULTIPLY:"NumpadMultiply",NUMPAD_ADD:"NumpadAdd",NUMPAD_SUBTRACT:"NumpadSubtract",NUMPAD_DECIMAL:"NumpadDecimal",NUMPAD_DIVIDE:"NumpadDivide",NUMPAD_ENTER:"NumpadEnter",F1:"F1",F2:"F2",F3:"F3",F4:"F4",F5:"F5",F6:"F6",F7:"F7",F8:"F8",F9:"F9",F10:"F10",F11:"F11",F12:"F12",F13:"F13",F14:"F14",F15:"F15",F16:"F16",F17:"F17",F18:"F18",F19:"F19",F20:"F20",F21:"F21",F22:"F22",F23:"F23",F24:"F24",NUM_LOCK:"NumLock",SCROLL_LOCK:"ScrollLock",SEMICOLON:"Semicolon",COMMA:"Comma",PERIOD:"Period",SLASH:"Slash",BACK_QUOTE:"Backquote",OPEN_BRACKET:"BracketLeft",BACK_SLASH:"Backslash",CLOSE_BRACKET:"BracketRight",QUOTE:"Quote",UNIVERSAL_CONTROL:r.isMac?"Meta":"Control"},n.MODIFIERS=new Set(["ControlLeft","ControlRight",n.KEYBOARD.CONTROL,n.KEYBOARD.META,n.KEYBOARD.SHIFT,n.KEYBOARD.ALT]),n.ACTIONS={DELETE:"delete",DUPLICATE:"duplicate"},n.DELETE_ACTION_IDS={DELETE:"DeleteNodeOnDeleteKey",DELETE_ALTERNATIVE:"DeleteNodeOnBackspaceKey"},n.DUPLICATE_ACTION_ID="DuplicateNodeOnShortcut",n.universalCtrl=r.isMac?n.KEYBOARD.META:n.KEYBOARD.CONTROL},90925:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163);r.__exportStar(t(20329),n),r.__exportStar(t(81588),n),r.__exportStar(t(85864),n),r.__exportStar(t(35182),n),r.__exportStar(t(34915),n),r.__exportStar(t(31287),n),r.__exportStar(t(69388),n)},81588:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.ScopesService=void 0,n.ScopesService=class{constructor(){this.isolatedScope=!1}removeScope(e){this.scope===e&&(this.scope=void 0,this.isolatedScope=!1)}setScope(e,n={isIsolated:!1}){const{isIsolated:t}=n;this.scope=e,this.isolatedScope=null!=t&&t}getScope(){return this.scope}getIsolatedScope(){return this.isolatedScope}}},35182:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.METHOD_STRATEGIES=void 0,n.METHOD_STRATEGIES={ON_NON_FOCUSABLE_TARGET:"on-non-focusable-target"}},34915:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.performShortcutStrategy=void 0;const r=t(7934),o=t(69388),i=t(35182);function s(e,n,t){!0===t?e[n]():t!==i.METHOD_STRATEGIES.ON_NON_FOCUSABLE_TARGET||(0,r.isFocusableTarget)(e)||e[n]()}n.performShortcutStrategy=(e,n)=>{const t=(0,o.getShortcutFromEvent)(e);if(!(null==t?void 0:t.length))return;const r=n.getShortcutStrategy(t);r&&((null==r?void 0:r.preventDefault)&&s(e,"preventDefault",r.preventDefault),(null==r?void 0:r.stopPropagation)&&s(e,"stopPropagation",r.stopPropagation))}},85864:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.ShortcutStrategyResource=void 0;const r=t(5163).__importDefault(t(78435)),o=t(60814),i=t(69388);class s extends o.JSONResource{setShortcutStrategy(e,n){const t=(0,i.normalizeShortcut)(e);this.applyPatch((e=>{e[t]&&(0,r.default)(e[t],n)||(e[t]=n)}))}getShortcutStrategy(e){const n=(0,i.normalizeShortcut)(e);return this.getLatest()[n]}}n.ShortcutStrategyResource=s},31287:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0})},69388:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.getShortcutFromEvent=n.getEventCode=n.normalizeShortcut=void 0;const r=t(20329);n.normalizeShortcut=e=>[...e].sort().join("+"),n.getEventCode=e=>e.code,n.getShortcutFromEvent=e=>{const t=(0,n.getEventCode)(e),o=e.ctrlKey&&r.KEYBOARD.CONTROL,i=e.metaKey&&r.KEYBOARD.META,s=e.altKey&&r.KEYBOARD.ALT,a=e.shiftKey&&r.KEYBOARD.SHIFT;if(!r.MODIFIERS.has(t))return[o,i,s,a,t].filter((e=>!!e))}},1529:(e,n,t)=>{e.exports=t(24577)},62202:(e,n,t)=>{e.exports=t(90925)},33248:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(93849),o=t(2993);n.default=new r.Feature({id:"analytics",dependencies:[],api:{analyticsConfig:new r.Config({}),analyticsService:r.Service.withType().defineEntity(r.Universal),analyticsSlot:r.Slot.withType().defineEntity(r.Universal),identifySlot:r.Slot.withType().defineEntity(r.Universal),registerSlot:r.Slot.withType().defineEntity(r.Universal),unregisterSlot:r.Slot.withType().defineEntity(r.Universal)}}).setup(r.Universal,(({analyticsSlot:e,identifySlot:n,registerSlot:t,unregisterSlot:r})=>({analyticsService:new o.AnalyticsService(t,r,n,e)})))},92279:function(e,n,t){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;var o=t(33248);Object.defineProperty(n,"default",{enumerable:!0,get:function(){return r(o).default}})},2993:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.AnalyticsService=void 0;const t="identity_error";n.AnalyticsService=class{constructor(e,n,r,o){this.registerSlot=e,this.unregisterSlot=n,this.identifySlot=r,this.analyticsSlot=o,this.globalAnalyticsAttributes=new Map,this.register=e=>{for(const[n,t]of Object.entries(e))this.globalAnalyticsAttributes.set(n,t);for(const e of this.registerSlot)try{e(Object.fromEntries(this.globalAnalyticsAttributes))}catch(e){}},this.track=(e,n)=>{for(const t of this.analyticsSlot)try{t(e,n)}catch(e){}},this.identify=(e,n)=>{this.unregister(t);for(const{identifyMethod:t}of this.identifySlot)try{t(e,n)}catch(e){}},this.setUserDetails=e=>{for(const{setUserDetails:n}of this.identifySlot)try{n(e)}catch(e){}},this.resetIdentity=()=>{this.unregister(t);for(const{resetIdentity:e}of this.identifySlot)if(e)try{e()}catch(e){}}}unregister(e){this.globalAnalyticsAttributes.delete(e);for(const n of this.unregisterSlot)try{n(e)}catch(e){}}setIdentityError(e){this.register({[t]:e})}}},60456:(e,n,t)=>{e.exports=t(92279)},50497:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163),o=t(93849),i=r.__importDefault(t(46548)),s=r.__importStar(t(2206)),a=r.__importDefault(t(93208)),c=r.__importDefault(t(12763)),l=new o.Feature({id:"code-editor-commands",api:{getFiles:o.Service.withType().defineEntity(s.processingEnv).allowRemoteAccess()},dependencies:[a.default.asDependency,c.default.asDependency,i.default.asDependency,s.default.asDependency]});n.default=l},12763:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.defaultMonacoOptions=n.binaryExtensions=n.CODE_PANEL_ENTRY_ID=n.CODE_PANEL_PANEL_TYPE=void 0;const r=t(5163),o=t(93849),i=t(5689),s=r.__importDefault(t(93208)),a=r.__importDefault(t(2206)),c=r.__importDefault(t(82026)),l=r.__importDefault(t(60456));n.CODE_PANEL_PANEL_TYPE="code",n.CODE_PANEL_ENTRY_ID="open_code_editor",n.binaryExtensions=[".jpg",".bmp",".gif",".png"],n.defaultMonacoOptions={readOnly:!1};const d=new o.Feature({id:"codeEditor",dependencies:[s.default.asDependency,a.default.asDependency,c.default.asDependency,l.default.asDependency],api:{monacoLanguages:o.Service.withType().defineEntity(i.mainEnv),monacoTextModels:o.Service.withType().defineEntity(i.mainEnv),monacoOptions:o.Config.withType().defineEntity(n.defaultMonacoOptions),tagsSlot:o.Slot.withType().defineEntity(i.mainEnv)}});n.default=d},45059:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.CodeEditorCommandsFeature=n.default=void 0;const r=t(5163);var o=t(12763);Object.defineProperty(n,"default",{enumerable:!0,get:function(){return r.__importDefault(o).default}}),r.__exportStar(t(12763),n);var i=t(50497);Object.defineProperty(n,"CodeEditorCommandsFeature",{enumerable:!0,get:function(){return r.__importDefault(i).default}})},30520:(e,n,t)=>{e.exports=t(45059)},43450:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.codeExecutionRenderer=void 0;const r=t(5163),o=r.__importDefault(t(1529)),i=r.__importDefault(t(25447)),s=t(93849),a=r.__importStar(t(32510)),c=r.__importDefault(t(93208)),l=r.__importStar(t(2206)),d=r.__importDefault(t(7967)),u=t(5689);n.codeExecutionRenderer=new s.Environment("window-renderer","iframe","multi");const p=(0,a.defineQueryResource)().defineEntity(l.processingEnv),h=(0,a.defineComputedResource)().defineEntity(l.processingEnv);n.default=new s.Feature({id:"codeExecution",dependencies:[l.default.asDependency,i.default.asDependency,s.COM.asDependency,c.default.asDependency,o.default.asDependency,a.default.asDependency,d.default.asDependency],api:{requestsExtractors:s.Slot.withType().defineEntity(l.processingEnv),requestResolvers:s.Slot.withType().defineEntity(l.processingEnv),bundlePlugins:s.Slot.withType().defineEntity(l.processingEnv),preRequestTransformers:s.Slot.withType().defineEntity(l.processingEnv),postRequestTransformers:s.Slot.withType().defineEntity(l.processingEnv),resolver:s.Service.withType().defineEntity(l.processingEnv).allowRemoteAccess(),codeExecutionInvalidatorService:s.Service.withType().defineEntity(l.processingEnv).allowRemoteAccess(),deepDependencies:h,deepDependenciesMain:h.defineConsumer(u.mainEnv),dependencyResourceFactory:(0,a.defineComputedResource)().defineEntity(l.processingEnv),fileDependencyResourceFactory:(0,a.defineComputedResource)().defineEntity(l.processingEnv),fileDependencyResourceFactoryMain:(0,a.defineComputedResource)().defineEntity(u.mainEnv),executionResourceFactory:p,executionResourceFactoryRenderer:p.defineConsumer(n.codeExecutionRenderer),fileDependencyGraphResourceFactory:(0,a.defineComputedResource)().defineEntity(l.processingEnv),resolveConfig:l.default.api.pluggableProjectConfig.entry({},"resolve"),injectedLibraries:s.MapSlot.withType().defineEntity(n.codeExecutionRenderer),runtimeEnvVars:s.OrderedSlot.withType().defineEntity(n.codeExecutionRenderer),createRenderer:s.Service.withType().defineEntity(n.codeExecutionRenderer),windowController:s.Service.withType().defineEntity(n.codeExecutionRenderer),globalSetupConfig:l.default.api.pluggableProjectConfig.entry(null,"boardGlobalSetup"),previewConfiguration:l.default.api.pluggableProjectConfig.entry({environmentVariables:{}},"previewConfiguration"),windowEventEmitter:s.Service.withType().defineEntity(n.codeExecutionRenderer)}})},57499:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163),o=t(73654),i=t(53433),s=t(93849),a=t(60814),c=t(2206),l=t(69144),d=t(48074),u=t(47951),p=t(60829),h=t(71925),f=r.__importStar(t(43450));f.default.setup(f.codeExecutionRenderer,(({dependencyResourceFactory:e,executionResourceFactory:n,resolver:t,injectedLibraries:r,runtimeEnvVars:m,onDispose:g,globalSetupConfig:y,previewConfiguration:_},{project:{pluggableProjectConfig:b,fileManager:v},compilation:{compiledFilesManager:w,compilationInvalidationManager:E}})=>{const S=b.consume({}),T=w.consume({manipulator:a.stringManipulator});v.consume({resourceConstructor:l.FileResource,manipulator:a.stringManipulator});const C=e.consume({manipulator:u.dependencyManipulator}),k=n.consume({results:[T,C]}),I=S.get(c.PROJECT_CONFIG_NAME,f.codeExecutionRenderer);r.register("path",o.win32);const R=new p.WindowController,O=new Map;E.consume({});const P=new p.WindowEventEmitter;return{createRenderer:async({entries:e,manuallyRequiredEntries:n=[],excludeEditingTransformers:o=!1,beforeRender:a,loadModule:c,ensureRenderable:l,environmentVariables:f,onModuleSystemReady:b=(()=>Promise.resolve()),loadModuleHook:v,globals:w={}})=>{var E;const S=(0,i.createDisposables)(),P=(0,i.createDisposables)(),D=(0,d.deferred)(),M=new Map,x=new Map,N=new Map,A={disposeModule:e=>{var n;try{null===(n=N.get(e))||void 0===n||n()}catch(e){(0,s.reportError)(new Error("Module was disposed with error",{cause:e}))}finally{N.delete(e)}},registerModuleDisposeHandler:(e,n)=>{N.set(e,n)}},F=e=>{if(e.added){for(const n of[...e.changed,...e.added])n.getId().filePath?M.set(n.getId().filePath,n.getLatest()):x.set(n.getId(),n.getLatest());for(const n of[...e.removed])n.getId().filePath?(M.delete(n.getId().filePath),A.disposeModule(n.getId().filePath)):x.delete(n.getId())}},L=await(0,p.resolveGlobalSetupPath)({projectConfig:I,globalSetupConfig:y,resolver:t});L&&e.push(L),n.forEach((function({name:e,contents:n,dependencies:t=[]}){M.set(e,n);const r={};for(const e of t)r[e.specifier]=e;x.set(e,r)}));const j=k.get({entries:e,excludeEditingTransformers:o});O.set("global",{query:j}),g((()=>{for(const[,{unsubscribe:e}]of O)null==e||e();O.clear()}));const B=(0,h.createNodeJSBuiltinModules)(null!==(E=w.process)&&void 0!==E?E:{},{...I.get(_).environmentVariables,...f});m.stream((({key:e,value:n})=>{B.process.env[e]=n}));const U=(0,p.createModuleSystem)({injectedLibraries:r,loadModuleHook:v,readFileSync:e=>{const n=M.get(e);if(void 0===n)throw new u.CompilationError(`Cannot find compiled file ${e}`);return n},resolveFrom:(e,n,t)=>{if(t){const e=x.get(t);if(e)return e[n].resolvedRequest}},globals:{...w,...B,_codux_module_hot:A}}),W=e=>{try{return c?c({entryPath:e,moduleSystem:U}):U.requireModule(e)}catch(e){throw e instanceof Error?new u.CompilationError(e.message):e}};function H(){for(const e of j.getResults())T.isResourceOfType(e)?M.set(e.getId().filePath,e.getLatest()):C.isResourceOfType(e)&&x.set(e.getId(),e.getLatest())}return j.ready?j.ready.then((()=>(H(),b(U)))).then(D.resolve).catch(D.reject):(H(),D.resolve()),j.subscribe(F),g((()=>j.unsubscribe(F,!0))),P.add((()=>j.unsubscribe(F,!0))),{getExecutionResource:(e,n)=>{const t=[e];return L&&t.push(L),k.get({entries:t,excludeEditingTransformers:o},n)},prepareRender:async(e,n)=>{var t;if(await D.promise,L&&(0,p.loadGlobalSetup)(L,j,T,U.requireModule,o),O.has(e)){const{unsubscribe:n}=O.get(e);null==n||n()}if(n.subscribe(F),O.set(e,{query:n,unsubscribe:()=>n.unsubscribe(F,!0)}),S.add((()=>{var n;if(O.has(e)){const t=O.get(e);null===(n=null==t?void 0:t.unsubscribe)||void 0===n||n.call(t),O.delete(e)}})),await n.ready,!j.isValid()||!n.isValid())throw new u.CompilationError(null!==(t=j.getStatus().message||n.getStatus().message)&&void 0!==t?t:"Compilation failed");for(const e of n.getResults())T.isResourceOfType(e)?M.set(e.getId().filePath,e.getLatest()):C.isResourceOfType(e)&&x.set(e.getId(),e.getLatest());const{beforeEntry:r,afterEntry:i}=n.getMetaData();return r.forEach((e=>W(e))),{executionResource:n,requireRenderable(){const n=l(W(e),e);return i.forEach((e=>W(e))),n},async render(e){var n;const{canvas:t}=(0,p.getOrCreateStage)(e,R);R.updateEnvironmentProperties(null!==(n=e.environmentProps)&&void 0!==n?n:{},u.ENVIRONMENT_PROPERTIES_KEYS),await(null==a?void 0:a({canvas:t,renderable:e}));const r=await e.render(t);r&&S.add(r),performance.mark("preview-finished-loading")}}},dispose:P.dispose,cleanup:S.dispose,moduleSystem:U,resolvedSetupPath:L}},windowController:R,executionResourceFactoryRenderer:k,windowEventEmitter:P}}))},33142:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;const r=t(5163);r.__exportStar(t(43450),n);var o=t(43450);Object.defineProperty(n,"default",{enumerable:!0,get:function(){return r.__importDefault(o).default}})},23575:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.RESOLVE_EXTENSIONS=n.SIMULATION_CANVAS_CLASS_NAME=n.ENVIRONMENT_PROPERTIES_KEYS=void 0,n.ENVIRONMENT_PROPERTIES_KEYS=["windowHeight","windowWidth","windowBackgroundColor","canvasHeight","canvasWidth","canvasBackgroundColor","canvasMargin","canvasPadding"],n.SIMULATION_CANVAS_CLASS_NAME="simulationCanvas",n.RESOLVE_EXTENSIONS=[".ts",".tsx",".js",".jsx",".json"]},41021:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.DependencyGraphComputer=void 0;const r=t(60814);n.DependencyGraphComputer=class{constructor(e,n){this.compiledFileDependencyResourceFactory=e,this.sourceFileDependencyResourceFactory=n}async compute(e){const n=[],t={};for(const t of e)n.push(t);const r=new Set;for(;n.length>0;){const e=n.shift();if(t[e])continue;t[e]={};const o=await this.compiledFileDependencyResourceFactory.getReady(e),i=await this.sourceFileDependencyResourceFactory.getReady(e);for(const[r,{resolvedRequest:s}]of Object.entries({...o.getLatest(),...i.getLatest()}))t[e][r]=s,s&&n.push(s);r.add(o),r.add(i)}return{value:t,dependencies:r,status:{valid:!0}}}async recompute(e){const{value:n,dependencies:t,status:o}=await this.compute(e.getId());return{changes:[(0,r.fullChange)(n)],dependencies:t,status:(0,r.calculateDependantResourceStatus)(e.getSerializedId(),t,o)}}}},32228:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.CompilationError=n.FormatError=void 0;class t extends Error{constructor(){super(...arguments),this.name="FormatError"}}n.FormatError=t;class r extends Error{constructor(){super(...arguments),this.name="CompilationError"}}n.CompilationError=r},37024:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.dependencyManipulator=void 0;const r=t(60814);n.dependencyManipulator={reducer:(e,n)=>({value:n.value,invertingChanges:[(0,r.fullChange)(e)]}),squasher:e=>[e[e.length-1]]}},47951:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163);r.__exportStar(t(23575),n),r.__exportStar(t(41021),n),r.__exportStar(t(32228),n),r.__exportStar(t(37024),n),r.__exportStar(t(48239),n),r.__exportStar(t(65084),n)},48239:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.parseInlineLoaders=n.generateModuleRequest=void 0;const r=t(91570);function o(e,n,t,r){const o=r.relative(e,n);if(r.isAbsolute(o))return o;const i=o.replace(/\\/g,"/"),s=i.startsWith("../")?i:`./${i}`,a=r.extname(s),c=".js"===a&&!t||".ts"===a||".tsx"===a?s.slice(0,-a.length):s;return"index"===r.basename(c)||"index.js"===r.basename(c)?r.dirname(c):c}n.generateModuleRequest=function({contextPath:e,targetPath:n,originalRequest:t,fs:i}){const s=!!t&&".js"===i.extname(t),a=i.findClosestFileSync(e,"package.json"),c=e===n?a:i.findClosestFileSync(n,"package.json");if(c&&a!==c){const a=function(e,n){try{const t=n.readJsonFileSync(e,"utf8");if("object"==typeof t&&null!==t&&"string"==typeof t.name)return t.name}catch{}}(c,i);return t&&!(0,r.isRelativeModuleRequest)(t)?t:a?i.posix.join(a,o(i.dirname(c),n,s,i)):o(e,n,s,i)}return o(e,n,s,i)},n.parseInlineLoaders=function(e){const n=e.lastIndexOf("!"),t=-1!==n,r=t?e.slice(0,n).split("!").filter((e=>!!e)):[];return{request:t?e.slice(n+1):e,loaders:r}}},65084:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.compiledFileId=void 0,n.compiledFileId=(e,n=!1,t="javascript")=>({filePath:e,outputLang:t,excludeEditingTransformers:n})},86656:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.addReactToWindow=void 0,n.addReactToWindow=async function(e,n,t){const{resolvedRequest:r}=await e.resolveFromFile(n,"react");if("string"!=typeof r)throw new Error(`cannot resolve "react" for ${n}`);const{resolvedRequest:o}=await e.resolveFromFile(n,"react-dom");if("string"!=typeof o)throw new Error(`cannot resolve "react-dom" for ${n}`);window.React=t(r),window.ReactDOM=t(o)}},71925:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.createNodeJSBuiltinModules=void 0;const r=t(5163),o=t(43368),i=r.__importDefault(t(34406));n.createNodeJSBuiltinModules=function(e,n){return{process:{...i.default,...e,env:{...e.env,...i.default.env,...n}},Buffer:o.Buffer}}},21759:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.getBoardFromModule=void 0;const r=t(91570);n.getBoardFromModule=e=>{if(!(0,r.isRecord)(e))throw new Error("Couldn't get exports of the board file.");const n=e.default;if(!(0,r.isRecord)(n))throw new Error("File doesn't contain a board.");if(!n.name)throw new Error("Board name is missing.");if("function"!=typeof n.Board)throw new Error("Board render function is missing.");return n}},60829:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163);r.__exportStar(t(86656),n),r.__exportStar(t(21759),n),r.__exportStar(t(38779),n),r.__exportStar(t(64897),n),r.__exportStar(t(98139),n),r.__exportStar(t(23),n)},98139:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.loadGlobalSetup=n.getOrCreateStage=n.resolveGlobalSetupPath=n.createModuleSystem=n.registerToFileChanges=void 0;const r=t(73654),o=t(96435),i=t(93849),s=t(47951);n.registerToFileChanges=function(e,n,t){e.unsubscribeAll(!1);const r=e=>{for(const t of[...e.changed,...e.added])t.getId().filePath&&(0,o.invalidateModule)(t.getId().filePath,n.requireCache);if(t){const e=t();e instanceof Promise&&e.catch(i.reportError)}};return e.subscribe(r),()=>e.unsubscribe(r)},n.createModuleSystem=function({injectedLibraries:e,loadModuleHook:n,readFileSync:t,resolveFrom:i,globals:s={}}){const a=(0,o.createBaseCjsModuleSystem)({dirname:r.win32.dirname,readFileSync:t,resolveFrom:i,globals:s,loadModuleHook:n});for(const[n,t]of e)a.requireCache.set(n,{filename:n,id:n,exports:t,children:[]});return a},n.resolveGlobalSetupPath=async function({globalSetupConfig:e,projectConfig:n,resolver:t}){await n.ready;const r=n.isValid()?n.get(e):null;if(r){const e=await t.resolveFromProjectRoot(r);if(!e)throw new s.CompilationError(`global setup file doesn't exist at ${r}`);return e}return null},n.getOrCreateStage=function(e,n){const t=n.getStage();if(!t){const t=e.setupStage();return n.setStage(t),t}return t},n.loadGlobalSetup=function(e,n,t,r,o){if(e){const i=n.getResult(t,(0,s.compiledFileId)(e,o));(null==i?void 0:i.isValid())&&r(e)}}},23:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0})},64897:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.WindowController=void 0;const r=t(23575);n.WindowController=class{constructor(){this.environmentProperties={},this.canvasIsEmptyListeners=new Set,this.generateStylesheet(),this.createBaseElement()}setStage(e){this.stage=e,this.stage.canvas.classList.add(r.SIMULATION_CANVAS_CLASS_NAME),this.observeCanvasIsEmpty()}getStage(){return this.stage}getStageDimensions(){return this.stage?{window:document.body.getBoundingClientRect().toJSON(),canvas:this.stage.canvas.getBoundingClientRect().toJSON()}:{}}isCanvasEmpty(){var e;return!(null===(e=this.stage)||void 0===e?void 0:e.canvas)||""===this.stage.canvas.innerHTML}setWindowInlineStyleRule(e,n){document.body.style.setProperty(e,n)}updateEnvironmentProperties(e,n=[]){var t,r;const o={};for(const t of n)o[t]=e[t];this.environmentProperties={...this.environmentProperties,...e,...o},null===(t=this.stage)||void 0===t||t.updateCanvas(this.environmentProperties),null===(r=this.stage)||void 0===r||r.updateWindow(this.environmentProperties)}createBaseElement(){const e=document.head.querySelector("base");if(!e||"_blank"!==e.target){const e=document.createElement("base");e.target="_blank",document.head.appendChild(e)}}generateStylesheet(){const e=`<style>\n            html {\n                height: 100%;\n            }\n\n            body {\n                height: 100%;\n                margin: 0;\n                box-sizing: border-box;\n                scrollbar-width: none;\n                -ms-overflow-style: none;\n                overflow: auto;\n                display: flex;\n            }\n\n            body::-webkit-scrollbar {\n                display: none;\n            }\n\n            .${r.SIMULATION_CANVAS_CLASS_NAME} {\n                position: relative;\n            }\n            </style>`;document.head.insertAdjacentHTML("beforeend",e)}addCanvasIsEmptyListener(e){this.canvasIsEmptyListeners.add(e)}removeCanvasIsEmptyListener(e){this.canvasIsEmptyListeners.delete(e)}observeCanvasIsEmpty(){var e;if(null===(e=this.stage)||void 0===e?void 0:e.canvas){let e=this.isCanvasEmpty();const n=new MutationObserver((()=>{var n;if(null===(n=this.stage)||void 0===n?void 0:n.canvas){const n=this.isCanvasEmpty();n!==e&&(e=n,this.canvasIsEmptyListeners.forEach((e=>e(n))))}}));n.observe(this.stage.canvas,{childList:!0})}}}},38779:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.WindowEventEmitter=void 0;const r=t(7934);n.WindowEventEmitter=class{constructor(){this.listenersMap=new Map}subscribe(e){const n=n=>{const t=(0,r.serializeEvent)(n);e(t)};this.listenersMap.set(e,n),this.addWindowEventsListener(n)}unsubscribe(e){const n=this.listenersMap.get(e);n&&(this.removeWindowEventsListener(n),this.listenersMap.delete(e))}addWindowEventsListener(e){r.EVENT_TYPES.forEach((n=>{window.addEventListener(n,e)}))}removeWindowEventsListener(e){r.EVENT_TYPES.forEach((n=>{window.removeEventListener(n,e)}))}}},93104:(e,n,t)=>{e.exports=t(33142)},12535:(e,n,t)=>{e.exports=t(60829)},23870:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163),o=t(93849),i=t(5689),s=r.__importDefault(t(93208)),a=t(2206),c=r.__importDefault(t(82026)),l=r.__importDefault(t(30520)),d=new o.Feature({id:"codeLanguages",dependencies:[s.default.asDependency,c.default.asDependency,l.default.asDependency],api:{languageSlot:o.MapSlot.withType().defineEntity(i.mainEnv),languageProviderSlot:o.MapSlot.withType().defineEntity(a.processingEnv),languageService:o.Service.withType().defineEntity(a.processingEnv).allowRemoteAccess(),codeFormatters:o.Slot.withType().defineEntity(a.processingEnv)}});n.default=d},7959:function(e,n,t){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;var o=t(23870);Object.defineProperty(n,"default",{enumerable:!0,get:function(){return r(o).default}})},83341:(e,n,t)=>{e.exports=t(7959)},93107:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163),o=t(93849),i=t(5689),s=r.__importDefault(t(93208)),a=r.__importDefault(t(1529));n.default=new o.Feature({id:"commander",dependencies:[s.default.asDependency,a.default.asDependency],api:{textualCommandsSlot:o.Slot.withType().defineEntity(i.mainEnv),commandsPrefixesSlot:o.Slot.withType().defineEntity(i.mainEnv),commanderControllerService:o.Service.withType().defineEntity(i.mainEnv),commanderConfig:o.Config.withType().defineEntity({},void 0,i.mainEnv)}})},34262:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;const r=t(5163);var o=t(93107);Object.defineProperty(n,"default",{enumerable:!0,get:function(){return r.__importDefault(o).default}}),r.__exportStar(t(93107),n),r.__exportStar(t(22165),n)},22165:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.HIDDEN_PREFIX=n.DEFAULT_PREFIX=void 0;const r=t(36904);n.DEFAULT_PREFIX={prefix:"",isHidden:!1,description:"Codux Commands",defaultShortcut:r.defaultOpenCommanderShortcut},n.HIDDEN_PREFIX={prefix:">>",isHidden:!0,description:"Codux engineer commands"}},36904:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.defaultOpenCommanderShortcut=void 0;const r=t(62202);n.defaultOpenCommanderShortcut=[r.KEYBOARD.UNIVERSAL_CONTROL,r.KEYBOARD.P]},46548:(e,n,t)=>{e.exports=t(34262)},12061:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.isIsolatedRender=void 0,n.isIsolatedRender=()=>window===window.parent},72873:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.AnimationFrameScheduler=void 0,n.AnimationFrameScheduler=class{constructor(){this.requestAnimationFrameId=0}start(...e){this.requestAnimationFrameId&&cancelAnimationFrame(this.requestAnimationFrameId),this.triggerRequestAnimationFrame(...e)}dispose(){this.requestAnimationFrameId&&cancelAnimationFrame(this.requestAnimationFrameId),this.onDispose()}triggerRequestAnimationFrame(...e){this.requestAnimationFrameId=requestAnimationFrame((()=>{this._onAnimationFrame(...e)}))}_onAnimationFrame(...e){this.onAnimationFrame(...e),this.triggerRequestAnimationFrame(...e)}}},46179:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.stableSort=n.isPermutationOf=void 0,n.isPermutationOf=function(e,n){if(e.length!==n.length)return!1;const t=new Set(e);for(const e of n)if(!t.has(e))return!1;return!0},n.stableSort=function(e,n,t=!1){const r=e.reduce(((e,n,t)=>(e.set(n,t),e)),new Map);return e.sort(((e,o)=>{const i=n(e,o);return 0===i?t?r.get(o)-r.get(e):r.get(e)-r.get(o):i}))}},93482:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.assertIsString=void 0,n.assertIsString=function(e,n="Value is not string"){if("string"!=typeof e)throw Error(n)}},5296:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.clamp=void 0,n.clamp=function(e,n,t){return e<n?n:e>t?t:e}},25561:(e,n)=>{"use strict";var t;Object.defineProperty(n,"__esModule",{value:!0}),n.SymbolKind=void 0,(t=n.SymbolKind||(n.SymbolKind={}))[t.File=0]="File",t[t.Module=1]="Module",t[t.Namespace=2]="Namespace",t[t.Package=3]="Package",t[t.Class=4]="Class",t[t.Method=5]="Method",t[t.Property=6]="Property",t[t.Field=7]="Field",t[t.Constructor=8]="Constructor",t[t.Enum=9]="Enum",t[t.Interface=10]="Interface",t[t.Function=11]="Function",t[t.Variable=12]="Variable",t[t.Constant=13]="Constant",t[t.String=14]="String",t[t.Number=15]="Number",t[t.Boolean=16]="Boolean",t[t.Array=17]="Array",t[t.Object=18]="Object",t[t.Key=19]="Key",t[t.Null=20]="Null",t[t.EnumMember=21]="EnumMember",t[t.Struct=22]="Struct",t[t.Event=23]="Event",t[t.Operator=24]="Operator",t[t.TypeParameter=25]="TypeParameter"},15494:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.content=void 0,n.content={applicationName:"Codux",boardActions:"Board actions"}},24529:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.Debouncer=void 0,n.Debouncer=class{constructor(e,n,t,r=((...e)=>setTimeout(...e)),o=(e=>clearTimeout(e))){this.cb=e,this.waitTime=n,this.maxWaitTime=t,this._setTimeout=r,this._clearTimeout=o}trigger(...e){return new Promise(((n,t)=>{this.timeout&&this._clearTimeout(this.timeout),this.timeout=this._setTimeout((()=>{try{n(this.cb(...e))}catch(e){t(e)}this.maxTimeout&&this._clearTimeout(this.maxTimeout)}),this.waitTime),this.maxTimeout||(this.maxTimeout=this._setTimeout((()=>{try{n(this.cb(...e))}catch(e){t(e)}this.timeout&&this._clearTimeout(this.timeout)}),this.maxWaitTime))}))}cancel(){this.timeout&&this._clearTimeout(this.timeout),this.maxTimeout&&this._clearTimeout(this.maxTimeout)}}},53559:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.delayed=void 0,n.delayed=function(e,n){const t=[];let r=!1;const o=(...i)=>{r?t.push(i):(r=!0,e(...i),setTimeout((()=>{r=!1,t.length&&o(...t.shift())}),n))};return o}},93737:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.Disposable=void 0;const r=t(53433);n.Disposable=class{constructor(){this._isDisposed=!1,this._isDisposing=!1,this.disposables=(0,r.createDisposables)(),this.timeouts=new Set,this.intervals=new Set,this.disposables.add((()=>{this.timeouts.forEach((e=>clearTimeout(e))),this.intervals.forEach((e=>clearInterval(e)))}))}async dispose(){this.disposalGuard(),this._isDisposing=!0,this.disposables.add((()=>this.doDispose())),await this.disposables.dispose(),this._isDisposed=!0,this._isDisposing=!1}get isDisposed(){return this._isDisposed||this._isDisposing}disposalGuard(e=!1){if(this.isDisposed){if(!this._isDisposing||!e)return;throw new Error("Instance was disposed")}}setDisposableTimeout(e,n){this.disposalGuard();const t=setTimeout((()=>{this.timeouts.delete(t),this.isDisposed||e()}),n);return this.timeouts.add(t),t}setDisposableInterval(e,n){this.disposalGuard();const t=setInterval((()=>{this.isDisposed||e()}),n);return this.intervals.add(t),t}doDispose(){}ifNotDisposed(e,n){const t=(...t)=>this.isDisposed?n:e.call(this,...t);return t.disposing=e,t}}},93040:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.enforceSequentialExecution=void 0,n.enforceSequentialExecution=e=>{let n=Promise.resolve();return()=>(n=n.then(e,e),n)}},16031:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.enumValues=void 0,n.enumValues=function*(e){let n=!0;for(const t in e)if("number"==typeof e[t]){n=!1;break}for(const t in e)(n||"number"==typeof e[t])&&(yield e[t])}},53321:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.isErrorLikeObject=n.errorToPlainObject=n.stringifyErrorStack=n.UnreachableCaseError=n.ErrorWithCode=n.getErrorCode=n.toError=void 0;const r=t(33841);n.toError=e=>e instanceof Error?e:new Error(void 0===e?void 0:String(e)),n.getErrorCode=e=>"string"==typeof e.code?e.code:void 0;class o extends Error{constructor(e,n){const{code:t,...r}=null!=n?n:{};super(e,r),this.code=t}}n.ErrorWithCode=o;class i extends Error{constructor(e){super(`Unreachable switch case: ${JSON.stringify(e)}`)}}function s(e){return(0,r.isRecord)(e)&&"string"==typeof e.name&&"string"==typeof e.message}n.UnreachableCaseError=i,n.stringifyErrorStack=function(e){if(s(e)){const{name:n,message:t,stack:r=""}=e,o=`${n}: ${t}`;return r.startsWith(o)?r:`${o}\n${r}`}return String(e)},n.errorToPlainObject=function(e){return{...e,message:e.message,name:e.name,stack:e.stack}},n.isErrorLikeObject=s},1230:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.isPathIncludesDir=n.pathChainToRoot=n.fileRequestPrefix=n.guardPath=n.isSubPath=n.getPackagePath=n.getPackageJsonPath=n.createImportPath=n.getBareImportSpecifier=n.getRelativeImportPath=n.getRelativeModulePath=n.rebaseRelativeModulePath=n.addRelativePrefix=n.isRelativeModuleRequest=n.isRelativeModulePath=n.formatToOSpaths=n.replaceWinSlashes=void 0;const r=t(73654),o=t(63328),i=t(33841);function s(e){return e.startsWith("./")||e.startsWith("../")||e.startsWith("/")}function a(e){return"."===e||".."===e||e.startsWith("./")||e.startsWith("../")}function c(e){return s(e)?e:`./${e}`}function l(e,t){const{relative:o,dirname:s}=r.posix,c=(0,i.getImportPath)(o(s((0,n.replaceWinSlashes)(e)),(0,n.replaceWinSlashes)(t)));return a(c)?c:`./${c}`}function d(e,t,o){const{dirname:s}=r.posix;return(0,i.getImportPath)((0,n.replaceWinSlashes)(e).replace(s((0,n.replaceWinSlashes)(t)),o))}function u(e,n){return n.findClosestFileSync(e,"package.json")}function p(e,n,t){if(!t.isAbsolute(e)||!t.isAbsolute(n))return!1;const r=t.relative(n,e);return""===r||!r.startsWith("..")&&!t.isAbsolute(r)}n.replaceWinSlashes=e=>e.replace(/\\/g,"/"),n.formatToOSpaths=e=>(0,i.isWindowsStyleAbsolutePath)(e)?e.replace(/\//g,"\\"):e,n.isRelativeModulePath=s,n.isRelativeModuleRequest=a,n.addRelativePrefix=c,n.rebaseRelativeModulePath=function(e,n){return s(n)||(0,i.isWindowsStyleAbsolutePath)(n)?c(r.posix.relative(r.posix.dirname(e),n)):n},n.getRelativeModulePath=function(e,t){const{relative:o,dirname:i}=r.win32;return c((0,n.replaceWinSlashes)(o(i(e),t)))},n.getRelativeImportPath=l,n.getBareImportSpecifier=d,n.createImportPath=function({importedFilePath:e,targetFilePath:n,targetPackageJsonPath:t,fs:r}){const i=u(e,r),s=i?(0,o.getPackageName)(i,r):void 0;return i!==t&&i&&s?d(e,i,s):l(n,e)},n.getPackageJsonPath=u,n.getPackagePath=function(e,n){const t=u(e,n);return t?n.dirname(t):void 0},n.isSubPath=p,n.guardPath=function(e,n,t){if("string"!=typeof n)throw new Error("Unexpected path type "+typeof n);if(""===n)throw new Error("Unexpected empty path");if("/"===n||h.test(n))throw new Error(`Unexpected root directory path ${n}`);if(!(null==t?void 0:t.allowRelative)&&!e.isAbsolute(n))throw new Error(`Unexpected relative path ${n}`);if((null==t?void 0:t.restrictTo)&&!e.isAbsolute(t.restrictTo))throw new Error("Invalid option: restrictTo should be an absolute path");if((null==t?void 0:t.restrictTo)&&!p(e.resolve(n),t.restrictTo,e))throw new Error(`Unexpected path '${n}' outside of '${t.restrictTo}'`)};const h=/^[a-zA-Z]:[\\/]?$/;function*f(e){let n;for(;n!==e;)yield e,n=e,e=r.win32.dirname(e)}n.fileRequestPrefix="file://",n.pathChainToRoot=f,n.isPathIncludesDir=function(e,n){for(const t of f(e))if(n===r.win32.basename(t))return!0;return!1}},63328:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.getPackageName=void 0,n.getPackageName=function(e,n){try{const{name:t}=JSON.parse(n.readFileSync(e,"utf8"));if(!t||"string"!=typeof t)return;return t}catch{return}}},33841:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.calculateReversedObject=n.escapeCSS=n.newMacrotask=n.prev=n.next=n.last=n.getImportPath=n.isWindowsStyleAbsolutePath=n.awaitRecord=n.groupBy=n.getDTSPath=n.isTsOrJS=n.isTypeAffectingFileOrDir=n.isDirPath=n.isJavaScriptFile=n.isTypeScriptFile=n.isJsonFile=n.reportError=n.asyncNoop=n.noop=n.notNullish=n.isRecord=n.getObjectKeys=n.unique=n.exclude=void 0;const r=t(73654),o=t(48074);n.exclude=function(...e){return function(n){for(const t of e)if(t===n)return!1;return!0}},n.unique=e=>Array.from(new Set(e)),n.getObjectKeys=e=>Object.keys(e),n.isRecord=function(e){return null!==e&&"object"==typeof e},n.notNullish=function(e){return null!=e},n.noop=()=>{},n.asyncNoop=()=>Promise.resolve(),n.reportError=e=>console.error(e),n.isJsonFile=e=>e.endsWith(".json"),n.isTypeScriptFile=e=>e.endsWith(".ts")||e.endsWith(".tsx"),n.isJavaScriptFile=e=>e.endsWith(".js")||e.endsWith(".jsx")||e.endsWith(".mjs")||e.endsWith(".cjs"),n.isDirPath=e=>0===(0,r.extname)(e).length,n.isTypeAffectingFileOrDir=e=>(0,n.isJsonFile)(e)||(0,n.isTypeScriptFile)(e)||(0,n.isJavaScriptFile)(e)||(0,n.isDirPath)(e),n.isTsOrJS=e=>(0,n.isTypeScriptFile)(e)||(0,n.isJavaScriptFile)(e),n.getDTSPath=e=>(e.endsWith(".js")?e=e.slice(0,e.length-3):e.endsWith(".jsx")&&(e=e.slice(0,e.length-4)),e+".d.ts"),n.groupBy=function(e,n){return e.reduce(((e,t)=>{const r=e.get(t[n]);return r?r.push(t):e.set(t[n],[t]),e}),new Map)},n.awaitRecord=async function(e){const n=Object.keys(e),t=await Promise.all(n.map((n=>e[n]))),r={};for(let e=0;e<n.length;e++)r[n[e]]=t[e];return r},n.isWindowsStyleAbsolutePath=function(e){return!r.posix.isAbsolute(e)&&r.win32.isAbsolute(e)},n.getImportPath=function(e){const n=[".d.ts",".ts",".tsx",".js",".jsx"];for(const t of n)if(e.endsWith(t))return e.slice(0,-t.length);return e},n.last=function(e){return e.at(-1)},n.next=function(e,n){const t=e.indexOf(n);return-1===t?void 0:e[t+1]},n.prev=function(e,n){const t=e.indexOf(n);return-1===t?void 0:e[t-1]},n.newMacrotask=()=>(0,o.sleep)(0),n.escapeCSS=e=>e.replace(/\W/giu,(e=>{var n;return`\\${(null!==(n=e.codePointAt(0))&&void 0!==n?n:65533).toString(16)} `})),n.calculateReversedObject=e=>{const n={};for(const[t,r]of Object.entries(e))r&&(n[r]||(n[r]=t));return n}},57770:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163);r.__exportStar(t(72873),n),r.__exportStar(t(93482),n),r.__exportStar(t(5296),n),r.__exportStar(t(25561),n),r.__exportStar(t(15494),n),r.__exportStar(t(24529),n),r.__exportStar(t(53559),n),r.__exportStar(t(16031),n),r.__exportStar(t(53321),n),r.__exportStar(t(1230),n),r.__exportStar(t(33841),n),r.__exportStar(t(99453),n),r.__exportStar(t(21254),n),r.__exportStar(t(15612),n),r.__exportStar(t(35889),n),r.__exportStar(t(77123),n),r.__exportStar(t(99233),n),r.__exportStar(t(32370),n),r.__exportStar(t(15243),n),r.__exportStar(t(3568),n),r.__exportStar(t(24537),n),r.__exportStar(t(38671),n),r.__exportStar(t(74252),n),r.__exportStar(t(78442),n),r.__exportStar(t(15243),n),r.__exportStar(t(32370),n),r.__exportStar(t(37333),n),r.__exportStar(t(3568),n),r.__exportStar(t(46179),n),r.__exportStar(t(97880),n),r.__exportStar(t(93040),n),r.__exportStar(t(36425),n),r.__exportStar(t(40511),n),r.__exportStar(t(93737),n),r.__exportStar(t(8152),n)},99453:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.loadScript=void 0,n.loadScript=(e,n)=>new Promise(((t,r)=>{const o=n.createElement("script");o.src=e,o.onload=()=>t(),o.onerror=r,o.crossOrigin="anonymous",n.head.appendChild(o)}))},97880:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.LRUCache=void 0,n.LRUCache=class{constructor(e={}){var n;if(this.config=e,this.cache=new Map,this.keys=[],this.maxSize=null!==(n=e.maxSize)&&void 0!==n?n:1/0,this.maxSize<1)throw new Error("LRUCache max size must be larger than 0")}set(e,n){if(this.updateKeysOrder(e),this.keys.length>this.maxSize){const e=this.keys.shift();this.cache.delete(e)}this.cache.set(e,n)}get(e){if(this.cache.has(e))return this.updateKeysOrder(e),this.cache.get(e)}delete(e){const n=this.keys.indexOf(e);n>-1&&this.keys.splice(n,1),this.cache.delete(e)}has(e){return this.cache.has(e)}size(){return this.cache.size}clear(){this.cache.clear(),this.keys=[]}updateKeysOrder(e){const n=this.keys.indexOf(e);n>-1&&this.keys.splice(n,1),this.keys.push(e)}}},40511:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.deepIterateOverKeyValuePairs=void 0,n.deepIterateOverKeyValuePairs=function({in:e,perform:n}){JSON.stringify(e,((e,t)=>(n(e,t),t)))}},21254:(e,n)=>{"use strict";function t(e,n,t){if(e.caseSensitive){const r=e.join(n,t);return e.existsSync(r)?t:void 0}try{const r=t.toLowerCase();return e.readdirSync(n).find((e=>e.toLowerCase()===r))}catch{return}}Object.defineProperty(n,"__esModule",{value:!0}),n.pathToTrueCase=void 0,n.pathToTrueCase=function(e,n){const r=e.resolve(n);if(e.caseSensitive)return r;const o=function(e,n){const t=[];for(;;){const r=e.basename(n);if(""===n||"."===n||".."===n||""===r)return t.unshift(n||"."),t;t.unshift(r),n=e.dirname(n)}}(e,r);for(let n=1;n<o.length;n++){const r=e.join(...o.slice(0,n)),i=t(e,r,o[n]);if(!i)break;o[n]=i}return e.join(...o)}},15612:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.pick=void 0,n.pick=function(e,n){const t={};for(const r of n)t[r]=e[r];return t}},35889:(e,n,t)=>{"use strict";var r,o=t(34406);Object.defineProperty(n,"__esModule",{value:!0}),n.getOs=n.isElectronRendererProcess=n.isWindows=n.isMac=void 0;const i=null===(r=globalThis.process)||void 0===r?void 0:r.platform;n.isMac=i?"darwin"===i:navigator.platform.includes("Mac"),n.isWindows=i?"win32"===i:navigator.platform.includes("Win32"),n.isElectronRendererProcess="object"==typeof o&&"renderer"===o.type,n.getOs=()=>i||(navigator.platform.includes("Mac")?"darwin":navigator.platform.includes("Win")?"win32":navigator.platform.includes("Linux")?"linux":navigator.platform)},99233:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.getLinesPosFromFileContent=void 0;const r=t(77123);n.getLinesPosFromFileContent=(e,n)=>{const t=e.split(/\n/),o=(0,r.charPosToLinePos)(t,n);return{line:o.line+1,column:o.char+1}}},77123:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.charPosToLinePosWithLineStarts=n.charPosToLinePos=void 0;const r=t(33841);n.charPosToLinePos=function(e,n){let t=0,r=0;for(const o of e){if(t+1+o.length>n)return{line:r,char:n-t};r++,t+=o.length+1}return{line:e.length-1,char:e[e.length-1].length}},n.charPosToLinePosWithLineStarts=function(e,n,t){if(t<=0||0===e.length)return{line:0,char:0};for(let n=1;n<e.length;n++)if(e[n]>t)return{line:n-1,char:t-e[n-1]};const o=n-(0,r.last)(e);return{line:e.length-1,char:o}}},32370:(e,n)=>{"use strict";function t(e,n,t){return e*(t-n)+n}function r(e=0){return function(){let n=e+=1831565813;return n=Math.imul(n^n>>>15,1|n),n^=n+Math.imul(n^n>>>7,61|n),((n^n>>>14)>>>0)/4294967296}}function o(e){const n=r(e);return(e,r)=>Math.floor(t(n(),e,r))}Object.defineProperty(n,"__esModule",{value:!0}),n.seededRandomInt=n.createRandomIntWithSeed=n.mulberry32=n.normToRage=void 0,n.normToRage=t,n.mulberry32=r,n.createRandomIntWithSeed=o,n.seededRandomInt=o(1)},37333:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.range=void 0,n.range=function(e){if(e<0)throw new RangeError("The range count must be non-negative");const n=[];for(let t=0;t<e;t++)n.push(t);return n}},15243:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.REQUIRED_PARAMS=void 0,n.REQUIRED_PARAMS=new Set(["feature","config"])},3568:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.addToSet=void 0,n.addToSet=(e,n)=>{for(const t of n)e.add(t)}},38671:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.MultiSignal=n.Signal=void 0;class t extends Set{constructor(){super(...arguments),this.subscribe=e=>{this.add(e)},this.unsubscribe=e=>{this.delete(e)},this.notify=e=>{for(const n of this)n(e)}}}n.Signal=t,n.MultiSignal=class{constructor(){this.signals=new Map,this.has=e=>this.signals.has(e),this.subscribe=(e,n)=>{const r=this.signals.get(e);r?r.add(n):this.signals.set(e,new t([n]))},this.unsubscribe=(e,n)=>{const t=this.signals.get(e);null==t||t.delete(n),0===(null==t?void 0:t.size)&&this.signals.delete(e)},this.delete=e=>{this.signals.delete(e)},this.notify=(e,n)=>{var t;null===(t=this.signals.get(e))||void 0===t||t.notify(n)}}}},24537:(e,n)=>{"use strict";var t;function r(e){return 0===e.length?e:e.charAt(0).toUpperCase()+e.slice(1)}function o(e){return(0,n.splitIntoWords)(e).join("-").toLowerCase()}function i(e){return(0,n.splitIntoWords)(e).map((e=>r(e.toLowerCase()))).join("")}function s(e){return(0,n.splitIntoWords)(e).map(((e,n)=>n>0?r(e.toLowerCase()):e.toLowerCase())).join("")}function a(e,n,t="\n"){const r=t.length;let o=0,i=0;for(let s=0;s<e.length+1;s++){if(o===n.line&&i===n.character)return s;e.slice(s,s+r)===t?(o++,i=0):i++}return-1}Object.defineProperty(n,"__esModule",{value:!0}),n.removeNewLines=n.noIdents=n.equalIdents=n.includesCaseInsensitive=n.lspRangeToTS=n.lineAndColumnToIndex=n.indexToLineAndColumn=n.toCSSCamelCase=n.toCSSKebabCase=n.toNamingConvention=n.toCamelCase=n.toPascalCase=n.toKebabCase=n.splitIntoWords=n.startsWithUpperCase=n.capitalizeFirstLetter=n.isValidNamingConvention=n.NamingConvention=void 0,function(e){e.KebabCase="kebab-case",e.PascalCase="pascal-case",e.CamelCase="camel-case"}(t=n.NamingConvention||(n.NamingConvention={})),n.isValidNamingConvention=function(e){return Object.values(t).some((n=>n===e))},n.capitalizeFirstLetter=r,n.startsWithUpperCase=function(e){if(0===e.length)return!1;const n=e.charAt(0);return!(n.toLowerCase()===n.toUpperCase())&&n===n.toUpperCase()},n.splitIntoWords=e=>{var n;let t=null!==(n=e.match(/[a-z0-9]+/gi))&&void 0!==n?n:[];return t=t.flatMap((e=>e.split(/(\d+)/g))),t=t.flatMap((e=>e.split(/([A-Z]+)(?=[A-Z][a-z])/g))),t=t.flatMap((e=>e.split(/([A-Z]?[a-z]+)/g))),t.filter((e=>e))},n.toKebabCase=o,n.toPascalCase=i,n.toCamelCase=s,n.toNamingConvention=function(e,n){switch(n){case t.KebabCase:return o(e);case t.PascalCase:return i(e);case t.CamelCase:return s(e)}},n.toCSSKebabCase=function(e){const n=e.charAt(0);return e.length&&n===n.toUpperCase()&&n!==n.toLowerCase()?`-${o(e)}`:o(e)},n.toCSSCamelCase=function(e){return"-"===e.charAt(0)?r(s(e)):s(e)},n.indexToLineAndColumn=function(e,n,t="\n"){if(n>e.length)return{character:-1,line:-1};const r=t.length;let o=0,i=0;for(let s=0;s<n;s++)e.slice(s,s+r)===t?(o++,i=0):i++;return{line:o,character:i}},n.lineAndColumnToIndex=a,n.lspRangeToTS=(e,n,t)=>{if(!e)return{start:0,length:0};const r=a(e,{line:t.start.line,character:t.start.character});return{start:r,length:a(e,{line:t.end.line,character:t.end.character})-r}},n.includesCaseInsensitive=function(e,n){return e.toLowerCase().includes(n.toLowerCase())},n.equalIdents=function(e,n,t="\n"){const r=e.split(t);return n.split(t).map(((e,n)=>{const t=r[n];if(!t)return e;const o=t.trimStart();return t.slice(0,t.length-o.length)+e.trimStart()})).join(t)},n.noIdents=function(e,n="\n"){return e.split(n).map((e=>e.trimStart())).join(n)},n.removeNewLines=e=>e.replace(/\r?\n/g,"")},36425:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.textRangeHitTest=void 0,n.textRangeHitTest=(e,n)=>e.from>=n.from&&e.from<=n.to||e.to>=n.from&&e.to<=n.to||n.from>=e.from&&n.from<=e.to||n.to>=e.from&&n.to<=e.to},74252:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.tokenizeCSSURLS=n.tokenize=void 0;const t=e=>"("===e||")"===e||","===e||";"===e||":"===e,r=e=>"'"===e||'"'===e||"`"===e,o=e=>" "===e||"\t"===e||"\r"===e||"\n"===e;function i(e){const n=[];let i="",s="",a="",c="",l=0,d=0;for(const n of e)d+=n.length,c?(s+=n,n===c&&"\\"!==i&&(c="",u("string"))):a?(s+=n,"line-comment"===a&&"\n"===n?(a="",u("line-comment")):"multi-comment"===a&&"/"===n&&"*"===i&&(a="",u("multi-comment"))):"/"===n&&"/"===e[d]?(u(),s+=n,a="line-comment"):"/"===n&&"*"===e[d]?(u(),s+=n,a="multi-comment"):r(n)?(u(),s+=n,c=n):t(n)?(u(),s+=n,u(n)):o(n)&&!o(i)||!o(n)&&o(i)?(u(),s+=n):s+=n,i=n;function u(e){if(0===s.length)return;const t=l+s.length;n.push({value:s,type:null!=e?e:s.trim().length?"text":"space",start:l,end:t}),l=t,s=""}return s.length&&(a?u("line-comment"===a?"line-comment":"unclosed-comment"):c?u("unclosed-string"):u()),n}n.tokenize=i,n.tokenizeCSSURLS=function(e){return function(e){var n;const t=[];let r;for(let o=0;o<e.length;o++){const i=e[o];r?(r.push(i),")"===i.type&&(t.push(r),r=void 0)):"text"===i.type&&"url"===i.value&&"("===(null===(n=e[o+1])||void 0===n?void 0:n.type)&&(r=[i])}return t}(i(e))}},78442:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0})},8152:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.WorkQueue=void 0;const r=t(48074);n.WorkQueue=class{constructor(e){this.hooks=e,this.running=0,this.ended=0,this.queue=[],this.workDone=(0,r.deferred)()}start(){return this.processTasks(),this.workDone.promise}addTask(e){this.queue.push(e)}processTasks(){for(let e=0;e<this.queue.length;e++){const n=this.queue[e];try{this.hooks.processTask(n,this)}catch(e){this.hooks.onError(n,e)}}this.queue.length=0,this.running===this.ended&&this.workDone.resolve()}startTask(){this.running++}finishTask(){this.ended++}finishTaskWithErrors(e,n){this.ended++,this.hooks.onError(e,n)}}},91570:(e,n,t)=>{e.exports=t(57770)},80134:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.defaultCompiledFileExtention=void 0;const r=t(5163),o=t(93849),i=r.__importStar(t(32510)),s=r.__importDefault(t(93208)),a=r.__importStar(t(2206)),c=r.__importDefault(t(19608));n.defaultCompiledFileExtention=".compiled",n.default=new o.Feature({id:"compilation",dependencies:[s.default.asDependency,a.default.asDependency,i.default.asDependency,c.default.asDependency],api:{compilationSlot:o.Slot.withType().defineEntity(a.processingEnv),compilationStore:o.Service.withType().defineEntity(a.processingEnv).allowRemoteAccess(),compiledFilesManager:(0,i.defineComputedResource)().defineEntity(a.processingEnv),compilationInvalidationManager:(0,i.defineComputedResource)().defineEntity(a.processingEnv)}})},97569:function(e,n,t){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;var o=t(80134);Object.defineProperty(n,"default",{enumerable:!0,get:function(){return r(o).default}})},25447:(e,n,t)=>{e.exports=t(97569)},95944:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163),o=t(93849),i=r.__importDefault(t(34302)),s=r.__importDefault(t(2206)),a=r.__importDefault(t(58729));n.default=new o.Feature({id:"demoDiscovery",dependencies:[i.default.asDependency,s.default.asDependency,a.default.asDependency],api:{}})},7822:function(e,n,t){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;var o=t(95944);Object.defineProperty(n,"default",{enumerable:!0,get:function(){return r(o).default}})},97903:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.demoPlugin=n.isBoardNode=void 0;const r=t(9240);n.isBoardNode=e=>!!e&&(0,r.isNodeOfKind)("board",e),n.demoPlugin=(0,r.packPlugin)()({kind:"board",modifiers:{addEnvironmentProps:(e,{value:n})=>({...e,environmentProps:n}),setName:(e,{name:n})=>({...e,name:r.stringPlugin.modifiers.setValue(e.name,{value:n})}),removeProps:e=>({...e,props:void 0})},createBlank:e=>({kind:"board",astNodeId:e(),name:r.stringPlugin.createBlank(e),board:r.nullPlugin.createBlank(e)}),getNodeChildren:e=>{const n=[e.name,e.board];return e.props&&n.push(e.props),e.environmentProps&&n.push(e.environmentProps),n},replaceChild:(e,n,t)=>{var o,i;if((0,r.isStringNode)(t)&&e.name.astNodeId===n)return{...e,name:t};if((0,r.isObjectNode)(t)&&(null===(o=e.props)||void 0===o?void 0:o.astNodeId)===n)return{...e,props:t};if((0,r.isObjectNode)(t)&&(null===(i=e.environmentProps)||void 0===i?void 0:i.astNodeId)===n)return{...e,environmentProps:t};if(e.board.astNodeId===n)return{...e,board:t};throw new Error("child not found")}})},12836:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163);r.__exportStar(t(24569),n),r.__exportStar(t(97903),n)},24569:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.BOARD_FILE_TAG=void 0,n.BOARD_FILE_TAG="board-file-tag"},45272:(e,n,t)=>{e.exports=t(7822)},26709:(e,n,t)=>{e.exports=t(12836)},56830:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163),o=t(93849),i=r.__importStar(t(2206)),s=r.__importDefault(t(58729));n.default=new o.Feature({id:"discovery",dependencies:[i.default.asDependency,s.default.asDependency],api:{extensionsConfig:o.Slot.withType().defineEntity(i.processingEnv)}})},8221:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;const r=t(5163);var o=t(56830);Object.defineProperty(n,"default",{enumerable:!0,get:function(){return r.__importDefault(o).default}}),r.__exportStar(t(56830),n)},34302:(e,n,t)=>{e.exports=t(8221)},846:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163),o=t(93849),i=r.__importDefault(t(93208)),s=r.__importDefault(t(1529)),a=r.__importStar(t(2206)),c=r.__importDefault(t(60456));n.default=new o.Feature({id:"environmentInfo",dependencies:[a.default.asDependency,i.default.asDependency,s.default.asDependency,c.default.asDependency],api:{itemProviders:o.Slot.withType().defineEntity(a.processingEnv),dataService:o.Service.withType().defineEntity(a.processingEnv).allowRemoteAccess()},context:{envSpecificProviders:a.processingEnv.withContext()}})},39451:function(e,n,t){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;var o=t(846);Object.defineProperty(n,"default",{enumerable:!0,get:function(){return r(o).default}})},73561:(e,n,t)=>{e.exports=t(39451)},59178:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163),o=t(93849),i=r.__importStar(t(2206)),s=r.__importStar(t(32510));n.default=new o.Feature({id:"fileAssets",dependencies:[i.default.asDependency,s.default.asDependency],api:{fileTaggerSlots:o.Slot.withType().defineEntity(i.processingEnv),assets:(0,s.defineComputedResource)().defineEntity(i.processingEnv)}})},18380:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;const r=t(5163);var o=t(59178);Object.defineProperty(n,"default",{enumerable:!0,get:function(){return r.__importDefault(o).default}}),r.__exportStar(t(59178),n)},58729:(e,n,t)=>{e.exports=t(18380)},22856:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.COMPONENTS_TASK_ID=n.FILE_COMPONENTS_TYPE=void 0;const r=t(5163),o=t(93849),i=t(32510),s=t(5689),a=r.__importStar(t(2206)),c=r.__importDefault(t(93104)),l=r.__importDefault(t(45272)),d=r.__importDefault(t(58729)),u=r.__importDefault(t(94400)),p=r.__importDefault(t(27628)),h=r.__importDefault(t(60456)),f=r.__importDefault(t(93208)),m=r.__importDefault(t(54690)),g=r.__importDefault(t(71815)),y=r.__importDefault(t(89111));n.FILE_COMPONENTS_TYPE="fileComponents",n.COMPONENTS_TASK_ID="components-discovery";const _=(0,i.defineComputedResource)().defineEntity(a.processingEnv),b=(0,i.defineComputedResource)().defineEntity(a.processingEnv),v=(0,i.defineComputedResource)().defineEntity(a.processingEnv);n.default=new o.Feature({id:n.FILE_COMPONENTS_TYPE,api:{demoComponentLocationsManager:_,componentsAndBoardsManager:b,demoComponentLocationsManagerMain:_.defineConsumer(s.mainEnv),componentsManager:v,componentsManagerMain:v.defineConsumer(s.mainEnv)},dependencies:[c.default.asDependency,a.default.asDependency,u.default.asDependency,l.default.asDependency,p.default.asDependency,f.default.asDependency,g.default.asDependency,y.default.asDependency,d.default.asDependency,h.default.asDependency,m.default.asDependency]})},46218:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;const r=t(5163);r.__exportStar(t(22856),n);var o=t(22856);Object.defineProperty(n,"default",{enumerable:!0,get:function(){return r.__importDefault(o).default}})},91821:(e,n,t)=>{e.exports=t(46218)},98617:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163),o=t(93849),i=r.__importDefault(t(20471)),s=r.__importDefault(t(93208));n.default=new o.Feature({id:"firebaseAuthUi",dependencies:[i.default.asDependency,s.default.asDependency],api:{firebaseAuthUiOptions:new o.Config({})}})},14029:function(e,n,t){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;var o=t(98617);Object.defineProperty(n,"default",{enumerable:!0,get:function(){return r(o).default}})},82983:(e,n,t)=>{e.exports=t(14029)},74853:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163),o=t(93849),i=r.__importStar(t(2206)),s=r.__importDefault(t(20471)),a=r.__importDefault(t(93208)),c=r.__importDefault(t(54690));n.default=new o.Feature({id:"firebaseFsPersistency",dependencies:[i.default.asDependency,s.default.asDependency,a.default.asDependency,c.default.asDependency],api:{firebaseFsServiceProcessing:o.Service.withType().defineEntity(i.processingEnv).allowRemoteAccess((0,o.declareComEmitter)("onFileSystemChange","removeFileSystemChangeHandler"))}})},21479:function(e,n,t){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;var o=t(74853);Object.defineProperty(n,"default",{enumerable:!0,get:function(){return r(o).default}})},82039:(e,n,t)=>{e.exports=t(21479)},94703:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163),o=t(93849),i=t(5689),s=r.__importDefault(t(93208)),a=t(9011);n.default=new o.Feature({id:"firebasePersistency",dependencies:[s.default.asDependency],api:{firebasePersistencyServiceOptions:new o.Config({rootCollectionId:"projects",testingMode:!1}),firebaseConfig:new o.Config(a.firebaseConfig),firebasePersistencyService:o.Service.withType().defineEntity(i.mainEnv),firebaseAuthService:o.Service.withType().defineEntity(i.mainEnv),firebaseCloneHandlers:o.Slot.withType().defineEntity(i.mainEnv)}})},70537:function(e,n,t){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;var o=t(94703);Object.defineProperty(n,"default",{enumerable:!0,get:function(){return r(o).default}})},9011:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.firebaseConfig=void 0,n.firebaseConfig={apiKey:"AIzaSyD-IS7lkB3o9GioLGayvTlOAgl2EFQnKrY",authDomain:"localhost",projectId:"demo-project",storageBucket:"core3-firebase-9b327.appspot.com",messagingSenderId:"491604166384",appId:"1:491604166384:web:fb676c56b4fdb306bd6435"}},20471:(e,n,t)=>{e.exports=t(70537)},68941:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.Context=void 0;const r=t(5163),o=t(93849),i=r.__importStar(t(2206));n.default=new o.Feature({id:"gitCommands",dependencies:[i.default.asDependency],api:{gitCommandsService:o.Service.withType().defineEntity(i.processingEnv).allowRemoteAccess(),gitUtilsService:o.Service.withType().defineEntity(i.processingEnv).allowRemoteAccess()},context:{gitCommandsContext:i.processingEnv.withContext()}}),n.Context=i.processingEnv.useContext("live-server")},54718:function(e,n,t){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;var o=t(68941);Object.defineProperty(n,"default",{enumerable:!0,get:function(){return r(o).default}})},35784:(e,n,t)=>{e.exports=t(54718)},48337:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163),o=t(93849),i=t(32510),s=r.__importDefault(t(35784)),a=r.__importStar(t(2206)),c=t(5689),l=r.__importDefault(t(58729)),d=(0,i.defineOneWayResource)().defineEntity(a.processingEnv),u=(0,i.defineOneWayResource)().defineEntity(a.processingEnv),p=(0,i.defineComputedResource)().defineEntity(a.processingEnv),h=(0,i.defineOneWayResource)().defineEntity(a.processingEnv),f=(0,i.defineOneWayResource)().defineEntity(a.processingEnv),m=(0,i.defineOneWayResource)().defineEntity(a.processingEnv),g=(0,i.defineComputedResource)().defineEntity(a.processingEnv),y=(0,i.defineComputedResource)().defineEntity(a.processingEnv);n.default=new o.Feature({id:"gitRevisions",dependencies:[a.default.asDependency,s.default.asDependency,l.default.asDependency],api:{gitService:o.Service.withType().defineEntity(a.processingEnv).allowRemoteAccess(),gitDetector:o.Service.withType().defineEntity(a.processingEnv).allowRemoteAccess(),gitFetcher:o.Service.withType().defineEntity(a.processingEnv).allowRemoteAccess(),gitFetcherOption:new o.Config({fetchInterval:6e5,enabled:!0}),gitSyncRepoService:o.Service.withType().defineEntity(a.processingEnv).allowRemoteAccess(),gitHeadResourceManager:d,gitHeadResourceManagerMain:d.defineConsumer(c.mainEnv),gitRepoStatusResourceManager:u,gitRepoStatusResourceManagerMain:u.defineConsumer(c.mainEnv),gitFileStatusResourceManager:p,gitFileStatusResourceManagerMain:p.defineConsumer(c.mainEnv),gitBranchListResourceManager:h,gitBranchListResourceManagerMain:h.defineConsumer(c.mainEnv),gitMergeStateResourceManager:f,gitMergeStateResourceManagerMain:f.defineConsumer(c.mainEnv),gitSyncRepoResourceManager:m,gitSyncRepoResourceManagerMain:m.defineConsumer(c.mainEnv),gitTrackingBranchResourceManager:g,gitTrackingBranchResourceManagerMain:g.defineConsumer(c.mainEnv),gitHeadFileContentResourceManager:y,gitHeadFileContentResourceManagerMain:y.defineConsumer(c.mainEnv),gitConflictsService:o.Service.withType().defineEntity(a.processingEnv).allowRemoteAccess(),gitEventEmitter:o.Service.withType().defineEntity(a.processingEnv),gitMonitoringService:o.Service.withType().defineEntity(a.processingEnv).allowRemoteAccess()}})},3486:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;const r=t(5163);r.__exportStar(t(48337),n);var o=t(48337);Object.defineProperty(n,"default",{enumerable:!0,get:function(){return r.__importDefault(o).default}})},72975:(e,n,t)=>{e.exports=t(3486)},89580:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(93849),o=t(5689);n.default=new r.Feature({id:"globalEvents",dependencies:[],api:{globalWindowEventEmitter:r.Service.withType().defineEntity(o.mainEnv),previewsListenerService:r.Service.withType().defineEntity(o.mainEnv)}})},18507:function(e,n,t){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;var o=t(89580);Object.defineProperty(n,"default",{enumerable:!0,get:function(){return r(o).default}})},82348:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163);r.__exportStar(t(49424),n),r.__exportStar(t(59409),n)},49424:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.EVENT_TYPES=n.mouseEventSerializedKeys=n.MOUSE_EVENTS=n.keyboardEventSerializedKeys=n.KEYBOARD_EVENTS=void 0,n.KEYBOARD_EVENTS=["keydown","keyup"],n.keyboardEventSerializedKeys=["type","key","code","altKey","shiftKey","metaKey","ctrlKey"],n.MOUSE_EVENTS=["mousedown","mouseup"],n.mouseEventSerializedKeys=["type","clientX","clientY"],n.EVENT_TYPES=[...n.KEYBOARD_EVENTS,...n.MOUSE_EVENTS]},59409:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.serializeEvent=n.isFocusableTarget=void 0;const r=t(91570),o=t(49424);n.isFocusableTarget=({target:e})=>e instanceof HTMLElement&&e.isContentEditable||e instanceof HTMLInputElement&&!["button","submit","reset","checkbox"].includes(e.type)||e instanceof HTMLTextAreaElement||e instanceof HTMLSelectElement,n.serializeEvent=e=>{if(i(e))return{...(0,r.pick)(e,o.keyboardEventSerializedKeys),isFocusableTarget:(0,n.isFocusableTarget)(e)};if(s(e))return(0,r.pick)(e,o.mouseEventSerializedKeys);throw new Error(`Cannot serialize event of unknown type: ${e.type}`)};const i=e=>o.KEYBOARD_EVENTS.includes(e.type),s=e=>o.MOUSE_EVENTS.includes(e.type)},7967:(e,n,t)=>{e.exports=t(18507)},7934:(e,n,t)=>{e.exports=t(82348)},13757:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.defaultConfig=void 0;const r=t(5163),o=r.__importDefault(t(1529)),i=r.__importDefault(t(60456)),s=r.__importDefault(t(7967)),a=t(93849),c=t(32510),l=r.__importStar(t(5689)),d=r.__importDefault(t(59995)),u=r.__importDefault(t(83654));n.defaultConfig={areas:{content:{type:"grid-area",controls:!0,acceptDrag:!1,activeTab:"",semanticId:"content"}},headerHeight:"42px",layout:{rows:"1fr",columns:"1fr",areas:'"content"'},openPanels:[],overlays:[],panelMinWidth:244,panelMaxWidth:500,focusedTab:{id:"",area:"content"},resizers:!1},n.default=new a.Feature({id:"gui",dependencies:[a.COM.asDependency,l.default.asDependency,u.default.asDependency,o.default.asDependency,i.default.asDependency,d.default.asDependency,s.default.asDependency],api:{sideBarConfig:new a.Config({tabSorting:[]}),contentConfig:new a.Config(n.defaultConfig),headerPanelConfig:new a.Config({}),headerPanelSlot:a.Slot.withType().defineEntity(l.mainEnv),footerPanelSlot:a.Slot.withType().defineEntity(l.mainEnv),documentTitleSlot:a.Slot.withType().defineEntity(l.mainEnv),panelFactory:a.Slot.withType().defineEntity(l.mainEnv),overlayPanelFactory:a.Slot.withType().defineEntity(l.mainEnv),homeScreenPanelFactory:a.Slot.withType().defineEntity(l.mainEnv),sidebarPanelSlot:a.OrderedSlot.withType().defineEntity(l.mainEnv),errorBoundarySlot:a.Slot.withType().defineEntity(l.mainEnv),contextSlot:a.Slot.withType().defineEntity(l.mainEnv),headerLogoTagSlot:a.Slot.withType().defineEntity(l.mainEnv),applicationLogoService:a.Service.withType().defineEntity(l.mainEnv).allowRemoteAccess((0,a.declareComEmitter)("onApplicationLogoClick","offApplicationLogoClick")),dragManager:a.Service.withType().defineEntity(l.mainEnv),panelStore:a.Service.withType().defineEntity(l.mainEnv),router:a.Service.withType().defineEntity(l.mainEnv).allowRemoteAccess(),historyController:a.Service.withType().defineEntity(l.mainEnv).allowRemoteAccess(),draggingResource:(0,c.defineOneWayResource)().defineEntity(l.mainEnv)}})},23719:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;const r=t(5163);var o=t(13757);Object.defineProperty(n,"default",{enumerable:!0,get:function(){return r.__importDefault(o).default}}),r.__exportStar(t(13757),n)},93208:(e,n,t)=>{e.exports=t(23719)},71797:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;const r=t(5163);r.__exportStar(t(12803),n);var o=t(12803);Object.defineProperty(n,"default",{enumerable:!0,get:function(){return r.__importDefault(o).default}})},12803:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(93849),o=t(2206);n.default=new r.Feature({id:"jobManager",dependencies:[r.COM.asDependency],api:{jobRunnersSlot:r.Slot.withType().defineEntity(o.processingEnv),jobs:r.Service.withType().defineEntity(o.processingEnv).allowRemoteAccess()}})},27628:(e,n,t)=>{e.exports=t(71797)},24134:function(e,n,t){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;var o=t(88867);Object.defineProperty(n,"default",{enumerable:!0,get:function(){return r(o).default}})},88867:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163),o=t(93849),i=t(32510),s=t(5689),a=r.__importDefault(t(93208));n.default=new o.Feature({id:"notifications",dependencies:[a.default.asDependency],api:{toastBarStackResourceManager:(0,i.defineOneWayResource)().defineEntity(s.mainEnv),toastBarStackResource:o.Service.withType().defineEntity(s.mainEnv)}})},54690:(e,n,t)=>{e.exports=t(24134)},2618:function(e,n,t){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;var o=t(43345);Object.defineProperty(n,"default",{enumerable:!0,get:function(){return r(o).default}})},43345:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.defaultFileTreeConfig=void 0;const r=t(5163),o=t(93849),i=r.__importDefault(t(60456)),s=r.__importDefault(t(2206)),a=r.__importDefault(t(93208)),c=r.__importDefault(t(54690)),l=t(5689),d=r.__importDefault(t(83654)),u=r.__importDefault(t(1529));n.defaultFileTreeConfig={openedItems:[]},n.default=new o.Feature({id:"projectUI",dependencies:[s.default.asDependency,a.default.asDependency,d.default.asDependency,u.default.asDependency,i.default.asDependency,c.default.asDependency],api:{slotsProcessor:o.Service.withType().defineEntity(l.mainEnv),fileTreeStore:o.Service.withType().defineEntity(l.mainEnv),fileTreeConfig:new o.Config(n.defaultFileTreeConfig),openFilesService:o.Service.withType().defineEntity(l.mainEnv),openFilesConfig:new o.Config({targetAreaGroup:"content",openFiles:[]}),openFileSlot:o.MapSlot.withType().defineEntity(l.mainEnv),contextMenuSlot:o.Slot.withType().defineEntity(l.mainEnv),decorationIconsSlot:o.Slot.withType().defineEntity(l.mainEnv),copyPasteManager:o.Service.withType().defineEntity(l.mainEnv),fileStylingSlot:o.OrderedSlot.withType().defineEntity(l.mainEnv),fileStylingConfig:new o.Config([]),fileIconSlot:o.OrderedSlot.withType().defineEntity(l.mainEnv),fileIconService:o.Service.withType().defineEntity(l.mainEnv),renderFileIconConfig:new o.Config([["extension",["default"]]])}})},82026:(e,n,t)=>{e.exports=t(2618)},43934:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;const r=t(5163);r.__exportStar(t(31434),n);var o=t(31434);Object.defineProperty(n,"default",{enumerable:!0,get:function(){return r.__importDefault(o).default}})},31434:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.Context=n.DEFAULT_IGNORED_SUBPATHS=n.PROJECT_CONFIG_NAME=n.DIRECTORY_RESOURCE_PROVIDER_MARK=n.FILE_RESOURCE_PROVIDER_MARK=n.processingEnv=void 0;const r=t(5163),o=r.__importDefault(t(60456)),i=t(93849),s=r.__importStar(t(32510)),a=r.__importDefault(t(93208)),c=t(5689),l=t(78204),d=new i.Environment("worker","webworker","single"),u=new i.Environment("live-server","node","single");n.processingEnv=new i.SingleEndpointContextualEnvironment("processing",[d,u]);const p=(0,s.defineTwoWayResource)().defineEntity(n.processingEnv),h=(0,s.defineOneWayResource)().defineEntity(n.processingEnv),f=(0,s.defineOneWayResource)().defineEntity(n.processingEnv),m=(0,s.defineOneWayResource)().defineEntity(n.processingEnv),g=(0,s.defineTwoWayResource)().defineEntity(n.processingEnv);n.FILE_RESOURCE_PROVIDER_MARK="FILE_RESOURCE_PROVIDER_MARK",n.DIRECTORY_RESOURCE_PROVIDER_MARK="DIRECTORY_RESOURCE_PROVIDER_MARK",n.PROJECT_CONFIG_NAME="codux.config.json",n.DEFAULT_IGNORED_SUBPATHS=["**/node_modules/**","**/cjs/**","**/esm/**","**/dist/**",".git/**"];const y=(0,s.definePluggableComputedResource)().defineEntity(n.processingEnv);n.default=new i.Feature({id:"project",dependencies:[i.COM.asDependency,a.default.asDependency,s.default.asDependency,o.default.asDependency],api:{fsContents:i.Config.withType().defineEntity({},void 0,n.processingEnv),linkedPackages:i.Config.withType().defineEntity({},void 0,n.processingEnv),fs:i.Service.withType().defineEntity(n.processingEnv),fsResourcesSyncer:i.Service.withType().defineEntity(n.processingEnv).allowRemoteAccess((0,i.declareComEmitter)("subscribeToFs","unsubscribeFromFs")),virtualFs:i.Service.withType().defineEntity(n.processingEnv),projectService:i.Service.withType().defineEntity(n.processingEnv).allowRemoteAccess((0,i.declareComEmitter)("subscribe","unsubscribe")),watchablePathService:i.Service.withType().defineEntity(n.processingEnv).allowRemoteAccess(),fileManager:p,fileMetaManager:h,fileManagerMain:p.defineConsumer(c.mainEnv),directoryManager:f,directoryManagerMain:f.defineConsumer(c.mainEnv),fileListManager:m,fileListManagerMain:m.defineConsumer(c.mainEnv),pluggableProjectConfig:y,pluggableProjectConfigMain:y.defineConsumer(c.mainEnv),schemaCacheName:i.Config.withType().defineEntity({},void 0,n.processingEnv),ignoredSubPathsConfig:y.entry(n.DEFAULT_IGNORED_SUBPATHS,"ignoredSubPaths"),fileNamingConventionConfig:y.entry(void 0,"fileNamingConvention"),directoryEntitiesService:i.Service.withType().defineEntity(n.processingEnv),fsInitializerOptions:i.Config.withType().defineEntity({fsMode:"native"}),undoRedoService:i.Service.withType().defineEntity(n.processingEnv).allowRemoteAccess({subscribeToUndo:{listener:!0},unsubscribeToUndo:{removeListener:"subscribeToUndo"},subscribeToRedo:{listener:!0},unsubscribeToRedo:{removeListener:"subscribeToRedo"},...(0,i.declareComEmitter)("attachCustomHandler","detachCustomHandler")}),undoRedoStatusManager:g,undoRedoStatusManagerMain:g.defineConsumer(c.mainEnv),getRelativePathInProject:i.Service.withType().defineEntity(c.mainEnv),dualExtensions:i.Config.withType().defineEntity(l.DEFAULT_DUAL_EXTENSIONS),projectPath:i.Config.withType().defineEntity({},void 0,n.processingEnv),invalidateFileSystemCache:i.Service.withType().defineEntity(n.processingEnv),projectRenderReadySlot:i.Slot.withType().defineEntity(c.mainEnv),getProjectRenderingReady:i.Service.withType().defineEntity(c.mainEnv),packageJsonService:i.Service.withType().defineEntity(n.processingEnv).allowRemoteAccess()},context:{processingContext:n.processingEnv.withContext(),mainContext:c.mainEnv.withContext()}}),n.Context=n.processingEnv.useContext("worker")},78204:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.FILE_RESOURCE_DELETE_MESSAGE=n.DEFAULT_DUAL_EXTENSIONS=n.UNDO_REDO_INITIAL_STATUS=n.UNDO_REDO_STATUS_RESOURCE_ID=void 0,n.UNDO_REDO_STATUS_RESOURCE_ID="UNDO_REDO_STATUS",n.UNDO_REDO_INITIAL_STATUS={canUndo:!1,canRedo:!1},n.DEFAULT_DUAL_EXTENSIONS=[".sim.ts",".demo.tsx"],n.FILE_RESOURCE_DELETE_MESSAGE="Deleted"},98180:(e,n)=>{"use strict";var t;Object.defineProperty(n,"__esModule",{value:!0}),n.directoryManipulator=n.directoryReducer=n.DirectoryChangeKind=void 0,function(e){e.FULL="full",e.ADD="add",e.REMOVE="remove"}(t=n.DirectoryChangeKind||(n.DirectoryChangeKind={})),n.directoryReducer=(e,n)=>{switch(n.kind){case t.FULL:return{value:n.value,invertingChanges:[{kind:t.FULL,value:e}]};case t.ADD:return{value:[...e,n.node],invertingChanges:[{kind:t.FULL,value:e}]};case t.REMOVE:return{value:e.filter((e=>e.name!==n.name)),invertingChanges:[{kind:t.FULL,value:e}]};default:return{value:e,invertingChanges:[{kind:t.FULL,value:e}]}}},n.directoryManipulator={reducer:n.directoryReducer}},34232:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.defaultFileNamingConvention=void 0;const r=t(91570);n.defaultFileNamingConvention=r.NamingConvention.KebabCase},71299:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.FileResource=void 0;const r=t(60814),o=t(78204);class i extends r.Resource{delete(){this.invalidate(o.FILE_RESOURCE_DELETE_MESSAGE)}restoreDeleted(){this.setStatus({valid:!0})}isDeleted(){return!this.isValid()&&this.getInvalidationMessage()===o.FILE_RESOURCE_DELETE_MESSAGE}}n.FileResource=i},61276:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.FileScannerComputeHandler=n.getDirectoryEntities=n.traverseFs=void 0;const r=t(93849),o=t(98180);n.traverseFs=function e({directoryPath:n,fs:t,filterFile:o=r.returnsTrue,filterDirectory:i=r.returnsTrue,directories:s=[],files:a=[]}){const{readdirSync:c}=t;s.push({path:n,name:t.basename(n)});for(const r of c(n,{withFileTypes:!0})){const c=r.name,l=t.join(n,c);r.isDirectory()&&i(l,c)?e({directoryPath:l,fs:t,filterFile:o,filterDirectory:i,directories:s,files:a}):r.isFile()&&o(l,c)&&a.push({path:l,name:c})}return{directories:s,files:a}},n.getDirectoryEntities=function({directoryPath:e,fs:n}){const{readdirSync:t}=n,r={directories:[],files:[]};for(const o of t(e,{withFileTypes:!0})){const t=o.name,i=n.join(e,t);o.isDirectory()?r.directories.push({path:i,name:t}):o.isFile()&&r.files.push({path:i,name:t})}return r},n.FileScannerComputeHandler=class{constructor(e,n,t,r,o){this.controller=e,this.manipulator=n,this.fs=t,this.pathPredicate=r,this.directoryManager=o}compute(e){let n=this.controller.getEmptyValue();const{changes:t,dependencies:r}=this.addDirectory(e,n);for(const e of t)n=this.manipulator.reducer(n,e).value;return{value:n,dependencies:r,status:{valid:!0}}}recompute(e,n,t,r){const o=e.getLatest(),i=[];let s=new Set(r);for(const e of t){if(!e.isValid())continue;const t=e.getType(),{changes:r,dependencies:a}=this.getDirectoryRelatedUpdates(e,n.get(t).get(e.getSerializedId()),o,s);i.push(...r),s=a}const a=Array.from(r).filter((e=>!e.isValid()));return{dependencies:new Set([...s].filter((e=>!a.includes(e)))),changes:i,status:{valid:!0}}}addDirectory(e,n){const t=new Set,{files:r,directoryResources:o}=this.addDirRecurse(e),i=[],s=this.controller.onFilesAdded(n,r.map((({path:e})=>e)));return o.forEach((e=>t.add(e))),i.push(...s.changes),{changes:i,dependencies:t}}addDirRecurse(e,n=[],t=[],r=[]){const o=this.directoryManager.get(e);r.push(o);const i=o.getLatest();for(const o of i){const i={name:o.name,path:this.fs.join(e,o.name)};this.pathPredicate(i.path)&&(o.stats.isDirectory?(n.push(i),this.addDirRecurse(i.path,n,t,r)):o.stats.isFile&&this.controller.predicate(i.path)&&t.push(i))}return{files:t,directories:n,directoryResources:r}}getDirectoryRelatedUpdates(e,n,t,r){if(n.isDisposed())return{changes:[],dependencies:r};const i=[],s=new Set(r),a=e.getChangesFromVersion(n),c=e.getId();return a.forEach((e=>{if(e.kind===o.DirectoryChangeKind.ADD){const n=this.fs.join(c,e.node.name);if(e.node.stats.isDirectory){if(this.pathPredicate(n)){const{changes:e,dependencies:r}=this.addDirectory(n,t);for(const e of r)s.add(e);i.push(...e)}}else if(this.pathPredicate(n)&&this.controller.predicate(n)){const{changes:e}=this.controller.onFilesAdded(t,[n]);i.push(...e)}}else if(e.kind===o.DirectoryChangeKind.REMOVE){const n=this.fs.join(c,e.name);i.push(...this.controller.onRemoved(t,n))}})),{changes:i,dependencies:s}}}},33506:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.removePrefixPath=n.directoryDeepChildren=n.getPathsOfFilePath=n.getTreeNodePath=void 0;const r=t(73654),o=t(91570);function i(e,n){return e.split(n).filter((e=>!!e))}function s(){return!0}n.getTreeNodePath=i,n.getPathsOfFilePath=function(e,n){var t;const r=e?i(e,n):[],o=[];for(let e=0;e<r.length;e++)o.push((null!==(t=o[e-1])&&void 0!==t?t:"")+n+r[e]);return o},n.directoryDeepChildren=async function*e(n,t,r=s,o=t){for(const i of await n.promises.readdir(t,{withFileTypes:!0})){const s=i.name,a=n.join(t,s),c=n.relative(o,a);if(i.isFile()){const e={type:"file",path:a,name:s,relativePath:c};r(e)&&(yield e)}else if(i.isDirectory()){const t={type:"directory",path:a,name:s,relativePath:c};r(t)&&(yield t,yield*e(n,a,r,o))}}},n.removePrefixPath=(e,n)=>e?(0,o.replaceWinSlashes)(r.win32.relative(e,n)):(0,o.replaceWinSlashes)(n)},18012:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.FileResource=void 0;const r=t(5163);r.__exportStar(t(78204),n),r.__exportStar(t(98180),n),r.__exportStar(t(33506),n),r.__exportStar(t(98073),n),r.__exportStar(t(61276),n),r.__exportStar(t(34232),n);var o=t(71299);Object.defineProperty(n,"FileResource",{enumerable:!0,get:function(){return o.FileResource}})},98073:(e,n)=>{"use strict";var t,r;Object.defineProperty(n,"__esModule",{value:!0}),n.NodeType=n.FsEventType=void 0,(r=n.FsEventType||(n.FsEventType={}))[r.CREATE=0]="CREATE",r[r.LOAD=1]="LOAD",r[r.UPDATE=2]="UPDATE",r[r.DELETE=3]="DELETE",(t=n.NodeType||(n.NodeType={}))[t.directory=0]="directory",t[t.file=1]="file",t[t.virtual=2]="virtual",t[t.none=3]="none"},2206:(e,n,t)=>{e.exports=t(43934)},69144:(e,n,t)=>{e.exports=t(18012)},21086:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;const r=t(5163);r.__exportStar(t(35855),n);var o=t(35855);Object.defineProperty(n,"default",{enumerable:!0,get:function(){return r.__importDefault(o).default}})},35855:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.mainEnv=n.MainContext=void 0;const r=t(93849),o=t(67968),i=t(86420);Object.defineProperty(n,"mainEnv",{enumerable:!0,get:function(){return i.mainEnv}}),n.default=new r.Feature({id:"reactRenderer",api:{rendererService:r.Service.withType().defineEntity(i.mainEnv),reactMainContext:o.reactMainContext}}),n.MainContext=i.mainEnv.useContext("window")},65174:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.ContextEntryDefinition=n.ContextField=n.ContextSlot=n.defineReactContext=void 0;const r=t(93849);function o(){return function(e){const n=e instanceof c?e.providedFrom:e,t=new c(n,e instanceof c?e:void 0);return{use:()=>t.getReact().useContext(t.initAndGetContext())(),contextSlot:t}}}let i;n.defineReactContext=o;const s=(e,n,t)=>{const r=r=>{var o;const s=e.getReact();i=i||s.createContext(null);const c=e.initAndGetContext(),l=s.useContext((null===(o=e.parentSlot)||void 0===o?void 0:o.initAndGetContext())||i),{value:d,disposers:u}=s.useMemo((()=>{const e=l?l():n();return[...t].reduce(((n,t)=>{n.value[t.featureName]||(n.value[t.featureName]={});const{value:o,dispose:i}=t.provide(r.params,e);return n.value[t.featureName][t.entryName]=o,i&&n.disposers.add(i),n}),{value:a(e),disposers:new Set})}),[l,r.params]);s.useEffect((()=>()=>{for(const e of u)e()}),[u]);const p=s.useCallback((()=>d),[d]);return s.createElement(c.Provider,{value:p},r.children)};return r.displayName="ReactSlotProvider",r},a=e=>Object.entries(e).reduce(((e,[n,t])=>(e[n]=Object.entries(t).reduce(((e,[n,t])=>(e[n]=t,e)),{}),e)),{});class c extends r.FeatureInput{constructor(e,n){super(e,e),this.parentSlot=n,this.__thisOrParents={},this.defineChildContext=()=>o()(this)}init(e){this.React=e}defineContext(){return new d(this.providedFrom,this)}defineGuiSlot(){return{slot:r.Slot.withType().defineEntity(this.providedFrom),use:()=>this.getReact().useContext(this.initAndGetContext())()}}[r.CREATE_RUNTIME](e){const n=new r.Registry;return{registry:n,definitionSlot:this,Provider:s(this,(()=>{const n={};for(const[t,r]of e.features)n[t.id]=r.api;return n}),n)}}[r.REGISTER_VALUE](e,n,t,o,i){if(!this.parentSlot&&!this.React){const{communication:n}=e.get(r.COM).api;if(n.getEnvironmentName()==this.providedFrom.env)throw new Error("React not inited for "+o+" "+i)}return t}getReact(){var e;return this.React||(null===(e=this.parentSlot)||void 0===e?void 0:e.getReact())}initAndGetContext(){return this.context=this.context||this.getReact().createContext((()=>({}))),this.context}}n.ContextSlot=c;class l{constructor(e,n){this.featureName=e,this.entryName=n}init(e){this.provider={provide:e,entryName:this.entryName,featureName:this.featureName}}}n.ContextField=l;class d extends r.FeatureInput{constructor(e,n){super(e,e),this.slot=n}[r.CREATE_RUNTIME](e,n,t){return new l(n,t)}[r.REGISTER_VALUE](e,n,t){if(!t.provider){const{api:{communication:n}}=e.get(r.COM);if(n.getEnvironmentName()==this.providedFrom.env)throw new Error("context field not inited "+t.featureName+" : "+t.entryName)}let o=!1;for(const[n,r]of e.features.entries()){for(const[e,i]of Object.entries(n.api))if(i===this.slot&&(o=!0,r.api[e].registry.register(t.provider)),o)break;if(o)break}if(!o)throw new Error("target slot not found");return t}}n.ContextEntryDefinition=d},86420:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.mainEnv=void 0;const r=t(93849);n.mainEnv=new r.SingleEndpointContextualEnvironment("main",[new r.Environment("window","window","single"),new r.Environment("electron-renderer","electron-renderer","single")])},67968:(e,n,t)=>{"use strict";var r;Object.defineProperty(n,"__esModule",{value:!0}),n.useMainContext=n.reactMainContext=void 0;const o=t(86420);r=(0,t(65174).defineReactContext)()(o.mainEnv),n.reactMainContext=r.contextSlot,n.useMainContext=r.use},5689:(e,n,t)=>{e.exports=t(21086)},31197:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;const r=t(5163);r.__exportStar(t(36041),n);var o=t(36041);Object.defineProperty(n,"default",{enumerable:!0,get:function(){return r.__importDefault(o).default}})},36041:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.defineGlobalStateResource=void 0;const r=t(93849),o=t(5689);n.defineGlobalStateResource=()=>r.Service.withType().defineEntity(o.mainEnv);const i=new r.Feature({id:"reactResources",api:{createStateResource:r.Service.withType().defineEntity(o.mainEnv)},dependencies:[]});n.default=i},59995:(e,n,t)=>{e.exports=t(31197)},40934:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;const r=t(5163);var o=t(15863);Object.defineProperty(n,"default",{enumerable:!0,get:function(){return r.__importDefault(o).default}}),r.__exportStar(t(15863),n)},15863:(e,n,t)=>{"use strict";var r;Object.defineProperty(n,"__esModule",{value:!0}),n.defineIncrementalComputedResource=n.defineTwoWayResource=n.defineTwoWayComputedResource=n.defineQueryResource=n.definePluggableTwoWayComputedResource=n.definePluggableResource=n.definePluggableComputedResource=n.defineOneWayResource=n.defineComputedResource=void 0;const o=t(93849),i=t(68537),s=t(89877),a=t(34270),c=o.Service.withType().defineEntity(o.Universal),l=o.Service.withType().defineEntity(o.Universal);class d{constructor(e,n){this.remoteSyncer=e,this.envSyncer=n,this[r]={connect:(0,o.multiTenantMethod)(this.connect)}}connect(e){const n=this.remoteSyncer.get({id:e});this.envSyncer.connectSyncer(e,n)}}r=o.SERVICE_CONFIG;const u=o.Service.withType().defineEntity(o.Universal).allowRemoteAccess(),p=new o.Feature({id:"Resources",dependencies:[o.COM.asDependency],api:{batcher:c,syncer:l,remoteSyncer:l.allowRemoteAccess({messageFromRemote:{emitOnly:!0}}),syncerConnector:u}}).setup(o.Universal,(({remoteSyncer:e},{COM:{communication:n,loggerService:t}})=>{const r=new s.Batcher,o=new i.ResourceSyncer(n.getEnvironmentId(),r,{},t);return n.subscribeToEnvironmentDispose((e=>{o.disconnectSyncer(e)})),{batcher:r,syncer:o,remoteSyncer:o,syncerConnector:new d(e,o)}}));n.default=p,n.defineComputedResource=(0,a.defineComputedResource)(p),n.defineOneWayResource=(0,a.defineOneWayResource)(p),n.definePluggableComputedResource=(0,a.definePluggableComputedResource)(p),n.definePluggableResource=(0,a.definePluggableResource)(p),n.definePluggableTwoWayComputedResource=(0,a.definePluggableTwoWayComputedResource)(p),n.defineQueryResource=(0,a.defineQueryResource)(p),n.defineTwoWayComputedResource=(0,a.defineTwoWayComputedResource)(p),n.defineTwoWayResource=(0,a.defineTwoWayResource)(p),n.defineIncrementalComputedResource=(0,a.defineIncrementalComputedResource)(p)},89877:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.Batcher=void 0;const r=t(98522),o=(e,n,t)=>{e.has(n)||e.set(n,new Map);const r=e.get(n);r.has(t)||r.set(t,new Set)};n.Batcher=class{constructor(){this.registered=new Map,this.registeredAtomic=new Map,this.inAtomic=!1,this.atomicSnapshots=new Map,this.batching=!1,this.subscribers=new Set,this.changed=new Map,this.changedStatus=new Map}subscribe(e){this.subscribers.add(e)}unsubscribe(e){this.subscribers.delete(e)}isBatching(){return this.batching}getRunningBatchId(){return this.runningBatchId}batchAll(e,n){if(this.runningBatchId=void 0===n?Math.random():n,this.batching)throw new Error("already batching");this.batching=!0;try{e(),this.batching=!1;const n=this.runningBatchId,t=this.commit(this.runningBatchId);return this.runningBatchId===n&&(this.runningBatchId=void 0),t}catch(e){return this.batching=!1,console.error(e),this.runningBatchId?this.revert(e,this.runningBatchId):this.createFailureEvent(e,n)}}batchIfNeeded(e){this.batching?e():this.batchAll(e)}runAtomic(e,n=Math.random()){if(this.inAtomic){const t=this.batchAll(e,n);return this.inAtomic=!1,t}this.inAtomic=!0;try{const t=this.batchAll(e,n);if("failure"===t.status)throw t.error;return this.inAtomic=!1,this.disposeAtomicSnapshots(n),this.atomicSnapshots=new Map,t}catch(e){return console.error(e),this.atomicSnapshots.has(n)&&this.batchAll((()=>{for(const[e,t]of this.atomicSnapshots.get(n).entries())for(const o of this.registeredAtomic.get(n).get(e)){const e=t.get(o.getSerializedId());e&&o.applyChange((0,r.fullChange)(o.getProjection(e)))}})),this.inAtomic=!1,this.disposeAtomicSnapshots(n),this.atomicSnapshots=new Map,this.createFailureEvent(e,n||-1)}}getAtomicSnapshot(e,n){var t;if(this.runningBatchId&&this.atomicSnapshots.has(this.runningBatchId))return null===(t=this.atomicSnapshots.get(this.runningBatchId).get(e))||void 0===t?void 0:t.get(n)}setAtomicSnapshot(e,n,t){if(!this.runningBatchId)throw new Error("trying to set snap in unknown batch");this.atomicSnapshots.has(this.runningBatchId)||this.atomicSnapshots.set(this.runningBatchId,new Map);const r=this.atomicSnapshots.get(this.runningBatchId);r.has(e)||r.set(e,new Map);const o=r.get(e);o.has(n)||o.set(n,t)}registerForBatch(e,n,t,r){if(!this.runningBatchId)throw new Error("registering to non existant batch");o(this.registered,this.runningBatchId,t),this.registered.get(this.runningBatchId).get(t).add(e),this.inAtomic&&(o(this.registeredAtomic,this.runningBatchId,t),this.registeredAtomic.get(this.runningBatchId).get(t).add(e)),r?(o(this.changedStatus,this.runningBatchId,t),this.changedStatus.get(this.runningBatchId).get(t).add(n)):(o(this.changed,this.runningBatchId,t),this.changed.get(this.runningBatchId).get(t).add(n))}unregisterFromBatch(e,n,t){var r,o,i,s,a,c,l,d;this.runningBatchId&&(null===(o=null===(r=this.registered.get(this.runningBatchId))||void 0===r?void 0:r.get(t))||void 0===o||o.delete(e),null===(s=null===(i=this.registeredAtomic.get(this.runningBatchId))||void 0===i?void 0:i.get(t))||void 0===s||s.delete(e),null===(c=null===(a=this.changed.get(this.runningBatchId))||void 0===a?void 0:a.get(t))||void 0===c||c.delete(n),null===(d=null===(l=this.changedStatus.get(this.runningBatchId))||void 0===l?void 0:l.get(t))||void 0===d||d.delete(n))}disposeAtomicSnapshots(e){if(!this.atomicSnapshots.has(e))return;const n=this.atomicSnapshots.get(e);for(const e of n.values())for(const n of e.values())n.dispose()}commit(e){let n=!1;if(this.registered.has(e))for(const t of this.registered.get(e).values())for(const r of t)r.commit(e),n=!0;const t=this.createSuccessEvent(e);return n&&this.dispatch(t),t}revert(e,n){if(this.registered.has(n)){for(const e of this.registered.get(n).values())for(const n of e)n.revert();this.registered.delete(n)}return this.createFailureEvent(e,n)}dispatch(e){for(const n of this.subscribers)n(e)}createFailureEvent(e,n){return{status:"failure",error:e,batchId:n}}createSuccessEvent(e){var n,t;const r={status:"success",changed:{},changedStatus:{},batchId:e};if(this.registered.has(e))for(const o of this.registered.get(e).keys()){const i=null===(n=this.changed.get(e))||void 0===n?void 0:n.get(o);(null==i?void 0:i.size)&&(r.changed[o]=[...i]);const s=null===(t=this.changedStatus.get(e))||void 0===t?void 0:t.get(o);(null==s?void 0:s.size)&&(r.changedStatus[o]=[...s])}return this.registered.delete(e),this.changed.delete(e),this.changedStatus.delete(e),r}}},65089:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.definePluggableComputedResource=n.PluggableComputedResourceDefinition=n.PluggableComputedResourceCreator=void 0;const r=t(93849),o=t(25076),i=t(13980),s=t(77952);class a extends i.ComputedResourceCreator{constructor(e,n,t,r){super(e,n,t,r)}consume(e,n){const{managerConstructor:t,resourceConstructor:r}=e;return super.consume({managerConstructor:t,resourceConstructor:r||o.PluggableResource},n)}provide(e){const{resourceConstructor:n,managerConstructor:t,handler:r,dispose:i,dependencies:s}=e;return super.provide({handler:r,dispose:i,managerConstructor:t,resourceConstructor:n||o.PluggableResource,dependencies:s})}}n.PluggableComputedResourceCreator=a;class c extends s.BasePluggableResourceDefinition{constructor(e,n){super(n),this.resourceFeature=e}[r.CREATE_RUNTIME](e,n,t){const r=e.entityID(n,t);return new a(this.env,r,e,this.resourceFeature)}}n.PluggableComputedResourceDefinition=c,n.definePluggableComputedResource=function(e){return()=>({defineEntity:n=>new c(e,n)})}},13980:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.defineComputedResource=n.ComputedResourceDefinition=n.ComputedResourceCreator=void 0;const r=t(93849),o=t(14572),i=t(98593),s=t(73836),a=t(91792),c=t(77952);class l extends c.BaseResourceCreator{constructor(e,n,t,r){super(e,n,t,r)}consume(e,n){const{managerConstructor:t,resourceConstructor:r,manipulator:i}=e,c=(null==n?void 0:n.id)||this.definitionENV.env;return this.getConsumer(new a.OneWayStrategySlave(r||o.Resource,c,this.getConsumerTypeName(n),this.batcher,i||new s.JsonManipulator,this.syncer.subscribeToRemote),t,n)}provide(e){const{resourceConstructor:n,managerConstructor:t,manipulator:r,handler:a,dependencies:c}=e;return this.getProvider({strategy:new i.OneWayComputedStrategyMaster(n||o.Resource,this.definitionENV.env,this.getProviderTypeName(),this.batcher,r||new s.JsonManipulator,a),dependenciesBaseTypeNames:c.map((e=>e.baseTypeName)),managerConstructor:t})}}n.ComputedResourceCreator=l;class d extends c.BaseResourceDefinition{constructor(e,n){super(n),this.resourceFeature=e}[r.CREATE_RUNTIME](e,n,t){const r=e.entityID(n,t);return new l(this.env,r,e,this.resourceFeature)}}n.ComputedResourceDefinition=d,n.defineComputedResource=function(e){return()=>({defineEntity:n=>new d(e,n)})}},16670:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.defineIncrementalComputedResource=n.IncrementalComputedResourceDefinition=n.IncrementalComputedResourceCreator=void 0;const r=t(93849),o=t(14572),i=t(73836),s=t(91792),a=t(77952),c=t(99540);class l extends a.BaseResourceCreator{constructor(e,n,t,r){super(e,n,t,r)}consume(e,n){const{managerConstructor:t,resourceConstructor:r,manipulator:a}=e,c=(null==n?void 0:n.id)||this.definitionENV.env;return this.getConsumer(new s.OneWayStrategySlave(r||o.Resource,c,this.getConsumerTypeName(n),this.batcher,a||new i.JsonManipulator,this.syncer.subscribeToRemote),t,n)}provide(e){var n;const{resourceConstructor:t,managerConstructor:r,manipulator:s,handler:a,dependencies:l}=e;return this.getProvider({strategy:new c.OneWayIncrementalComputedStrategyMaster(t||o.Resource,this.definitionENV.env,this.getProviderTypeName(),this.batcher,s||new i.JsonManipulator,a,{maxWorkTime:e.maxWorkTime,minSleepTime:e.minSleepTime,startValue:e.startValue,emptyValue:null!==(n=e.emptyValue)&&void 0!==n?n:{...e.startValue,progress:1},changeBufferTime:e.changeBufferTime}),dependenciesBaseTypeNames:l.map((e=>e.baseTypeName)),managerConstructor:r})}}n.IncrementalComputedResourceCreator=l;class d extends a.BaseResourceDefinition{constructor(e,n){super(n),this.resourceFeature=e}[r.CREATE_RUNTIME](e,n,t){const r=e.entityID(n,t);return new l(this.env,r,e,this.resourceFeature)}}n.IncrementalComputedResourceDefinition=d,n.defineIncrementalComputedResource=function(e){return()=>({defineEntity:n=>new d(e,n)})}},61928:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.defineOneWayResource=n.OneWayResourceDefinition=n.OneWayResourceCreator=void 0;const r=t(93849),o=t(14572),i=t(91792),s=t(73836),a=t(77952);class c extends a.BaseResourceCreator{constructor(e,n,t,r){super(e,n,t,r)}consume(e,n){const{managerConstructor:t,resourceConstructor:r,manipulator:a}=e,c=(null==n?void 0:n.id)||this.definitionENV.env;return this.getConsumer(new i.OneWayStrategySlave(r||o.Resource,c,this.getConsumerTypeName(n),this.batcher,a||new s.JsonManipulator,this.syncer.subscribeToRemote),t,n)}provide(e){const{resourceConstructor:n,managerConstructor:t,manipulator:r,handler:a}=e;return this.getProvider({managerConstructor:t,strategy:new i.OneWayStrategyMaster(n||o.Resource,this.definitionENV.env,this.getProviderTypeName(),this.batcher,r||new s.JsonManipulator,a)})}}n.OneWayResourceCreator=c;class l extends a.BaseResourceDefinition{constructor(e,n){super(n),this.resourceFeature=e}[r.CREATE_RUNTIME](e,n,t){const r=e.entityID(n,t);return new c(this.env,r,e,this.resourceFeature)}}n.OneWayResourceDefinition=l,n.defineOneWayResource=function(e){return()=>({defineEntity:n=>new l(e,n)})}},85494:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.definePluggableResource=n.PluggableResourceDefinition=n.PluggableResourceCreator=void 0;const r=t(93849),o=t(25076),i=t(61928),s=t(77952);class a extends i.OneWayResourceCreator{constructor(e,n,t,r){super(e,n,t,r)}consume(e,n){const{managerConstructor:t,resourceConstructor:r}=e;return super.consume({managerConstructor:t,resourceConstructor:r||o.PluggableResource},n)}provide(e){const{resourceConstructor:n,managerConstructor:t,handler:r,dispose:i}=e;return super.provide({handler:r,dispose:i,managerConstructor:t,resourceConstructor:n||o.PluggableResource})}}n.PluggableResourceCreator=a;class c extends s.BasePluggableResourceDefinition{constructor(e,n){super(n),this.resourceFeature=e}[r.CREATE_RUNTIME](e,n,t){const r=e.entityID(n,t);return new a(this.env,r,e,this.resourceFeature)}}n.PluggableResourceDefinition=c,n.definePluggableResource=function(e){return()=>({defineEntity:n=>new c(e,n)})}},64620:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.defineQueryResource=n.QueryResourceDefinition=n.QueryResourceCreator=void 0;const r=t(93849),o=t(77163),i=t(90294),s=t(77952);class a extends s.BaseResourceCreator{constructor(e,n,t,r){super(e,n,t,r)}consume(e,n){const{managerConstructor:t,resourceConstructor:r,results:s}=e,a=(null==n?void 0:n.id)||this.definitionENV.env;return this.getConsumer(new o.QueryStrategySlave(r||i.QueryResource,a,this.getConsumerTypeName(n),this.batcher,this.syncer.subscribeToRemote,s.map((e=>e.getTypeName())),this.syncer.get.bind(this.syncer)),t,n)}provide(e){const{resourceConstructor:n,managerConstructor:t,handler:r,dependencies:s,results:a}=e;return this.getProvider({managerConstructor:t,strategy:new o.QueryStrategyMaster(n||i.QueryResource,this.definitionENV.env,this.getProviderTypeName(),this.batcher,a.map((e=>e.getTypeName())),s.map((e=>e.getTypeName())),r)})}}n.QueryResourceCreator=a;class c extends s.BaseResourceDefinition{constructor(e,n){super(n),this.resourceFeature=e}[r.CREATE_RUNTIME](e,n,t){const r=e.entityID(n,t);return new a(this.env,r,e,this.resourceFeature)}}n.QueryResourceDefinition=c,n.defineQueryResource=function(e){return()=>({defineEntity:n=>new c(e,n)})}},77952:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.BasePluggableResourceDefinition=n.BaseResourceDefinition=n.BaseResourceCreator=void 0;const r=t(93849),o=t(91570),i=t(86307),s=t(25076);n.BaseResourceCreator=class{constructor(e,n,t,o){this.definitionENV=e,this.baseTypeName=n,this.context=t,this.managers={};const i=t.get(o).api,s=t.get(r.COM).api;this.comunication=s.communication,this.syncer=i.syncer,this.batcher=i.batcher,this.logger=s.loggerService,this.connectorId=t.entityID(o.id,"syncerConnector"),this.rApiID=t.entityID(o.id,"remoteSyncer")}getConsumerTypeName(e){return e?e.id+"#"+this.baseTypeName:this.baseTypeName}getProviderTypeName(){return"single"===this.definitionENV.endpointType?this.baseTypeName:this.comunication.getEnvironmentId()+"#"+this.baseTypeName}getConsumer(e,n,t){const r=this.getConsumerTypeName(t),s=n||i.ResourceManager,a=t||{id:this.definitionENV.env};if(this.managers[a.id])return this.managers[a.id];const c=new s(e,r,this.syncer,this.batcher,this.logger,this.baseTypeName,[]);if(!this.comunication.isServer){const e=this.comunication.apiProxy(a,{id:this.connectorId}),n=this.comunication.apiProxy(a,{id:this.rApiID});this.syncer.hasSyncer(a.id)||(e.connect(this.syncer.id).catch(o.reportError),this.syncer.connectSyncer(a.id,n))}return this.managers[a.id]=c,c}getProvider({strategy:e,managerConstructor:n,dependenciesBaseTypeNames:t}){const r=this.getProviderTypeName();return new(n||i.ResourceManager)(e,r,this.syncer,this.batcher,this.logger,this.baseTypeName,t||[])}};class a extends r.FeatureOutput{constructor(e){super(e,r.Universal,!0),this.env=e}defineConsumer(e){return r.Service.withType().defineEntity(e)}[r.CREATE_RUNTIME](e,n,t){return null}[r.REGISTER_VALUE](e,n,t,r,o){return n||t}}n.BaseResourceDefinition=a,n.BasePluggableResourceDefinition=class extends a{entry(e,n,t=s.defaultMergeConfig){return new s.PluggableResourceEntryDefinition(n,e,t)}}},73175:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.definePluggableTwoWayComputedResource=n.PluggableTwoWayComputedResourceDefinition=n.PluggableTwoWayComputedResourceCreator=void 0;const r=t(93849),o=t(25076),i=t(87588),s=t(77952);class a extends i.TwoWayComputedResourceCreator{constructor(e,n,t,r){super(e,n,t,r)}consume(e,n){const{managerConstructor:t,resourceConstructor:r}=e;return super.consume({managerConstructor:t,resourceConstructor:r||o.PluggableResource},n)}provide(e){const{resourceConstructor:n,managerConstructor:t,handler:r,dispose:i,dependencies:s}=e;return super.provide({handler:r,dispose:i,managerConstructor:t,resourceConstructor:n||o.PluggableResource,dependencies:s})}}n.PluggableTwoWayComputedResourceCreator=a;class c extends s.BasePluggableResourceDefinition{constructor(e,n){super(n),this.resourceFeature=e}[r.CREATE_RUNTIME](e,n,t){const r=e.entityID(n,t);return new a(this.env,r,e,this.resourceFeature)}}n.PluggableTwoWayComputedResourceDefinition=c,n.definePluggableTwoWayComputedResource=function(e){return()=>({defineEntity:n=>new c(e,n)})}},87588:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.defineTwoWayComputedResource=n.TwoWayComputedResourceDefinition=n.TwoWayComputedResourceCreator=void 0;const r=t(93849),o=t(14572),i=t(73836),s=t(80375),a=t(77952);class c extends a.BaseResourceCreator{constructor(e,n,t,r){super(e,n,t,r)}consume(e,n){const{managerConstructor:t,resourceConstructor:r,manipulator:a}=e,c=(null==n?void 0:n.id)||this.definitionENV.env;return this.getConsumer(new s.TwoWayComputedStrategySlave(r||o.Resource,c,this.getConsumerTypeName(n),this.batcher,a||new i.JsonManipulator,this.syncer.subscribeToRemote,this.logger),t,n)}provide(e){const{resourceConstructor:n,managerConstructor:t,manipulator:r,handler:a,dependencies:c}=e;return this.getProvider({managerConstructor:t,strategy:new s.TwoWayComputedStrategyMaster(n||o.Resource,this.definitionENV.env,this.getProviderTypeName(),this.batcher,this.syncer,r||new i.JsonManipulator,c.map((e=>e.getTypeName())),a)})}}n.TwoWayComputedResourceCreator=c;class l extends a.BaseResourceDefinition{constructor(e,n){super(n),this.resourceFeature=e}[r.CREATE_RUNTIME](e,n,t){const r=e.entityID(n,t);return new c(this.env,r,e,this.resourceFeature)}}n.TwoWayComputedResourceDefinition=l,n.defineTwoWayComputedResource=function(e){return()=>({defineEntity:n=>new l(e,n)})}},95561:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.defineTwoWayResource=n.TwoWayResourceDefinition=n.TwoWayResourceCreator=void 0;const r=t(93849),o=t(14572),i=t(72288),s=t(73836),a=t(77952);class c extends a.BaseResourceCreator{constructor(e,n,t,r){super(e,n,t,r)}consume(e,n){const{managerConstructor:t,resourceConstructor:r,manipulator:a}=e,c=(null==n?void 0:n.id)||this.definitionENV.env;return this.getConsumer(new i.TwoWayStrategySlave(r||o.Resource,c,this.getConsumerTypeName(n),this.batcher,a||new s.JsonManipulator,this.syncer.subscribeToRemote,this.logger),t,n)}provide(e){const{resourceConstructor:n,managerConstructor:t,manipulator:r,handler:a}=e;return this.getProvider({managerConstructor:t,strategy:new i.TwoWayStrategyMaster(n||o.Resource,this.definitionENV.env,this.getProviderTypeName(),this.batcher,r||new s.JsonManipulator,a)})}}n.TwoWayResourceCreator=c;class l extends a.BaseResourceDefinition{constructor(e,n){super(n),this.resourceFeature=e}[r.CREATE_RUNTIME](e,n,t){const r=e.entityID(n,t);return new c(this.env,r,e,this.resourceFeature)}}n.TwoWayResourceDefinition=l,n.defineTwoWayResource=function(e){return()=>({defineEntity:n=>new l(e,n)})}},34270:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163);r.__exportStar(t(65089),n),r.__exportStar(t(13980),n),r.__exportStar(t(16670),n),r.__exportStar(t(61928),n),r.__exportStar(t(85494),n),r.__exportStar(t(64620),n),r.__exportStar(t(77952),n),r.__exportStar(t(73175),n),r.__exportStar(t(87588),n),r.__exportStar(t(95561),n)},4238:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0})},73858:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163);r.__exportStar(t(89877),n),r.__exportStar(t(34270),n),r.__exportStar(t(4238),n),r.__exportStar(t(27868),n),r.__exportStar(t(31796),n),r.__exportStar(t(73836),n),r.__exportStar(t(75884),n),r.__exportStar(t(25076),n),r.__exportStar(t(90294),n),r.__exportStar(t(14572),n),r.__exportStar(t(86307),n),r.__exportStar(t(98593),n),r.__exportStar(t(99540),n),r.__exportStar(t(91792),n),r.__exportStar(t(77163),n),r.__exportStar(t(80375),n),r.__exportStar(t(72288),n),r.__exportStar(t(68537),n),r.__exportStar(t(42580),n),r.__exportStar(t(98522),n),r.__exportStar(t(76893),n)},27868:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.jsonEquals=void 0;const{hasOwnProperty:t}=Object.prototype;n.jsonEquals=function e(n,r){if(n===r)return!0;if(n&&r&&"object"==typeof n&&"object"==typeof r){if(Array.isArray(n)){if(Array.isArray(r)&&n.length===r.length){for(let t=0;t<n.length;t++)if(!e(n[t],r[t]))return!1;return!0}return!1}if(!Array.isArray(r)){const o=Object.keys(n);if(o.length!==Object.keys(r).length)return!1;for(let i=0;i<o.length;i++){const s=o[i];if(!t.call(r,s))return!1;if(!e(n[s],r[s]))return!1}return!0}}return!1}},31796:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.JSONResource=void 0;const r=t(30412),o=t(14572);(0,r.enablePatches)();const i=e=>{switch(e.op){case"add":return{kind:"add",path:e.path,value:e.value};case"remove":return{kind:"remove",path:e.path};case"replace":return{kind:"replace",path:e.path,value:e.value}}};class s extends o.Resource{applyPatch(e){const n=[];if((0,r.produce)(this.getLatest(),e,(e=>{n.push(...e)})),n.length){const e=()=>{for(const e of n)this.applyChange(i(e))};this.batcher.isBatching()?e():this.batcher.batchAll(e)}}}n.JSONResource=s},73836:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.JsonManipulator=n.jsonWalk=void 0;const r=t(91570),o=t(75884);n.jsonWalk=(e,n)=>{const{kind:t,path:r}=n,i=[];if(0===r.length){if("remove"===t)throw new Error("Cannot remove from empty path");if("add"===t)throw new Error("Cannot add to empty path");if("fetch"===t)return{json:e,inverting:i};if("replace"===n.kind)return i.push({kind:"replace",path:r,value:e}),{json:n.value,inverting:i};if("partial-string-replace"===n.kind)throw new Error("Cannot apply partial string replace to empty path");throw new Error("Not yet supported")}const s=(e,n,t)=>{if(1===n.length){const s=n[0];if("add"===t.kind){if(i.push({kind:"remove",path:r}),Array.isArray(e)&&"number"==typeof s)return[...e.slice(0,s),t.value,...e.slice(s)];{const n=e[s];return Array.isArray(n)?{...e,[s]:[...n,t.value]}:{...e,[s]:t.value}}}if("remove"===t.kind){if(Array.isArray(e)&&"number"==typeof s){if(s<0||s>e.length)throw new Error("Cannot remove : non existing path");return i.push({kind:"add",value:e[s],path:r}),[...e.slice(0,s),...e.slice(s+1)]}{if(!(s in e))throw new Error("Cannot remove : non existing path");i.push({kind:"add",value:e[s],path:r});const n=String(s),t={};for(const r of Object.keys(e))r!==n&&(t[r]=e[r]);return t}}if("fetch"===t.kind)return e[s];if("replace"===t.kind){const o=n[0];return Array.isArray(e)&&"number"==typeof o?(i.push({kind:"replace",value:e[o],path:r}),[...e.slice(0,o),t.value,...e.slice(o+1)]):(i.push({kind:"replace",value:e[o],path:r}),{...e,[o]:t.value})}if("partial-string-replace"===t.kind){const n=e[s];if("string"!=typeof n)throw new Error("Cannot apply partial string replace on non-string");const{value:a,invertingChanges:c}=o.stringManipulator.reducer(n,t.partialChange);return i.push(...c.map((e=>({kind:"partial-string-replace",partialChange:e,path:r})))),Array.isArray(e)&&"number"==typeof s?[...e.slice(0,s),a,...e.slice(s+1)]:{...e,[s]:a}}return e}{const r=e[n[0]];if(!r)throw new Error(`Cannot ${t.kind} : non existing path`);if("object"!=typeof r)throw new Error(`Cannot ${t.kind} : cannot change in non empty path of non object/array`);const o=n[0];if("fetch"===t.kind)return s(r,n.slice(1),t);if(Array.isArray(e)){if("number"!=typeof o)throw new Error(`Cannot ${t.kind} : cannot access array with non number index`);const a=s(r,n.slice(1),t);return i.length?[...e.slice(0,o),a,...e.slice(o+1)]:e}{const o=s(r,n.slice(1),t);return i.length?{...e,[n[0]]:o}:e}}};if("object"!=typeof e||null===e)throw new Error("Cannot apply change to undefined value");return{json:s(e,r,n),inverting:i}},n.JsonManipulator=class{constructor(){this.merger=(e,t,r)=>{const o=(e,t)=>{const r=[t.path||t.fromPath,t.toPath];if(void 0===r[0])return!0;try{for(const t of r)t&&(0,n.jsonWalk)(e,{path:t,kind:"fetch"});this.reducer(e,t)}catch(e){return!1}return!0},i=(e,t,r)=>{if(["add","move","copy"].includes(r.kind)){const o=r.path||r.toPath;if(o.length>0){const r=o[o.length-1],{json:i}=(0,n.jsonWalk)(e,{kind:"fetch",path:o.slice(0,-1)});if("number"==typeof r&&Array.isArray(i)){const e=[t.path||t.fromPath,t.toPath];for(const n of e)if(n){const e=n[n.length-1];"number"==typeof e&&Array.isArray(i)&&r<=e&&(n[n.length-1]+=1)}}}}if(["remove","move"].includes(r.kind)){const o=r.path||r.fromPath;if(o.length>0){const r=o[o.length-1],{json:i}=(0,n.jsonWalk)(e,{kind:"fetch",path:o.slice(0,-1)});if("number"==typeof r&&Array.isArray(i)){const e=[t.path||t.fromPath,t.toPath];for(const n of e)if(n){const e=n[n.length-1];"number"==typeof e&&Array.isArray(i)&&r<=e&&(n[n.length-1]-=1)}}}}return t},s=[],a=[];for(const n of t){let t=n;for(const o of[...r,...s])t=i(e,n,o);o(e,t)?(s.push(t),e=this.reducer(e,t).value):a.push(n)}return{changesToApply:s,changesRevoked:a}}}reducer(e,t){switch(t.kind){case"add":{const{json:r,inverting:o}=(0,n.jsonWalk)(e,t);return{value:r,invertingChanges:o}}case"remove":{const{json:r,inverting:o}=(0,n.jsonWalk)(e,t);return{value:r,invertingChanges:o}}case"move":{const{json:o,inverting:[i]}=(0,n.jsonWalk)(e,{kind:"remove",path:t.fromPath}),{json:s}=(0,n.jsonWalk)(o,{kind:"fetch",path:t.toPath.slice(0,t.toPath.length-1)}),{json:a,inverting:c}=(0,n.jsonWalk)(o,{...i,path:t.toPath,kind:(0,r.last)(t.toPath)in s?"replace":"add"});return{value:a,invertingChanges:[i,...c]}}case"copy":{const{json:r}=(0,n.jsonWalk)(e,{kind:"fetch",path:t.fromPath});if(void 0===r)throw new Error("Cannot copy : non existing path");const o={kind:"add",path:t.toPath,value:r},{json:i,inverting:s}=(0,n.jsonWalk)(e,o);return{value:i,invertingChanges:s}}case"replace":{const{json:r,inverting:o}=(0,n.jsonWalk)(e,t);return{value:r,invertingChanges:o}}case"partial-string-replace":{const{json:r,inverting:o}=(0,n.jsonWalk)(e,t);return{value:r,invertingChanges:o}}default:throw new Error(`Unsupported change kind ${t.kind} for json manipulator`)}}squasher(e){return e.reduce(((e,n)=>{if(0!==e.length){const t=e[e.length-1];"replace"===n.kind&&"replace"===t.kind?JSON.stringify(n.path)===JSON.stringify(t.path)?t.value=n.value:e.push(n):"partial-string-replace"===n.kind&&"partial-string-replace"===t.kind&&JSON.stringify(n.path)===JSON.stringify(t.path)?t.partialChange=o.stringManipulator.squasher([t.partialChange,n.partialChange])[0]:e.push(n)}else e.push(n);return e}),[])}}},91439:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.isSameResource=n.queryManipulator=n.querySquasher=n.findPrevChange=n.squashJsonAndFull=n.queryReducer=n.isSameIdentifier=void 0;const r=t(73836);function o(e,n){return e.type===n.type&&e.serializedId===n.serializedId}n.isSameIdentifier=o;const i=new r.JsonManipulator;n.queryReducer=(e,n)=>{switch(n.kind){case"full":return{value:n.value,invertingChanges:[{kind:"full",value:e}]};case"partial":{const t=e.resources.filter((e=>!n.removed.find((n=>o(n,e)))));for(const e of n.added)t.push(e);return{value:{resources:t,metaData:e.metaData},invertingChanges:[{kind:"full",value:e}]}}case"meta":{const t={kind:"meta",changes:[]};let r=e.metaData;for(const o of n.changes)if("full"===o.kind)t.changes.unshift({kind:"full",value:r}),r=o.value;else{const n=i.reducer(e.metaData,o);r=n.value,t.changes.push(...n.invertingChanges)}return{value:{resources:e.resources,metaData:r},invertingChanges:[t]}}}},n.squashJsonAndFull=e=>{const n=e.findIndex((e=>"full"===e.kind));return-1===n?i.squasher(e):[e[n],...i.squasher(e.slice(n+1))]},n.findPrevChange=(e,n)=>{const t=e.findIndex((e=>"full"===e.kind));if(-1===t)return e.findIndex((e=>e.kind===n));const r=e.slice(t+1).findIndex((e=>e.kind===n));return-1===r?r:r+t+1},n.querySquasher=e=>e.reduce(((e,t)=>{if(0===e.length)return e.push(t),e;if("full"===t.kind)return[t];if("meta"===t.kind){const r=(0,n.findPrevChange)(e,"meta");if(-1===r)return e.push(t),e;const o=e[r];e.splice(r,1);const i=o.changes.concat(t.changes),s={kind:"meta",changes:(0,n.squashJsonAndFull)(i)};return e.push(s),e}if("partial"===t.kind){const r=(0,n.findPrevChange)(e,"partial");if(-1===r)return e.push(t),e;const i=e[r];e.splice(r,1);const s=[...i.added],a=[...i.removed],c=e=>{s.find((n=>o(n,e)))||s.push(e)},l=e=>{const n=s.findIndex((n=>o(n,e)));-1!==n?s.splice(n,1):a.find((n=>o(n,e)))||a.push(e)};t.added.forEach(c),t.removed.forEach(l),e.push({kind:"partial",added:s,removed:a})}return e}),[]),n.queryManipulator={reducer:n.queryReducer,squasher:n.querySquasher},n.isSameResource=function(e,n){return e.getType()===n.getType()&&e.getSerializedId()===n.getSerializedId()}},75884:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.stringManipulatorWithId=n.stringManipulator=n.stringSquasher=n.getDeltaFromPartialChange=n.stringPartialChange=n.stringPartialChangeByValues=n.getChangeRanges=void 0;const r=t(98522),o=t(91570);n.getChangeRanges=function(e){var t;const r=(0,n.stringSquasher)(e);return"full"===(null===(t=r[0])||void 0===t?void 0:t.kind)?[{from:0,length:r[0].value.length,newLength:r[0].value.length}]:r.length?[r.map((e=>({change:e.at,length:e.del,newLength:e.add.length})))]:[{from:0,length:0,newLength:0}]},n.stringPartialChangeByValues=(e,n,t)=>{if(n>t)throw new Error("string partial change, to must be equal or greater than at");return{kind:"partial",at:n,del:t-n,add:e}},n.stringPartialChange=(e,t,r)=>(0,n.stringPartialChangeByValues)(e,t,r),n.getDeltaFromPartialChange=e=>e.add.length-e.del;const i=(e,n)=>{switch(n.kind){case"full":return{value:n.value,invertingChanges:[{kind:"full",value:e}]};case"partial":{const t=n.at+n.del,r=e.slice(n.at,t);return{value:e.slice(0,n.at)+n.add+e.slice(t),invertingChanges:[{kind:"partial",at:n.at,del:n.add.length,add:r}]}}}};n.stringSquasher=e=>{const n=e.findIndex((e=>"full"===e.kind)),t=-1!==n?e[n]:void 0,s=-1!==n?e.slice(n+1):e;if(t){let e=t.value;for(const n of s)e=i(e,n).value;return[(0,r.fullChange)(e)]}return s.reduce(((e,n)=>{const t=(0,o.last)(e);if(t&&(0,o.textRangeHitTest)({from:t.at,to:t.at+t.add.length},{from:n.at,to:n.at+n.del})){s.length,e.pop();const r=n.at-t.at,o=Math.max(0,r),i=-Math.min(0,r),a=t.add.slice(0,o)+n.add+t.add.slice(r+n.del),c=Math.max(0,n.del-t.add.length+r);e.push({kind:"partial",at:Math.min(t.at,n.at),del:i+c+t.del,add:a})}else e.push(n);return e}),[])};const s=(e,n,t)=>{if(n.find((e=>"full"===e.kind||t.find((e=>"full"===e.kind)))))return{changesToApply:[],changesRevoked:t};const r=[],o=[];for(const e of n){const n=o.findIndex((({pos:n})=>n>=e.at)),t=n>=0?o[n]:void 0;if(t){const n=e.at>Math.max(0,t.pos+t.delta)?e.at-t.delta:e.at,r=t.delta+e.add.length-e.del;n===t.pos?(t.del+=e.del,t.delta=r):o.push({del:e.del,delta:r,pos:n})}else o.push({del:e.del,delta:e.add.length-e.del,pos:e.at})}for(const e of t){const n=o.findIndex((({pos:n})=>n<=e.at)),t=n>=0?o[n]:void 0;t?e.at<t.pos+t.del||r.push({kind:"partial",add:e.add,at:e.at+t.delta,del:e.del}):r.push(e)}return{changesToApply:r,changesRevoked:[]}};n.stringManipulator={reducer:i,squasher:n.stringSquasher,merger:s},n.stringManipulatorWithId=()=>({reducer:i,squasher:n.stringSquasher,merger:s})},25076:(e,n,t)=>{"use strict";var r;Object.defineProperty(n,"__esModule",{value:!0}),n.PluggableResource=n.ResourceField=n.PluggableResourceEntryDefinition=n.defaultMergeConfig=void 0;const o=t(93849),i=t(14572);n.defaultMergeConfig=(e,n)=>e&&e.constructor===Object?{...e,...n}:n||e;class s extends o.FeatureInput{constructor(e,n,t){super(o.AllEnvironments,o.AllEnvironments),this.customKey=e,this.defaultValue=n,this.mergeConfig=t,this[r]=!0,this.defaultValue=n}getTypeName(){return this.typeName}[(r=o.CONFIGURABLE,o.IDENTIFY_API)](e,n){if(this.customKey)this.typeName=this.customKey;else{const t=((e,n)=>`${e}.${n}`)(e,n);this.typeName=t}}[o.CREATE_RUNTIME](e,n,t){const r=e.getTopLevelConfig(n,t).reduce(((e,n)=>this.mergeConfig(e,n)),this.defaultValue);return new a(this.typeName,r,this.mergeConfig)}[o.REGISTER_VALUE](e,n,t){return t}}n.PluggableResourceEntryDefinition=s;class a{constructor(e,n,t){this.key=e,this.defaults=n,this.mergeConfig=t}}n.ResourceField=a;class c extends i.Resource{get(e){if(this.isDisposed())return;const n=e.defaults,t=this.getLatest()[e.key];return(null==n?void 0:n.constructor)===Object?e.mergeConfig(n,t):t||n}merge(e,n){this.getLatest()[e.key]?this.batcher.batchAll((()=>{for(const t of Object.keys(n))this.applyChange({kind:"add",value:n[t],path:[e.key,t]})})):this.applyChange({kind:"add",value:n,path:[e.key]})}}n.PluggableResource=c},90294:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.QueryResource=void 0;const r=t(14572),o=t(91439),i=t(86307);class s extends r.Resource{constructor(e,n){super(e,{batcher:n.batcher,manipulator:o.queryManipulator,provider:n.provider,resourceType:n.resourceType}),this.results=new Set,this.disposedResults=new Set,this.updatedResults=new Set,this.snap=this.createSnapshot()}getResults(){return this.results}cloneResults(){return new Set([...this.results])}getResult(e,n){return this.findResourceInSet(this.results,{id:n,type:e.getTypeName(),serializedId:(0,i.serializeId)(n)})||null}getMetaData(){return this.getLatest().metaData}setResults(e=undefined,n,t,r=!1){for(const e of n)this.disposedResults.add(e);for(const e of t)this.updatedResults.add(e);e&&(this.results=e),r&&this.dispatchEvent({id:this.getId(),serializedId:this.getSerializedId()})}dispatchEvent(e){const n=this.snap;this.snap=this.createSnapshot();const t=this.getChangesFromVersion(n),r=new Set,o=new Set,i=this.updatedResults;for(const e of t)switch(e.kind){case"full":break;case"partial":for(const n of e.added){const e=this.findResourceInSet(this.results,n);e&&r.add(e)}for(const n of e.removed){const e=this.findResourceInSet(this.disposedResults,n);e&&o.add(e)}}this.updatedResults=new Set,this.disposedResults=new Set,(r.size||o.size||i.size)&&super.dispatchEvent({added:r,removed:o,changed:i,...e})}findResourceInSet(e,{type:n,serializedId:t}){return[...e].find((e=>e.getType()===n&&e.getSerializedId()===t))}}n.QueryResource=s},86307:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.ResourceManager=n.deserializeId=n.serializeId=void 0;const r=t(98522),o=t(91570),i=t(76893);function s(e){return JSON.stringify(null!=e?e:{},Object.keys(null!=e?e:{}).sort())}function a(e){return JSON.parse(e)}n.serializeId=s,n.deserializeId=a,n.ResourceManager=class{constructor(e,n,t,r,i,a=n,c=[]){this.strategy=e,this.typeName=n,this.syncer=t,this.batcher=r,this.logger=i,this.baseTypeName=a,this.dependenciesBaseTypeName=c,this.listeners=new Set,this.inBatchlisteners=new Set,this.listListeners=new Set,this.openResources=new Map,this.serializeIdsCache=new Map,this.syncerAPI={dispatchChanges:e=>{const n=new Set(e.map((e=>this.openResources.get(e))));for(const e of this.inBatchlisteners)e(n)},get:(e,n)=>this.get(e,n),getResource:e=>this.openResources.get(this.cachedSerializeId(e)),getOpen:()=>this.getOpenResources(),isOpen:e=>this.isOpen(e),onDependencyChange:e=>this.strategy.onDependencyChange?this.strategy.onDependencyChange(this.openResources,e):{recomputedVal:[],recomputedStatus:[]},hasComputeBack:()=>void 0!==this.strategy.onComputeBack,onComputeBack:e=>{var n,t,r;return null!==(r=null===(t=(n=this.strategy).onComputeBack)||void 0===t?void 0:t.call(n,e))&&void 0!==r?r:[]},hasDependenciesToSync:()=>!!this.strategy.dependenciesToSync,dependenciesToSync:e=>this.strategy.dependenciesToSync(e),getMasterSyncerId:()=>this.strategy.getMasterSyncerId(),isLocalChangeAllowed:()=>this.strategy.isLocalChangeAllowed(),remoteInitializeResource:(e,n)=>this.remoteInitializeResource(e,n),onRemoteChanges:(e,n,t,r)=>this.strategy.onRemoteChanges(e,n,t,r),subscribeToOpen:e=>this.subscribeToOpened(e),resourceManager:this},this.isOpen=e=>this.openResources.has(this.cachedSerializeId(e)),this.isProviderOpen=async e=>{if(this.isOpen(e))return!0;const n=this.strategy.getMasterSyncerId();return n!==this.syncer.id&&await this.syncer.isRemoteOpen(this.typeName,e,n)},this.remoteInitializeResource=(e,n)=>{const t=this.strategy.remoteInitializeResource(e,n);return this.onResourceCreated(t).catch(o.reportError),t},this.createResource=(e,n)=>{const t=this.strategy.createResource(e);return n&&t.use(n),this.openResources.set(this.cachedSerializeId(e),t),this.onResourceCreated(t).catch(o.reportError),t},this.onResourceCreated=async e=>{this.openResources.set(e.getSerializedId(),e),e.subscribeToDispose(this.disposeResource),e.isReady()||await e.ready,this.dispatchOpenListEvent([e.getSerializedId()])},this.dispatchOpenListEvent=(e=[],n=[])=>{for(const t of this.listListeners)t(e,n)},this.disposeResource=e=>{this.dispatchOpenListEvent([],[e.getSerializedId()]),this.openResources.delete(e.getSerializedId())},this.cachedSerializeId=e=>{const n=this.serializeIdsCache.get(e);if(n)return n;{const n=s(e);return this.serializeIdsCache.set(e,n),n}},this.batcherListerer=e=>{if(e.changed[this.getTypeName()]||e.changedStatus[this.getTypeName()]){const n=this.getResources(e.changed[this.getTypeName()]),t=this.getResources(e.changedStatus[this.getTypeName()]);this.listeners.forEach((e=>e(n,t)))}};const l=this.strategy.getManipulator();t.registerResourceType(n,{manipulator:l,resourceManager:this.getSyncerAPI(),baseTypeName:a,dependenciesBaseTypeName:c})}addDependencyResourceManager(e){this.syncer.addResourceDependency(this,e)}getSyncerAPI(){return this.syncerAPI}getTypeName(){return this.typeName}isResourceOfType(e){return e.getType()===this.getTypeName()}getBatcher(){return this.batcher}get(e,n){let t;return this.isOpen(e)?(t=this.openResources.get(this.cachedSerializeId(e)),n&&t.use(n)):t=this.createResource(e,n),t}getIfReady(e){const n=this.openResources.get(this.cachedSerializeId(e));if(n&&n.isReady())return n}async getReady(e,n){const t=this.get(e,n);return await t.ready,t}getOpenResources(){return[...this.openResources.keys()]}getOpenResourceDeserializedIds(){return[...this.openResources.values()].map((e=>e.getId()))}reEvaluateValue(e){const n=this.openResources.get(this.cachedSerializeId(e));if(n){if(!this.strategy.getValueFromHandler)throw new Error("type strategy does not support invalidation");const t=this.strategy.getValueFromHandler(e,n);(0,i.isPromise)(t)?t.then((e=>{n.isDisposed()||this.setResourceValue(n,e)})).catch(o.reportError):this.setResourceValue(n,t)}}setResourceValue(e,n){const t=e.getLatest();n.value!==t&&(e.applyChange((0,r.fullChange)(n.value)),e.setStatus(n.status||{valid:!0}))}subscribeToAny(e){this.subscribeToBatcher(),this.listeners.add(e)}unsubscribeFromAny(e){this.listeners.delete(e)}subscribeToOpened(e){this.listListeners.add(e)}unsubscribeToOpened(e){this.listListeners.delete(e)}subscribeDuringBatch(e){this.inBatchlisteners.add(e)}unsubscribeDuringBatch(e){this.inBatchlisteners.delete(e)}subscribeToBatcher(){this.batcher.subscribe(this.batcherListerer)}getResources(e){return new Set((null==e?void 0:e.map((e=>this.get(a(e)))))||[])}}},14572:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.Resource=n.ResourceSnapshot=void 0;const r=t(98522),o=t(76893),i=t(86307),s=t(91570);class a{constructor(e,n){this.ofVer=e,this.disposer=n,this.disposed=!1}dispose(){this.disposer(this),this.disposed=!0}isDisposed(){return this.disposed}}n.ResourceSnapshot=a,n.Resource=class{constructor(e,n,t){this.id=e,this.validateChange=t,this.ready=void 0,this.subscribers=new Set,this.disposeSubscribers=new Set,this.status={valid:!0},this.disposed=!1,this.base=void 0,this.changes=[],this.invertingChanges=[],this.projections={},this.snaps=new Set,this.lastProjection=void 0,this.batchStart=void 0,this._ready=!1,this.disposeCheckTimer=void 0,this.disposeSnap=e=>{if(!this.snaps.has(e))throw(0,o.unknownVersionError)(e.ofVer,this.getSerializedId(),this.currentVersion);this.snaps.delete(e);const n=e.ofVer,t=[...this.snaps];t.find((e=>e.ofVer===n))||delete this.projections[n];const i=t.reduce(((e,n)=>Math.min(e,n.ofVer)),Number.MAX_SAFE_INTEGER),s=this.changes.findIndex((e=>e.version>i));if(s>0){const e=this.changes.splice(0,s),n=(e,n)=>{let t=e;for(const e of n)if((0,r.isFullChange)(e))t=e.value;else{const{value:n}=this.manipulator.reducer(t,e);t=n}return t};this.base={value:n(this.base.value,e.map((e=>e.change))),version:i}}},this.serializedId=(0,i.serializeId)(e),this.users=new Set,this.provider=n.provider,this.manipulator=n.manipulator||o.fullChangeManipulator,this.batcher=n.batcher,this.resourceTypeId=n.resourceType,this.currentVersion=r.FIRST_VERSION,this.provider.dispose&&this.disposeSubscribers.add(this.provider.dispose);try{const n=this.provider.provide(e,this);(0,o.isPromise)(n)?(this.ready=new Promise(((e,n)=>{this._resolveReady=e})),n.then((e=>{this.base={value:e.value,version:r.FIRST_VERSION},this.status=e.status||{valid:!0},this.lastProjection=e.value,this.triggerDisposeCheck(),this._ready=!0,this.ready=void 0,this._resolveReady(e.value)})).catch((e=>{console.error(e),this.invalidate(`Provider of resource type ${this.getType()} and id ${this.getSerializedId()} failed to provide value, reason: ${e}`),this.base=void 0,this._ready=!0,this.ready=void 0,this._resolveReady(void 0)}))):(this._ready=!0,this.base={value:n.value,version:r.FIRST_VERSION},this.lastProjection=n.value,this.status=n.status||{valid:!0})}catch(e){console.error(e),this.invalidate(`Provider of resource type ${this.getType()} id ${this.getSerializedId()} failed to provide value, error: ${e}`),this.base=void 0,this._ready=!0,this.ready=void 0}}getType(){return this.resourceTypeId}getId(){return this.id}getSerializedId(){return this.serializedId}getManipulator(){return this.manipulator}getCurrentVersion(){return this.currentVersion}isChanged(){return this.currentVersion!==r.FIRST_VERSION}getBatcher(){return this.batcher}createSnapshot(){const e=new a(this.currentVersion,this.disposeSnap);return this.snaps.add(e),this.projections[this.currentVersion]||(this.isReady()?this.projections[this.currentVersion]=this.isValid()?this.getLatest():void 0:this.ready.then((()=>{this.snaps.size&&(this.projections[this.currentVersion]=this.isValid()?this.getLatest():void 0)})).catch(s.reportError)),e}isReady(){return this._ready}applyChange(e,n=!1){var t;return null===(t=this.validateChange)||void 0===t||t.call(this,e),this.applyChangeInternal(e,n)}applyChanges(e,n=!1){this.batcher.batchIfNeeded((()=>{for(const t of e)this.applyChange(t,n)}))}applyChangeInternal(e,n=!1){if(this.disposed&&!n)throw(0,o.disposedResourceError)(this.getType(),this.getSerializedId());if(!this.status.valid&&!n)throw(0,o.invalidResourceError)(this.getType(),this.getSerializedId(),this.getInvalidationMessage());if(!this.isReady()&&!n)throw(0,o.nonReadyResourceError)(this.getType(),this.getSerializedId());const t=void 0!==this.lastProjection?this.lastProjection:this.base.value,r=()=>{if(this.batcher.inAtomic){this.batcher.registerForBatch(this,this.getSerializedId(),this.resourceTypeId,!1);const e=this.getType(),n=this.getSerializedId();this.batcher.getAtomicSnapshot(e,n)||this.batcher.setAtomicSnapshot(e,n,this.createSnapshot())}this.batchStart||(this.batchStart=this.createSnapshot());const n=this.applyChangesInternal(t,[e]),r=this.wrapWithVersion(this.changes,e)[0];this.currentVersion=r.version,this.changes.push(r),this.lastProjection=n,this.dispatchOrPend(!1)};if(void 0!==this.batcher.getRunningBatchId()&&this.batcher.isBatching())r();else{const e=this.batcher.runAtomic(r);if("failure"===e.status)throw e.error}}subscribe(e){this.subscribers.add(e)}subscribeToDispose(e){this.disposeSubscribers.add(e)}subscribeOnce(e){const n=t=>{this.subscribers.delete(n),e(t)};this.subscribers.add(n)}unsubscribe(e,n=!0){this.subscribers.delete(e),n&&this.triggerDisposeCheck()}unsubscribeAll(e=!0){this.subscribers=new Set([]),e&&this.triggerDisposeCheck()}async waitForValid(){if(!this.isValid()){const e=new Promise((e=>{const n=()=>{this.isValid()?e():this.subscribeOnce(n)};this.subscribeOnce(n)}));await e}}getProjection(e){return this.projections[e.ofVer]}getChangesBetweenVersion(e,n){return void 0===e?[]:this.getAnyChangesBetweenVersionInternal(this.changes,e.ofVer,n.ofVer)}getChangesFromVersion(e){return this.getAnyChangesBetweenVersionInternal(this.changes,e.ofVer,this.currentVersion)}getInvertingChangesBetweenVersion(e,n){return void 0===e?[]:this.getAnyChangesBetweenVersionInternal(this.invertingChanges,e.ofVer,n.ofVer).reverse()}getInvertingChangesFromVersion(e){return this.getAnyChangesBetweenVersionInternal(this.invertingChanges,e.ofVer,this.currentVersion).reverse()}getLatest(){if(!this.isReady())throw(0,o.unknownResourceError)(this.getType(),this.getSerializedId());return this.lastProjection}getSavedChangeCount(){return this.changes.length}getSnapsCount(){return this.snaps.size}isDisposed(){return this.disposed}use(e){this.users.add(e)}release(e,n=!0){this.users.delete(e),n&&this.triggerDisposeCheck()}commit(e){this.clearBatchStart(),this.dispatchEvent({batchId:e})}revert(){if(this.batchStart){const e=this.projections[this.batchStart.ofVer];this.changes=this.changes.slice(0,this.changes.findIndex((e=>e.version===this.batchStart.ofVer))+1),this.lastProjection=e,this.currentVersion=this.batchStart.ofVer,this.clearBatchStart()}}clearBatchStart(){this.batchStart&&(this.batchStart.dispose(),this.batchStart=void 0)}onResourceDisposed(){}invalidate(e){this.setStatus({valid:!1,message:e})}restore(){this.setStatus({valid:!0})}isValid(){return this.status.valid}getInvalidationMessage(){return this.status.message}setStatus(e){return(e.valid!==this.status.valid||e.message!==this.status.message)&&(this.status=e,void 0!==this.batcher.getRunningBatchId()&&this.batcher.isBatching()?this.dispatchOrPend(!0):this.batcher.batchAll((()=>{this.dispatchOrPend(!0)})),!0)}getStatus(){return this.status}revertChanges(e){const n=this.changes.length-e.length,t=new Array(n+1);t[0]=(0,r.fullChange)(this.base.value);for(let e=0;e<n;e++)t[e+1]=this.changes[e].change;const o=this.getManipulator(),i=o.squasher?o.squasher(t):t;for(const e of i)this.applyChange(e);return 0!=i.length}dispatchEvent(e){const n={...e,serializedId:this.serializedId,id:this.id};for(const e of this.subscribers)e(n)}dispose(){void 0!==this.disposeCheckTimer&&(clearTimeout(this.disposeCheckTimer),this.disposeCheckTimer=void 0),this.subscribers.clear(),this.disposed=!0,this.batcher&&this.batcher.unregisterFromBatch(this,this.getSerializedId(),this.resourceTypeId);for(const e of this.disposeSubscribers)e(this);this.base=void 0,this.changes=[],this.invertingChanges=[]}triggerDisposeCheck(){void 0!==this.disposeCheckTimer&&clearTimeout(this.disposeCheckTimer),this.disposeCheckTimer=setTimeout((()=>{this.disposeCheckTimer=void 0,this.disposeIfUnused()}),10)}disposeIfUnused(){this.isDisposed()||0!==this.users.size||0!==this.subscribers.size||this.dispose()}getAnyChangesBetweenVersionInternal(e,n,t){const o=[];if(n>=t)return o;n=n===r.FIRST_VERSION?0:n+1,t+=1;for(let r=0;r<e.length;r++){const{version:i,change:s}=e[r];if(i>=n&&i<t&&o.push(s),i===t)break}return o}dispatchOrPend(e){this.batcher&&this.batcher.isBatching()?this.batcher.registerForBatch(this,this.getSerializedId(),this.resourceTypeId,e):this.dispatchEvent()}wrapWithVersion(e,...n){let t=e.length?e[e.length-1].version:this.currentVersion;return n.map((e=>(t++,{change:e,version:t})))}applyChangesInternal(e,n){let t=e;for(const e of n)if((0,r.isFullChange)(e)){const n=t;t=e.value,this.invertingChanges.push(...this.wrapWithVersion(this.invertingChanges,(0,r.fullChange)(n)))}else{const{value:n,invertingChanges:r}=this.manipulator.reducer(t,e);t=n,this.invertingChanges.push(...this.wrapWithVersion(this.invertingChanges,...r))}return t}}},98593:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.OneWayComputedStrategy=n.OneWayComputedStrategyMaster=void 0;const r=t(14572),o=t(76893),i=t(91792),s=t(91570),a={status:!1,value:!1};class c{constructor(e,n,t,r,o,i){this.resourceClass=e,this.envId=n,this.type=t,this.batcher=r,this.manipulator=o,this.handler=i,this.dependencies={},this.snaps=new Map,this.dependencyTypes=new Set,this.inAsyncRecompute=new Set,this.pendingRecompute={}}getResourceDependenciesType(){return this.dependencyTypes}getManipulator(){return this.manipulator}createResource(e){const n={provide:(e,n)=>{const t=e=>{for(const t of e.dependencies)t.use(n);return this.updateDependencies(n,e.dependencies),e},r=this.safeCompute(e,n);return(0,o.isPromise)(r)?r.then(t):t(r)},dispose:e=>{this.handler.dispose&&this.handler.dispose(e),this.onResourceDisposed(e)}},t=new this.resourceClass(e,{batcher:this.batcher,provider:n,manipulator:this.manipulator,resourceType:this.type});return t.isReady()?(this.updateSnapshot(t),this.updateSnapshots(this.dependencies[t.getSerializedId()]||[])):t.ready.then((()=>{this.updateSnapshot(t),this.updateSnapshots(this.dependencies[t.getSerializedId()]||[])})).catch((e=>(0,o.reportResourceError)(t," initialization ",e))),t}remoteInitializeResource(){throw new Error("one way computed master cannot be remote initialized")}getValueFromHandler(e,n){return this.safeCompute(e,n)}onRemoteChanges(e,n,t){return{status:"failure",statusChanged:!!n.newStatus&&t.setStatus(n.newStatus),reason:"OneWayComputedStrategyMaster does not allow remote changes from "+e}}isLocalChangeAllowed(){return!0}getMasterSyncerId(){return this.envId}onResourceDisposed(e){const n=e.getSerializedId();if(this.dependencies[n]){for(const t of this.dependencies[n])t.release(e);delete this.dependencies[n]}}onDependencyChange(e,n){const t=Object.keys(n),r=this.getResourceDependenciesType();if(!t.find((e=>r.has(e))))return{recomputedVal:[],recomputedStatus:[]};const i=[],s=[],a=new Set;for(const[t,r]of e.entries()){const e=this.dependencies[t];if(e){const c=(0,o.filterSet)(e,(e=>n[e.getType()]&&n[e.getType()].includes(e.getSerializedId())));if(c.size){c.forEach((e=>a.add(e)));const e=this.recomputeResource(r,c);!0===e.value&&i.push(t),!0===e.status&&s.push(t)}}}return this.updateSnapshots(a),{recomputedVal:i,recomputedStatus:s}}recomputeResource(e,n){const t=e.getSerializedId(),r=this.dependencies[t];if(this.inAsyncRecompute.has(t))return this.pendingRecompute[t]||(this.pendingRecompute[t]=new Set),(0,s.addToSet)(this.pendingRecompute[t],n),{status:!1,value:!1};this.inAsyncRecompute.add(t);const i=n=>{this.updateDependencies(e,n.dependencies);let r=a;if(!e.isDisposed()){const o=e.getStatus(),i={status:n.status.valid!==o.valid||n.status.message!==o.message,value:!!n.changes.length};(i.value||i.status)&&e.getBatcher().batchIfNeeded((()=>{for(const t of n.changes)e.applyChange(t,!0);e.setStatus(n.status)}));const s=this.pendingRecompute[t];s&&(Promise.resolve().then((()=>this.recomputeResource(e,s))),delete this.pendingRecompute[t]),r=i}return this.inAsyncRecompute.delete(t),r},c=n=>{(0,o.reportResourceError)(e," recompute ",n);const r=n.message;return this.inAsyncRecompute.delete(t),e.isValid()||e.getStatus().message!==r?(e.invalidate(r),{status:!0,value:!1}):a};try{const t=this.handler.recompute(e,this.snaps,n,r);if(!(0,o.isPromise)(t))return i(t);t.then(i).catch(c)}catch(e){return c(e)}return a}updateDependencies(e,n){const t=this.dependencies[e.getSerializedId()];if(t!==n)if(this.dependencies[e.getSerializedId()]=n,t){for(const r of t)n.has(r)||r.release(e);for(const r of n)t.has(r)||(r.use(e),this.dependencyTypes.add(r.getType()),this.updateSnapshot(r))}else for(const t of n)t.use(e),this.dependencyTypes.add(t.getType())}updateSnapshots(e){for(const n of e)this.updateSnapshot(n)}updateSnapshot(e){var n;const t=e.getType(),r=e.getSerializedId();this.snaps.has(t)||this.snaps.set(t,new Map),null===(n=this.snaps.get(t).get(r))||void 0===n||n.dispose(),this.snaps.get(t).set(r,e.createSnapshot())}safeCompute(e,n){try{const t=this.handler.compute(e,n);return(0,o.isPromise)(t)?t.catch((e=>((0,o.reportResourceError)(n," safe compute ",e),{value:void 0,status:{valid:!1,message:e.message},dependencies:new Set}))):t}catch(e){return(0,o.reportResourceError)(n," safe compute ",e),{value:void 0,status:{valid:!1,message:e.message},dependencies:new Set}}}}n.OneWayComputedStrategyMaster=c,n.OneWayComputedStrategy=function(e){return(n,t,o)=>{const s=e.customResourceClass||r.Resource,a="string"==typeof e.sourceEnv?e.sourceEnv:e.sourceEnv.env;return t.id===a?new c(s,a,n,o,e.manipulator,e.handler):new i.OneWayStrategySlave(s,a,n,o,e.manipulator,t.subscribeToRemote)}}},99540:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.OneWayIncrementalComputedStrategy=n.OneWayIncrementalComputedStrategyMaster=void 0;const r=t(14572),o=t(76893),i=t(91792),s=t(73836);class a{constructor(e,n,t,r,i,s,a,c=(()=>Date.now())){this.resourceClass=e,this.envId=n,this.type=t,this.batcher=r,this.manipulator=i,this.handler=s,this.options=a,this._timer=c,this.dependencies={},this.snaps=new Map,this.tasks={},this.fullTasks={},this.timeouts={},this.resources=new Map,this.changesFromBuffer={},this.dependencyTypes=new Set,this.addChangesToBuffer=e=>{for(const[n,t]of Object.entries(e)){this.changesFromBuffer[n]||(this.changesFromBuffer[n]=[]);for(const e of t)this.changesFromBuffer[n].includes(e)||this.changesFromBuffer[n].push(e)}},this.onBufferEnd=()=>{const e=[],n=[],t=new Set,r=this.changesFromBuffer;this.changesFromBuffer={};const i=this.resources;for(const[s,a]of i.entries()){const i=this.dependencies[s];if(i){const c=(0,o.filterSet)(i,(e=>r[e.getType()]&&r[e.getType()].includes(e.getSerializedId())));if(c.size){t.add(a),c.forEach((e=>t.add(e)));const r=t=>{for(const e of t.changes)a.applyChange(e,!0);const r=a.setStatus(t.status||{valid:!0});return t.changes.length&&e.push(s),r&&n.push(s),{changedVal:t.changes.length,changedStatus:r}},i=e=>{this.updateDependencies(a,e.dependencies);const n=this.performCompute(a,this.snaps,e.tasks);return(0,o.isPromise)(n)?n.then(r):r(n)};this.timeouts[a.getSerializedId()]&&(clearInterval(this.timeouts[a.getSerializedId()]),this.timeouts[a.getSerializedId()]=void 0);const l=this.recomputeResourceTasks(a,c);try{if((0,o.isPromise)(l))l.then(i).catch((e=>{(0,o.reportResourceError)(a," recompute ",e),a.invalidate(e.message)}));else{const e=i(l);(0,o.isPromise)(e)&&e.catch((e=>{(0,o.reportResourceError)(a," recompute ",e),a.invalidate(e.message)}))}}catch(e){(0,o.reportResourceError)(a," recompute ",e),a.invalidate(e.message)}}}}this.updateSnapshots(t)},this.provider={provide:(e,n)=>{const t=e=>{for(const t of e.dependencies)t.use(n);this.updateDependencies(n,e.dependencies),this.onTasksComputed(n,e.tasks);const t=this.performCompute(n,new Map,e.tasks),r=e=>{const n=e.changes;let t=this.options.startValue;0===n.length&&(t=this.options.emptyValue);for(const e of n)t=this.manipulator.reducer(t,e).value;return{value:t,status:e.status}};return(0,o.isPromise)(t)?t.then(r):r(t)},r=this.computeTasks(e,n);return(0,o.isPromise)(r)?r.then(t):t(r)},dispose:e=>{this.handler.dispose&&this.handler.dispose(e),this.onResourceDisposed(e)}}}getResourceDependenciesType(){return this.dependencyTypes}getManipulator(){return this.manipulator}createResource(e){const n=new this.resourceClass(e,{batcher:this.batcher,provider:this.provider,manipulator:this.manipulator,resourceType:this.type}),t=this.dependencies[n.getSerializedId()]||[];return n.isReady()?(this.updateSnapshot(n),this.updateSnapshots(t)):n.ready.then((()=>{this.updateSnapshot(n),this.updateSnapshots(t)})).catch((e=>(0,o.reportResourceError)(n," initialization ",e))),n}remoteInitializeResource(){throw new Error("one way computed master cannot be remote initialized")}getValueFromHandler(e,n){return this.provider.provide(e,n)}onRemoteChanges(e,n,t){return{status:"failure",statusChanged:!!n.newStatus&&t.setStatus(n.newStatus),reason:"OneWayComputedStrategyMaster does not allow remote changes from "+e}}isLocalChangeAllowed(){return!0}getMasterSyncerId(){return this.envId}onResourceDisposed(e){const n=e.getSerializedId();if(this.timeouts[n]&&(clearTimeout(this.timeouts[n]),this.timeouts[n]=void 0),this.dependencies[n]){for(const t of this.dependencies[n])t.release(e);delete this.dependencies[n]}}onDependencyChange(e,n){const t=Object.keys(n),r=this.getResourceDependenciesType();return t.find((e=>r.has(e)))?(this.bufferTimeout&&clearTimeout(this.bufferTimeout),this.addChangesToBuffer(n),this.resources=e,this.bufferTimeout=setTimeout(this.onBufferEnd,this.options.changeBufferTime),{recomputedVal:[],recomputedStatus:[]}):{recomputedVal:[],recomputedStatus:[]}}recomputeResourceTasks(e,n){const t=e.getSerializedId(),r=this.dependencies[t];try{const t=this.handler.updateTasks(e,this.snaps,n,r,this.getTasks(e));return(0,o.isPromise)(t)?t.then((n=>(this.onTasksComputed(e,n.tasks),n))).catch((n=>((0,o.reportResourceError)(e," recompute ",n),{tasks:[],status:{valid:!1,message:n.message},dependencies:r}))):(this.onTasksComputed(e,t.tasks),t)}catch(n){return(0,o.reportResourceError)(e," recomputeResourceTasks ",n),{tasks:[],status:{valid:!1,message:n.message},dependencies:r}}}getTasks(e){const n=e.getSerializedId();return this.tasks[n]||[]}onTasksComputed(e,n){const t=e.getSerializedId();this.tasks[t]=n,this.fullTasks[t]=n}updateDependencies(e,n){const t=this.dependencies[e.getSerializedId()];if(t!==n)if(this.dependencies[e.getSerializedId()]=n,t){for(const r of t)n.has(r)||r.release(e);for(const r of n)t.has(r)||(r.use(e),this.dependencyTypes.add(r.getType())),this.updateSnapshot(r)}else for(const t of n)t.use(e),this.dependencyTypes.add(t.getType()),this.updateSnapshot(t)}updateSnapshots(e){for(const n of e)this.updateSnapshot(n)}updateSnapshot(e){var n;const t=e.getType(),r=e.getSerializedId();this.snaps.has(t)||this.snaps.set(t,new Map),null===(n=this.snaps.get(t).get(r))||void 0===n||n.dispose(),this.snaps.get(t).set(r,e.createSnapshot())}computeTasks(e,n){try{const t=this.handler.getTasks(e,n);return(0,o.isPromise)(t)?t.catch((e=>((0,o.reportResourceError)(n," computeTasks ",e),{tasks:[],status:{valid:!1,message:e.message},dependencies:new Set}))):t}catch(e){return(0,o.reportResourceError)(n," computeTasks",e),{tasks:[],status:{valid:!1,message:e.message},dependencies:new Set}}}performCompute(e,n,t){const r=this._timer(),i={changes:[]},s=()=>this._timer()-r>this.options.maxWorkTime,a=[...t],c=t=>{const r=this.handler.performTask(t,e,n,a.slice(1)),l=t=>{if(a.shift(),i.changes.push(...t.changes),0===a.length||s()){this.tasks[e.getSerializedId()]=a;const t=this.handler.getProgressChanges(this.fullTasks[e.getSerializedId()],a);return i.changes.push(...t),a.length&&(this.timeouts[e.getSerializedId()]=setTimeout((()=>{this.performNextCompute(e,n)}),this.options.minSleepTime)),i}return c(a[0])};return(0,o.isPromise)(r)?r.then(l):l(r)};return 0===a.length?i:c(a[0])}performNextCompute(e,n){const t=this.getTasks(e);if(t.length){const r=this.performCompute(e,n,t),i=n=>{this.batcher.batchAll((()=>{for(const t of n.changes)e.applyChange(t);e.setStatus(n.status||{valid:!0})}))};return(0,o.isPromise)(r)?void r.then(i).catch((n=>(0,o.reportResourceError)(e," initialization ",n))):void i(r)}}}n.OneWayIncrementalComputedStrategyMaster=a,n.OneWayIncrementalComputedStrategy=function(e){return(n,t,o)=>{var c;const l=e.customResourceClass||r.Resource,d="string"==typeof e.sourceEnv?e.sourceEnv:e.sourceEnv.env;return t.id===d?new a(l,d,n,o,e.manipulator||new s.JsonManipulator,e.handler,{maxWorkTime:e.maxWorkTime,minSleepTime:e.minSleepTime,startValue:e.startValue,emptyValue:null!==(c=e.emptyValue)&&void 0!==c?c:{...e.startValue,progress:1},changeBufferTime:e.changeBufferTime},e.testTimer):new i.OneWayStrategySlave(l,d,n,o,e.manipulator||new s.JsonManipulator,t.subscribeToRemote)}}},91792:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.OneWayStrategy=n.OneWayStrategySlave=n.OneWayStrategyMaster=void 0;const r=t(14572),o=t(48074),i=t(76893),s=t(73836);class a{constructor(e,n,t,r,o,i){this.resourceClass=e,this.envId=n,this.type=t,this.batcher=r,this.manipulator=o,this.provider=i}getManipulator(){return this.manipulator}createResource(e){return new this.resourceClass(e,{batcher:this.batcher,provider:this.provider,manipulator:this.manipulator,resourceType:this.type})}remoteInitializeResource(){throw new Error(" one way strategy master cannot be remote initialized")}getValueFromHandler(e,n){try{return this.provider.provide(e,n)}catch(e){return(0,i.reportResourceError)(n," invalidate ",e),{value:void 0,status:{valid:!1,message:e.message}}}}onRemoteChanges(e,n,t){return{status:"failure",statusChanged:!!n.newStatus&&t.setStatus(n.newStatus),reason:"OneWayStrategyMaster does not allow remote changes from "+e}}getMasterSyncerId(){return this.envId}isLocalChangeAllowed(){return!0}}n.OneWayStrategyMaster=a;class c{constructor(e,n,t,r,o,i){this.resourceClass=e,this.masterId=n,this.type=t,this.batcher=r,this.manipulator=o,this.subscribeToRemote=i,this.remoteChanges=new WeakSet,this.validateChange=e=>{if(!this.remoteChanges.has(e))throw new Error(`Resource ${this.type} strategy doesn't allow local changes`);this.remoteChanges.delete(e)}}getManipulator(){return this.manipulator}createResource(e){const{promise:n,resolve:t,reject:r}=(0,o.deferred)(),i=new this.resourceClass(e,{batcher:this.batcher,provider:{provide:async()=>n},manipulator:this.manipulator,resourceType:this.type},this.validateChange);return this.subscribeToRemote(this.masterId,i).then((e=>{t(e)})).catch((e=>{r(e)})),i}remoteInitializeResource(e,n){return new this.resourceClass(e,{batcher:this.batcher,provider:{provide:()=>n},manipulator:this.manipulator,resourceType:this.type},this.validateChange)}onRemoteChanges(e,n,t){var r;const o=!!n.newStatus&&t.setStatus(n.newStatus);if(n.changes)for(const e of n.changes)this.remoteChanges.add(e),t.isReady()?t.applyChange(e,!0):null===(r=t.ready)||void 0===r||r.then((()=>{t.applyChange(e,!0)})).catch((e=>(0,i.reportResourceError)(t," remote changes applied ",e)));return{status:"success",statusChanged:o}}getMasterSyncerId(){return this.masterId}isLocalChangeAllowed(){return!1}}n.OneWayStrategySlave=c,n.OneWayStrategy=function(e){return(n,t,o)=>{const i=e.customResourceClass||r.Resource,l="string"==typeof e.sourceEnv?e.sourceEnv:e.sourceEnv.env;return t.id===l?new a(i,l,n,o,e.manipulator||new s.JsonManipulator,e.handler):new c(i,l,n,o,e.manipulator||new s.JsonManipulator,t.subscribeToRemote)}}},77163:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.QueryStrategy=n.QueryStrategySlave=n.QueryStrategyMaster=void 0;const r=t(91570),o=t(48074),i=t(91439),s=t(90294),a=t(98522),c=t(76893);class l{constructor(e,n,t,r,o,i,s){this.resourceClass=e,this.envId=n,this.type=t,this.batcher=r,this.queryResultTypes=o,this.dependenciesTypes=i,this.handler=s,this.inAsyncRecompute=new Set,this.pendingRecompute={},this.dependencies={},this.onQueryUpdate=(e,n,t)=>{var r,o;(r=this.dependencies)[o=e.getSerializedId()]||(r[o]=new Set),n.results.forEach((n=>n.use(e))),n.dependencies.forEach((n=>n.use(e)));const i=this.dependencies[e.getSerializedId()],s=new Set;for(const t of i)n.dependencies.has(t)||n.results.has(t)||t.release(e);for(const t of e.getResults())n.results.has(t)||(n.dependencies.has(t)||t.release(e),s.add(t));this.dependencies[e.getSerializedId()]=n.dependencies,e.setResults(n.results,s,t||new Set),e.setStatus(n.status)}}getManipulator(){return i.queryManipulator}createResource(e){let n;const t={provide:(e,t)=>{try{n=this.handler.query(e,t)}catch(e){(0,c.reportResourceError)(r," initialization ",e),n={dependencies:new Set,results:new Set,status:{valid:!1,message:e.message},metaData:null}}return(0,c.isPromise)(n)?n.catch((e=>((0,c.reportResourceError)(r," async init ",e),{dependencies:new Set,results:new Set,status:{valid:!1,message:e.message},metaData:null}))).then((e=>(this.onQueryUpdate(t,e),{value:d(e.results,e.metaData),status:e.status}))):{value:d(n.results,n.metaData),status:n.status}},dispose:e=>{this.handler.dispose&&this.handler.dispose(e),this.onResourceDisposed(e)}},r=new this.resourceClass(e,{batcher:this.batcher,provider:t,resourceType:this.type});return(0,c.isPromise)(n)||this.onQueryUpdate(r,n,void 0),r}remoteInitializeResource(){throw new Error(" two way startegy master cannot be remote initialized")}onRemoteChanges(e,n,t){return{status:"failure",statusChanged:!!n.newStatus&&t.setStatus(n.newStatus),reason:"QueryStrategyMaster does not allow remote changes from "+e}}isLocalChangeAllowed(){return!0}getMasterSyncerId(){return this.envId}dependenciesToSync(e){return e.getResults()}onDependencyChange(e,n){var t;const o=Object.keys(n),i=o.find((e=>this.dependenciesTypes.includes(e))),s=o.find((e=>this.queryResultTypes.includes(e)));if(!i&&!s)return{recomputedVal:[],recomputedStatus:[]};const a=[],l=[];for(const[o,s]of e.entries()){const e=this.dependencies[s.getSerializedId()]||new Set,d=i?(0,c.filterSet)(e,(e=>n[e.getType()]&&n[e.getType()].includes(e.getSerializedId()))):new Set,u=(0,c.filterSet)(s.getResults(),(e=>n[e.getType()]&&n[e.getType()].includes(e.getSerializedId())));if(d.size){if(this.inAsyncRecompute.has(o)){(t=this.pendingRecompute)[o]||(t[o]={modifiedDependencies:new Set,modifiedResults:new Set}),(0,r.addToSet)(this.pendingRecompute[o].modifiedDependencies,d),(0,r.addToSet)(this.pendingRecompute[o].modifiedResults,u);continue}this.applyAsyncChanges(s,o,d,u,a,l)}else u.size&&s.setResults(void 0,new Set,u)}return{recomputedVal:a,recomputedStatus:l}}afterRecomputeResource(e,n,t,r=[],o=[]){const i=e.getSerializedId(),s=function(e,n){const t=[],r=[];for(const t of e)n.has(t)||r.push(u(t));for(const r of n)e.has(r)||t.push(u(r));return{kind:"partial",added:t,removed:r}}(e.getResults(),n.results);this.onQueryUpdate(e,n,t),e.isValid()!==n.status.valid&&(o.push(i),e.setStatus(n.status)),e.isValid()&&e.applyChange(s),r.push(i),this.inAsyncRecompute.delete(i)}applyAsyncChanges(e,n,t,r,o=[],i=[]){try{this.inAsyncRecompute.add(n);const s=this.recomputeResource(e,t);(0,c.isPromise)(s)?s.then((t=>{const s=this.pendingRecompute[n];s&&(delete this.pendingRecompute[n],Promise.resolve().then((()=>{this.applyAsyncChanges(e,n,s.modifiedDependencies,s.modifiedResults)}))),this.afterRecomputeResource(e,t,r,o,i)})).catch((n=>{(0,c.reportResourceError)(e," recompute ",n),e.invalidate(n.message)})):this.afterRecomputeResource(e,s,r,o,i)}catch(n){(0,c.reportResourceError)(e," recompute ",n),e.invalidate(n.message)}}recomputeResource(e,n){const t=this.dependencies[e.getSerializedId()];try{if(this.handler.updateQuery){const r=this.handler.updateQuery(e,n,{results:e.cloneResults(),dependencies:t,status:e.getStatus(),metaData:e.getMetaData()});return(0,c.isPromise)(r)?r.catch((n=>((0,c.reportResourceError)(e," recompute ",n),{dependencies:t,results:new Set,status:{valid:!1,message:n.message},metaDataChanges:[]}))):r}const r=this.handler.query(e.getId(),e);return(0,c.isPromise)(r)?r.catch((n=>((0,c.reportResourceError)(e," recompute ",n),{dependencies:t,results:new Set,status:{valid:!1,message:n.message},metaData:null}))).then((n=>({...n,metaDataChanges:e.getMetaData()===n.metaData?[]:[(0,a.fullChange)(n.metaData)]}))):{...r,metaDataChanges:[]}}catch(n){return(0,c.reportResourceError)(e," recompute ",n),{dependencies:t,results:new Set,status:{valid:!1,message:n.message},metaDataChanges:[]}}}onResourceDisposed(e){const n=e.getSerializedId();if(this.dependencies[n]){for(const t of this.dependencies[n])t.release(e);delete this.dependencies[n]}for(const n of e.getResults())n.release(e)}}function d(e,n){const t=new Array(e.size);let r=0;for(const n of e)t[r]=u(n),r++;return{resources:t,metaData:n}}n.QueryStrategyMaster=l;const u=e=>({type:e.getType(),id:e.getId(),serializedId:e.getSerializedId()});class p{constructor(e,n,t,r,o,i,s){this.resourceClass=e,this.masterId=n,this.type=t,this.batcher=r,this.subscribeToRemote=o,this.queryResultTypes=i,this.getFromLocal=s}createResource(e){const{promise:n,resolve:t,reject:r}=(0,o.deferred)(),i=new this.resourceClass(e,{batcher:this.batcher,provider:{provide:()=>n,dispose:this.onResourceDisposed},resourceType:this.type});return this.subscribeToRemote(this.masterId,i).then((async e=>{await this.updateDependencies(i,e.value),t(e)})).catch((e=>{r(e)})),i}getManipulator(){return i.queryManipulator}remoteInitializeResource(e,n){return new this.resourceClass(e,{batcher:this.batcher,provider:{provide:()=>({value:n}),dispose:this.onResourceDisposed},resourceType:this.type})}onRemoteChanges(e,n,t){const r=!!n.newStatus&&t.setStatus(n.newStatus);return n.changes&&(n.changes.forEach((e=>{t.applyChange(e,!0);for(const n of e.removed)this.getFromLocal(n.type,n.id).release(t)})),this.updateDependencies(t,t.getLatest()).catch((e=>{throw new Error("query strategy, update dependecies failed with"+e)}))),{status:"success",statusChanged:r}}getMasterSyncerId(){return this.masterId}isLocalChangeAllowed(){return!1}getResourceDependenciesType(){return this.queryResultTypes}onDependencyChange(e,n){const t=Object.keys(n),r=this.getResourceDependenciesType();if(!t.find((e=>r.includes(e))))return{recomputedVal:[],recomputedStatus:[]};for(const t of e.values()){const e=t.getResults();if(e){const r=(0,c.filterSet)(e,(e=>n[e.getType()]&&n[e.getType()].includes(e.getSerializedId())));r.size&&t.setResults(void 0,new Set,r,!0)}}return{recomputedVal:[],recomputedStatus:[]}}async updateDependencies(e,n){const t=n.resources.map((n=>{const t=this.getFromLocal(n.type,n.id);return t.use(e),t})),r=t.filter((e=>!e.isReady())).map((e=>e.ready));r.length&&await Promise.all(r),e.setResults(new Set(t),e.cloneResults(),new Set)}onResourceDisposed(e){for(const n of e.getResults())n.release(e)}}n.QueryStrategySlave=p,n.QueryStrategy=function(e){return(n,t,r)=>{const o=e.customResourceClass||s.QueryResource,i="string"==typeof e.sourceEnv?e.sourceEnv:e.sourceEnv.env;return t.id===i?new l(o,i,n,r,e.resultTypes.map((e=>e.getTypeName())),e.dependencyTypes.map((e=>e.getTypeName())),e.handler):new p(o,i,n,r,t.subscribeToRemote,e.resultTypes.map((e=>e.getTypeName())),t.get.bind(t))}}},80375:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.TwoWayComputedStrategy=n.TwoWayComputedStrategySlave=n.TwoWayComputedStrategyMaster=void 0;const r=t(98522),o=t(14572),i=t(48074),s=t(76893),a=t(86307);class c{constructor(e,n,t,r,o,i,s,a){this.resourceClass=e,this.envId=n,this.type=t,this.batcher=r,this.syncer=o,this.manipulator=i,this.dependencyTypes=s,this.handler=a,this.dependencies=new Map,this.snaps=new Map,this.dependencySnaps=new Map}getResourceDependenciesType(){return this.dependencyTypes}getManipulator(){return this.manipulator}createResource(e){const n={provide:(e,n)=>{const t=e=>(this.updateDependencies(n,e.dependencies),e),r=this.safeCompute(e,n);return(0,s.isPromise)(r)?r.then(t):t(r)},dispose:e=>{this.handler.dispose&&this.handler.dispose(e),this.onResourceDisposed(e)}},t=new this.resourceClass(e,{batcher:this.batcher,provider:n,manipulator:this.manipulator,resourceType:this.type}),r=e=>{var n;const t=e.getType(),r=e.getSerializedId();this.snaps.has(t)||this.snaps.set(t,new Map),this.snaps.get(t).set(r,e.createSnapshot());const o=this.dependencies.get(r);if(o){this.dependencySnaps.has(r)||this.dependencySnaps.set(r,new Map);const e=this.dependencySnaps.get(r);for(const t of o){const r=t.getSerializedId(),o=t.getType();e.has(o)||e.set(o,new Map),null===(n=e.get(o).get(r))||void 0===n||n.dispose(),e.get(o).set(r,t.createSnapshot())}}};return t.isReady()?r(t):t.ready.then((()=>{r(t)})).catch((e=>(0,s.reportResourceError)(t," init ",e))),t}remoteInitializeResource(){throw new Error(" two way strategy master cannot be remote initialized")}getValueFromHandler(e,n){return this.safeCompute(e,n)}onRemoteChanges(e,n,t,r){const o=!!n.newStatus&&t.setStatus(n.newStatus),{changes:i}=n;if(i){const n=r.connections[e],s=t.getChangesFromVersion(n.approvedSnap);if(s.length>0){let e=[];if(void 0!==this.manipulator.merger){const n=this.manipulator.merger(t.getLatest(),s,i);e=n.changesRevoked;for(const e of n.changesToApply)t.applyChange(e)}else e=i;return e.length>0?{status:"failure",statusChanged:o,reason:"master has newer changes"}:{status:"success",statusChanged:o}}for(const e of i)t.applyChange(e)}return{status:"success",statusChanged:o}}onChangeResult(e,n,t){if("failure"===t.status)throw new Error("TwoWayStrategyMaster changes can not be rejected from "+e)}getMasterSyncerId(){return this.envId}isLocalChangeAllowed(){return!0}onResourceDisposed(e){const n=e.getSerializedId(),t=this.dependencies.get(n);if(t){for(const n of t)n.release(e);this.dependencies.delete(n)}}onDependencyChange(e,n){const t=Object.keys(n),r=this.getResourceDependenciesType();if(!t.find((e=>r.includes(e))))return{recomputedVal:[],recomputedStatus:[]};const o=[],i=[];for(const[t,r]of e.entries()){const e=this.dependencies.get(t);if(e){const a=(0,s.filterSet)(e,(e=>n[e.getType()]&&n[e.getType()].includes(e.getSerializedId())));if(a.size){const e=e=>{var n,o;const i=r.getType(),s=this.snaps.get(i);this.updateDependencies(r,e.dependencies);const c=0!==e.changes.length,l=r.setStatus(e.status);if(c){null===(n=s.get(t))||void 0===n||n.dispose();for(const n of e.changes)r.applyChange(n,!0);s.set(t,r.createSnapshot());for(const e of a){const n=e.getSerializedId(),t=this.dependencySnaps.get(r.getSerializedId()).get(e.getType());null===(o=t.get(n))||void 0===o||o.dispose(),t.set(n,e.createSnapshot())}}return{changedVal:c,changedStatus:l}},n=this.recomputeResource(r,a);try{if((0,s.isPromise)(n))n.then(e).catch((e=>{(0,s.reportResourceError)(r," recompute ",e),r.invalidate(e.message)}));else{const r=e(n);r.changedVal&&o.push(t),r.changedStatus&&i.push(t)}}catch(e){(0,s.reportResourceError)(r," recompute ",e),r.invalidate(e.message)}}}}return{recomputedVal:o,recomputedStatus:i}}onComputeBack(e){const n={value:e.getLatest(),dependencies:this.dependencies.get(e.getSerializedId())||new Set,status:{valid:!0}};try{const t=this.handler.recomputeBack(n,e,this.snaps.get(e.getType()).get(e.getSerializedId())),r=e.getSerializedId(),o=n=>{var t,o;const i=Object.keys(n);for(const e of i)for(const o of Object.keys(n[e])){const i=this.syncer.get(e,(0,a.deserializeId)(o));this.dependencySnaps.has(r)||this.dependencySnaps.set(r,new Map);const s=this.dependencySnaps.get(r);s.has(e)||s.set(e,new Map),null===(t=s.get(e).get(o))||void 0===t||t.dispose();for(const t of n[e][o])i.applyChange(t);s.get(e).set(o,i.createSnapshot())}null===(o=this.snaps.get(e.getType()).get(r))||void 0===o||o.dispose(),this.snaps.get(e.getType()).set(r,e.createSnapshot())};(0,s.isPromise)(t)?t.then(o).catch((n=>(0,s.reportResourceError)(e," compute-back ",n))):o(t)}catch(e){if("Recompute aborted"!==(null==e?void 0:e.message))throw e}return Array.from(n.dependencies).map((e=>({type:e.getType(),id:e.getId(),serializedId:e.getSerializedId()})))}recomputeResource(e,n){const t=e.getSerializedId(),r=this.dependencies.get(t);try{const o=this.handler.recompute(e,this.dependencySnaps.get(t),n,r);return(0,s.isPromise)(o)?o.catch((n=>((0,s.reportResourceError)(e," recompute ",n),{changes:[],status:{valid:!1,message:n.message},dependencies:r}))):o}catch(n){return(0,s.reportResourceError)(e," recompute ",n),{changes:[],status:{valid:!1,message:n.message},dependencies:r}}}updateDependencies(e,n){const t=this.dependencies.get(e.getSerializedId());if(t!==n){if(this.dependencies.set(e.getSerializedId(),n),t)for(const r of t)n.has(r)||r.release(e);for(const r of n)t&&t.has(r)||r.use(e)}}safeCompute(e,n){const t=this.dependencies.get(n.getSerializedId())||new Set;try{const r=this.handler.compute(e,n);return(0,s.isPromise)(r)?r.catch((e=>((0,s.reportResourceError)(n," safe compute ",e),{value:void 0,status:{valid:!1,message:e.message},dependencies:t}))):r}catch(e){return(0,s.reportResourceError)(n," safe compute ",e),{value:void 0,status:{valid:!1,message:e.message},dependencies:t}}}}n.TwoWayComputedStrategyMaster=c;class l{constructor(e,n,t,r,o,i,s){this.resourceClass=e,this.masterId=n,this.type=t,this.batcher=r,this.manipulator=o,this.subscribeToRemote=i,this.logger=s}createResource(e){const{promise:n,resolve:t,reject:r}=(0,i.deferred)(),o=new this.resourceClass(e,{batcher:this.batcher,provider:{provide:async()=>n},manipulator:this.manipulator,resourceType:this.type});return this.subscribeToRemote(this.masterId,o).then((e=>{t(e)})).catch((e=>{r(e)})),o}getManipulator(){return this.manipulator}remoteInitializeResource(e,n){return new this.resourceClass(e,{batcher:this.batcher,provider:{provide:()=>n},manipulator:this.manipulator,resourceType:this.type})}onRemoteChanges(e,n,t,o){if(e!==this.masterId)throw new Error("messages from unknown syncer");const i=!!n.newStatus&&t.setStatus(n.newStatus);if(!t.isReady())return{status:"failure",statusChanged:i,reason:"Resource slave is not ready"};const{changes:s}=n;if(s){const n=o.connections[e],i=t.getChangesFromVersion(n.approvedSnap),a=[...s];if(s.length&&!(0,r.isFullChange)(s[0]))for(const e of t.getInvertingChangesFromVersion(n.approvedSnap))a.unshift(e);for(const e of a)t.applyChange(e,!0);const c=[...s];let l=[];if(0!==i.length){if(void 0!==this.manipulator.merger){const e=this.manipulator.merger(t.getLatest(),c,i);l=e.changesRevoked;for(const n of e.changesToApply)t.applyChange(n,!0)}else l=s;l.length>0&&this.logger.warn({value:"changes rejected because of new change from master",metadata:{changesFromMaster:s,changesRevoked:l}})}}return{status:"success",statusChanged:i}}isLocalChangeAllowed(){return!0}getMasterSyncerId(){return this.masterId}}n.TwoWayComputedStrategySlave=l,n.TwoWayComputedStrategy=function(e){return(n,t,r,i)=>{const s=e.customResourceClass||o.Resource,a="string"==typeof e.sourceEnv?e.sourceEnv:e.sourceEnv.env;return t.id===a?new c(s,a,n,r,t,e.manipulator,e.dependencies.map((e=>e.getTypeName())),e.handler):new l(s,a,n,r,e.manipulator,t.subscribeToRemote,i)}}},72288:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.TwoWayStrategy=n.TwoWayStrategySlave=n.TwoWayStrategyMaster=void 0;const r=t(98522),o=t(14572),i=t(48074),s=t(76893);class a{constructor(e,n,t,r,o,i){this.resourceClass=e,this.envId=n,this.type=t,this.batcher=r,this.manipulator=o,this.provider=i}getManipulator(){return this.manipulator}createResource(e){return new this.resourceClass(e,{batcher:this.batcher,provider:this.provider,manipulator:this.manipulator,resourceType:this.type})}remoteInitializeResource(){throw new Error(" two way startegy master cannot be remote initialized")}getValueFromHandler(e,n){try{return this.provider.provide(e,n)}catch(e){return(0,s.reportResourceError)(n," invalidate ",e),{value:void 0,status:{valid:!1,message:e.message}}}}onRemoteChanges(e,n,t,r){const o=!!n.newStatus&&t.setStatus(n.newStatus),{changes:i}=n,s=r.connections[e];if(i&&s){const e=t.getChangesFromVersion(s.approvedSnap);if(e.length>0){let n=[];if(void 0!==this.manipulator.merger){const r=this.manipulator.merger(t.getLatest(),e,i);n=r.changesRevoked;for(const e of r.changesToApply)t.applyChange(e)}else n=i;return n.length>0?{status:"failure",statusChanged:o,reason:"master has newer changes"}:{status:"success",statusChanged:o}}for(const e of i)t.applyChange(e)}return{status:"success",statusChanged:o}}onChangeResult(e,n,t){if("failure"===t.status)throw new Error("TwoWayStrategyMaster changes can not be rejected from "+e)}getMasterSyncerId(){return this.envId}isLocalChangeAllowed(){return!0}}n.TwoWayStrategyMaster=a;class c{constructor(e,n,t,r,o,i,s){this.resourceClass=e,this.masterId=n,this.type=t,this.batcher=r,this.manipulator=o,this.subscribeToRemote=i,this.logger=s}createResource(e){const{promise:n,resolve:t,reject:r}=(0,i.deferred)(),o=new this.resourceClass(e,{batcher:this.batcher,provider:{provide:async()=>n},manipulator:this.manipulator,resourceType:this.type});return this.subscribeToRemote(this.masterId,o).then((e=>{t(e)})).catch((e=>{r(e)})),o}getManipulator(){return this.manipulator}remoteInitializeResource(e,n){return new this.resourceClass(e,{batcher:this.batcher,provider:{provide:()=>n},manipulator:this.manipulator,resourceType:this.type})}onRemoteChanges(e,n,t,o){if(e!==this.masterId)throw new Error("messages from unknown syncer");const i=!!n.newStatus&&t.setStatus(n.newStatus);if(!t.isReady())return{status:"failure",statusChanged:i,reason:"Resource slave is not ready"};const{changes:s}=n;if(s){const n=o.connections[e],i=t.getChangesFromVersion(n.approvedSnap),a=[...s];if(s.length&&!(0,r.isFullChange)(s[0]))for(const e of t.getInvertingChangesFromVersion(n.approvedSnap))a.unshift(e);for(const e of a)t.applyChange(e,!0);const c=[...s];let l=[];if(0!==i.length){if(void 0!==this.manipulator.merger){const e=this.manipulator.merger(t.getLatest(),c,i);l=e.changesRevoked;for(const n of e.changesToApply)t.applyChange(n,!0)}else l=s;l.length>0&&this.logger.warn({value:"changes rejected because of new change from master",metadata:{changesFromMaster:s,changesRevoked:l}})}}return{status:"success",statusChanged:i}}isLocalChangeAllowed(){return!0}getMasterSyncerId(){return this.masterId}}n.TwoWayStrategySlave=c,n.TwoWayStrategy=function(e){return(n,t,r,i)=>{const s=e.customResourceClass||o.Resource,l="string"==typeof e.sourceEnv?e.sourceEnv:e.sourceEnv.env;return t.id===l?new a(s,l,n,r,e.manipulator,e.handler):new c(s,l,n,r,e.manipulator,t.subscribeToRemote,i)}}},42580:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.withDefaultPendingSyncerInfo=n.createSyncerInfo=n.pendingSyncerMessageTypes=void 0,n.pendingSyncerMessageTypes=["pendingChanges","pendingStatusChanges","openRequests","openRequestsResult","changesResult","pushOpenRequests","closeRequests","disconnectSyncers"],n.createSyncerInfo=function(e,n){return{syncer:e,isPending:n,changesResult:{},closeRequests:{},openRequests:{},openRequestsResult:{},pendingChanges:{},pendingStatusChanges:{},pushOpenRequests:{},disconnectSyncers:[]}},n.withDefaultPendingSyncerInfo=e=>{for(const t of n.pendingSyncerMessageTypes)"disconnectSyncers"===t?e[t]||(e[t]=[]):e[t]||(e[t]={});return e}},84488:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.mergeChangeSets=n.mergeIdList=n.cloneIdList=n.resourceMapToIdList=n.mergeResourceMaps=n.resourceSetToList=void 0,n.resourceSetToList=function(e){return Object.keys(e).reduce(((n,t)=>(n[t]=[...e[t]],n)),{})},n.mergeResourceMaps=function(e,...n){const t={};for(const r of n)Object.keys(r).reduce(((n,t)=>(n[t]=Object.keys(r[t]).reduce(((n,o)=>(void 0!==n[o]?n[o]=e(n[o],r[t][o],o):n[o]=r[t][o],n)),n[t]||{}),n)),t);return t},n.resourceMapToIdList=function(e,n=(()=>!0)){const t={};for(const r of Object.keys(e)){const o=e[r],i=Object.keys(o),s=t[r]||(t[r]=[]);for(const e of i)n(o[e])&&s.push(e)}return t},n.cloneIdList=function(e){const n={};for(const t in e)n[t]=[...e[t]];return n},n.mergeIdList=function(e,n){const t={},r=[...new Set(Object.keys(e).concat(Object.keys(n)))];for(const o of r)t[o]=e[o]&&n[o]?[...new Set([...e[o],...n[o]])]:e[o]?e[o]:n[o];return t},n.mergeChangeSets=function(e,n){for(const t of Object.keys(n))if(e[t]){const r=e[t],o=n[t];for(const e of o)r.add(e)}else e[t]=n[t]}},68537:(e,n,t)=>{"use strict";var r;Object.defineProperty(n,"__esModule",{value:!0}),n.ResourceSyncer=void 0;const o=t(42580),i=t(48074),s=t(93849),a=t(86307),c=t(84488),l=t(91570);n.ResourceSyncer=class{constructor(e,n,t,o){this.id=e,this.batcher=n,this.loggerService=o,this[r]={messageFromRemote:(0,s.multiTenantMethod)(this.messageFromRemote)},this.syncers=new Map,this.resources=new Map,this.preDisposalChanges=new Map,this.resourceRemotePromise=new Map,this.rTypesOrder=[],this.resourceConfigs={},this.isCollectingMessages=!1,this.connectionListeners=new Set,this.registrationListeners=new Set,this.subscribeToRemote=(e,n)=>{const t=this.syncers.get(e),r=n.getType(),o=n.getSerializedId();if(!t)throw new Error(`unknown syncer cannot connect to ${e}, resource type: ${r}`);this.linkResourceToMasterSyncer(e,r,o,n),this.hasCollectedCloseRequestWith(t,r,o)&&t.closeRequests[r].delete(o);const s=this.resourceRemotePromise.get(r);return s.set(o,(0,i.deferred)()),this.updateSyncer(e,{openRequests:{[r]:new Set([o])}}),s.get(o).promise},this.onBatchChange=e=>{e.batchId!==this.runningBatch&&this.reactToLocalChanges(e.changed,e.changedStatus)},this.disposeResource=e=>{var n,t,r;const o=e.getType(),i=e.getSerializedId(),s=this.resourceConfigs[o].resourceManager.getMasterSyncerId(),a=null===(n=this.resources.get(o))||void 0===n?void 0:n.get(i);if(a)for(const n of Object.keys(a.connections)){const t=e.getChangesFromVersion(a.connections[n].snap);this.preDisposalChanges.has(n)||this.preDisposalChanges.set(n,new Map),this.preDisposalChanges.get(n).has(o)||this.preDisposalChanges.get(n).set(o,new Map),this.preDisposalChanges.get(n).get(o).has(i)||this.preDisposalChanges.get(n).get(o).set(i,[]);const r=this.preDisposalChanges.get(n).get(o);r.set(i,r.get(i).concat(t))}null===(t=this.resources.get(o))||void 0===t||t.delete(i);const c=e.results;if(void 0!==c)for(const e of c){const n=e.getSerializedId(),t=e.getType(),o=null===(r=this.resources.get(t))||void 0===r?void 0:r.get(n);o&&e.release(o.connections[s])}s!==this.id&&this.updateSyncer(s,{closeRequests:{[o]:new Set([i])}})};for(const e of Object.keys(t))this.registerResourceType(e,t[e]);n.subscribe(this.onBatchChange)}hasSyncer(e){return this.syncers.has(e)}getRegisteredEnvs(){return[...this.syncers.keys()]}getRegisteredResourceManagers(){return Object.values(this.resourceConfigs).map((e=>e.resourceManager))}addConnectionListener(e){this.connectionListeners.add(e)}removeConnectionListener(e){this.connectionListeners.delete(e)}addRegistartionListener(e){this.registrationListeners.add(e)}removeRegistrationListener(e){this.registrationListeners.delete(e)}registerResourceType(e,n){this.resourceConfigs[e]=n,this.insertInOrder(e,n),this.resources.set(e,new Map),this.resourceRemotePromise.set(e,new Map),n.resourceManager.subscribeToOpen(((e,t)=>{const r=n.resourceManager.getOpen();for(const e of t)r.includes(e)&&this.disposeResource(n.resourceManager.getResource((0,a.deserializeId)(e)))})),this.registrationListeners.forEach((e=>e()))}insertInOrder(e,n){const t=this.rTypesOrder.findIndex((e=>this.resourceConfigs[e].dependenciesBaseTypeName&&this.resourceConfigs[e].dependenciesBaseTypeName.includes(n.baseTypeName)));-1==t?this.rTypesOrder.push(e):this.rTypesOrder.splice(t,0,e)}addResourceDependency(e,n){const t=e.getTypeName(),r=this.resourceConfigs[t];if(!r)throw new Error("Cannot add dependency to unknown ResourceManager");r.dependenciesBaseTypeName.push(n.baseTypeName),this.rTypesOrder.splice(this.rTypesOrder.indexOf(t),1),this.insertInOrder(t,r)}connectSyncer(e,n){this.syncers.has(e)||(this.syncers.set(e,(0,o.createSyncerInfo)(n,!1)),this.connectionListeners.forEach((e=>e())))}disconnectSyncer(e){if(this.syncers.has(e)){for(const[n,t]of this.resources.entries())for(const r of t.keys())this.remoteDisposeRequest(e,n,r);this.syncers.delete(e),this.connectionListeners.forEach((e=>e()))}}get(e,n,t){if(!this.resourceConfigs[e])throw new Error("unknown resource type "+e);return this.resourceConfigs[e].resourceManager.get(n,t)}async getReady(e,n,t){const r=this.get(e,n,t);return await r.ready,r}getOpenResources(e){if(!this.resourceConfigs[e])throw new Error("unknown resource type "+e);return this.resourceConfigs[e].resourceManager.getOpen()}isOpen(e,n){if(!this.resourceConfigs[e])throw new Error("unknown resource type "+e);return this.resourceConfigs[e].resourceManager.isOpen(n)}async isRemoteOpen(e,n,t){const r=this.syncers.get(t);if(!r)throw new Error(`unknown syncer cannot query open, syncerId:${t}, resource type: ${e}`);return await r.syncer.isOpen(e,n)}hasCollectedCloseRequestWith(e,n,t){var r;return(this.isCollectingMessages||e.isPending)&&(null===(r=e.closeRequests[n])||void 0===r?void 0:r.has(t))}messageFromRemote(e,n,{closeRequests:t,openRequests:r,openRequestsResults:o,changeRequests:i,changesResult:s,pushOpenRequests:d}){this.loggerService.info({value:`message from ${e} to ${this.id}`,metadata:{closeRequests:t,openRequests:r,openRequestsResults:o,changeRequests:i,changesResult:s,pushOpenRequests:d}});let u=!1;const p={},h={},f=(0,c.resourceMapToIdList)(i,(e=>!!e.changes)),m=(0,c.resourceMapToIdList)(i,(e=>!!e.newStatus));this.runningBatch=Math.random(),this.startCollectingMessages();const g=this.batcher.batchAll((()=>{var n,t;for(const n of this.rTypesOrder){for(const t of r[n]||[])this.remoteResourceRequest(e,n,t).catch(l.reportError);for(const t of Object.keys(o[n]||[]))this.remoteResourceResponse(e,n,t,o[n][t]);for(const t of Object.keys(d[n]||[]))this.remotePushOpen(e,n,t,d[n][t]);const t=s[n];t&&this.remoteChangeResult(e,n,t);const a=i[n];if(a){this.remoteChangeRequest(e,n,a);for(const n of Object.keys(a)){const{changes:t}=a[n];if(t)for(const n of t){const t=n.removed;if(void 0!==t)for(const n of t)this.get(n.type,n.id).release(this.resources.get(n.type).get(n.serializedId).connections[e])}}}}let g=this.rTypesOrder.length;for(;g--;){const e=this.rTypesOrder[g],r=this.resourceConfigs[e];if(!r.resourceManager.hasComputeBack())continue;const o=[...f[e]||[],...p[e]||[]];for(const s of o)try{const e=r.resourceManager.onComputeBack(r.resourceManager.get((0,a.deserializeId)(s)));for(const{type:n,serializedId:t}of e)u=!0,f[n]||(f[n]=[]),p[n]||(p[n]=[]),f[n].push(t),p[n].push(t)}catch(o){(0,l.reportError)(o);const c=r.resourceManager.getResource((0,a.deserializeId)(s)),d=(null===(t=null===(n=i[e])||void 0===n?void 0:n[s])||void 0===t?void 0:t.changes)||[];c.revertChanges(d)&&this.updateSyncersAfterChanges({[e]:[s]},{})}}const y=(0,c.mergeIdList)(f,m);if(Object.keys(y).length)for(const e of this.rTypesOrder){const n=this.resourceConfigs[e],{recomputedVal:t,recomputedStatus:r}=n.resourceManager.onDependencyChange(y);t.length&&(u=!0,this.updateNewlyComputed(p,y,e,t)),r.length&&(u=!0,this.updateNewlyComputed(h,y,e,r)),this.callManagerSubscribers(y[e],n)}}),this.runningBatch);for(const n of this.rTypesOrder)for(const r of t[n]||[])this.remoteDisposeRequest(e,n,r);if(this.runningBatch=void 0,"failure"===g.status)throw g.error;u?this.updateSyncersAfterChanges(p,h):this.releaseCollectedMessages()}startCollectingMessages(){this.isCollectingMessages=!0}releaseCollectedMessages(){this.isCollectingMessages=!1;for(const[e,n]of this.syncers.entries())n.isPending||this.updateSyncerIfPending(e)}reactToLocalChanges(e,n){this.runningBatch=Math.random();const t=(0,c.cloneIdList)(e),r=(0,c.cloneIdList)(n),o=this.batcher.batchAll((()=>{let e=this.rTypesOrder.length;for(;e--;){const n=this.rTypesOrder[e],r=this.resourceConfigs[n];if(t[n]&&r.resourceManager.hasComputeBack())for(const e of t[n]){const n=r.resourceManager.onComputeBack(r.resourceManager.get((0,a.deserializeId)(e)));for(const e of n)t[e.type]||(t[e.type]=[]),t[e.type].push(e.serializedId)}}const n=(0,c.mergeIdList)(t,r);for(const e of this.rTypesOrder){const o=this.resourceConfigs[e],{recomputedVal:i,recomputedStatus:s}=o.resourceManager.onDependencyChange(n);i.length&&this.updateNewlyComputed(n,t,e,i),s.length&&this.updateNewlyComputed(n,r,e,s),this.callManagerSubscribers(n[e],o)}}),this.runningBatch);if("failure"===o.status)throw o.error;this.updateSyncersAfterChanges({...o.changed,...t},{...o.changedStatus,...r}),this.runningBatch=void 0}updateNewlyComputed(e,n,t,r){e[t]=(e[t]||[]).concat(r),n[t]=n[t]?n[t].concat(r):r}callManagerSubscribers(e,n){(null==e?void 0:e.length)&&n.resourceManager.dispatchChanges(e)}linkResourceToSlaveSyncer(e,n,t,r){const o=this.resources.get(n);o.get(t)||o.set(t,{connections:{}});const i=o.get(t);if(!i.connections[e]){const n={snap:r.createSnapshot(),approvedSnap:r.createSnapshot(),toMaster:!1,resource:r};r.use(n),i.connections[e]=n}return r}linkResourceToMasterSyncer(e,n,t,r){const o=this.resources.get(n);o.get(t)||o.set(t,{connections:{}});const i=o.get(t);return i.connections[e]||(i.connections[e]={snap:r.createSnapshot(),approvedSnap:r.createSnapshot(),toMaster:!1}),r}async remoteResourceRequest(e,n,t){if(!this.syncers.has(e))throw new Error(`unknown syncer cannot connect to ${e}`);const r=this.get(n,(0,a.deserializeId)(t));let o;this.linkResourceToSlaveSyncer(e,n,t,r);try{await r.ready,o={status:"success",result:{value:r.getLatest(),status:r.getStatus()}}}catch(e){o={status:"failure",reason:e&&e.message?e.message:e.toString()}}this.updateSyncer(e,{openRequestsResult:{[n]:{[t]:o}},pushOpenRequests:this.getDependenciesToUpdate(r,e)})}getDependenciesToUpdate(e,n){var t;const r=e.getType(),o=this.resourceConfigs[r];if(o.resourceManager.hasDependenciesToSync()){const r={};for(const i of o.resourceManager.dependenciesToSync(e)){const e=i.getType(),o=i.getSerializedId(),s=null===(t=this.resources.get(e))||void 0===t?void 0:t.get(o);if(!s||!s.connections[n]){r[e]||(r[e]={});const t={result:{value:i.getLatest(),status:i.getStatus()}};r[e][o]=t,this.linkResourceToSlaveSyncer(n,e,o,i)}}return r}}remoteResourceResponse(e,n,t,r){var o;const i=null===(o=this.resourceRemotePromise.get(n))||void 0===o?void 0:o.get(t);i&&("success"===r.status?i.resolve(r.result):i.reject(r.reason),this.resourceRemotePromise.get(n).delete(t))}remotePushOpen(e,n,t,r){const o=this.resourceConfigs[n];if(!o.resourceManager.isOpen(t)){const i=o.resourceManager.remoteInitializeResource((0,a.deserializeId)(t),r.result);this.linkResourceToMasterSyncer(e,n,t,i),i.use(this.resources.get(n).get(t).connections[e])}}remoteChangeResult(e,n,t){var r;const o=Object.keys(t),i=this.resourceConfigs[n];for(const s of o){const o=null===(r=this.resources.get(n))||void 0===r?void 0:r.get(s);if(!o)continue;const c=i.resourceManager.getResource((0,a.deserializeId)(s)),l=o.connections[e];l&&("success"===t[s].status?l.pendingApproval&&(l.approvedSnap.dispose(),l.approvedSnap=l.pendingApproval,l.pendingApproval=void 0):(l.snap=this.renewSnap(c,l.snap),l.approvedSnap=this.renewSnap(c,l.approvedSnap)))}}remoteChangeRequest(e,n,t){var r;const o=Object.keys(t),i=this.resourceConfigs[n],s={},c={};for(const l of o){const o=null===(r=this.resources.get(n))||void 0===r?void 0:r.get(l);if(!o)continue;const d=i.resourceManager.getResource((0,a.deserializeId)(l)),u=i.resourceManager.onRemoteChanges(e,t[l],d,o),p=!!t[l].newStatus&&!t[l].changes;if(p&&!u.statusChanged)continue;s[l]=u;const h=o.connections[e];h&&(h.snap=this.renewSnap(d,h.snap),h.approvedSnap=this.renewSnap(d,h.approvedSnap));for(const n of Object.keys(o.connections))n!==e&&(c[n]||(c[n]={pendingChanges:new Set,pendingStatusChanges:new Set}),p?c[n].pendingStatusChanges.add(l):c[n].pendingChanges.add(l))}this.updateSyncer(e,{changesResult:{[n]:s}});for(const e of Object.keys(c))this.updateSyncer(e,{pendingChanges:{[n]:c[e].pendingChanges},pendingStatusChanges:{[n]:c[e].pendingStatusChanges}})}renewSnap(e,n){return n.dispose(),e.createSnapshot()}remoteDisposeRequest(e,n,t){var r,o;if(!this.syncers.has(e))return void console.error(`unknown syncer cannot dispose: ${e} ${n} ${t}`);const i=null===(r=this.resources.get(n))||void 0===r?void 0:r.get(t);if(!i)return void console.error(`unknown resource cannot dispose: ${e} ${n} ${t}`);const s=i.connections[e];s&&(delete i.connections[e],null===(o=s.resource)||void 0===o||o.release(s),0===Object.values(i.connections).length&&this.resources.get(n).delete(t))}updateSyncersAfterChanges(e,n){var t,r;this.startCollectingMessages();const o={};for(const i of this.rTypesOrder){const s=e[i];if(null==s?void 0:s.length)for(const e of s){const n=null===(t=this.resources.get(i))||void 0===t?void 0:t.get(e);if(!n)continue;const r=this.resourceConfigs[i].resourceManager.getResource((0,a.deserializeId)(e));for(const e of Object.keys(n.connections)){o[e]=o[e]||{pendingChanges:{},pendingStatusChanges:{},pushOpenRequests:{}},o[e].pendingChanges[i]=new Set(s);const n=this.getDependenciesToUpdate(r,e);n&&(o[e].pushOpenRequests=(0,c.mergeResourceMaps)(((e,n)=>n),o[e].pushOpenRequests||{},n))}}const l=n[i];if(null==l?void 0:l.length)for(const e of l){const n=null===(r=this.resources.get(i))||void 0===r?void 0:r.get(e);if(n)for(const e of Object.keys(n.connections))o[e]=o[e]||{pendingChanges:{},pendingStatusChanges:{},pushOpenRequests:{}},o[e].pendingStatusChanges[i]=new Set(l)}}for(const e of Object.keys(o))this.updateSyncer(e,o[e]);this.releaseCollectedMessages()}updateSyncerIfPending(e){const n=this.syncers.get(e);if(!n)return;let t=!1;const r={};for(const e of o.pendingSyncerMessageTypes)Object.keys(n[e]).length&&(t=!0,r[e]=n[e]);t&&this.updateSyncer(e,r)}updateSyncer(e,n){var t,r,i;const s=this.syncers.get(e);if(!s)return;if(this.isCollectingMessages||s.isPending){for(const e in n)"pendingChanges"===e||"pendingStatusChanges"===e||"openRequests"===e||"closeRequests"===e?n[e]&&(0,c.mergeChangeSets)(s[e],n[e]):"openRequestsResult"!==e&&"changesResult"!==e||(s[e]=(0,c.mergeResourceMaps)(((e,n)=>n),s[e],n[e]));return void(n.pushOpenRequests&&(s.pushOpenRequests=(0,c.mergeResourceMaps)(((e,n)=>n),s.pushOpenRequests,n.pushOpenRequests)))}const d=(0,o.withDefaultPendingSyncerInfo)(n),u=(0,o.createSyncerInfo)(s.syncer,s.isPending);this.syncers.set(e,u);const p={},h=d.pendingChanges;for(const n of Object.keys(h)){const o=this.resourceConfigs[n];if(o.resourceManager.isLocalChangeAllowed()){p[n]={};for(const r of[...h[n]]){p[n][r]={};const i=null===(t=this.resources.get(n))||void 0===t?void 0:t.get(r);if(i){const t=o.resourceManager.getResource((0,a.deserializeId)(r)),s=i.connections[e];if(s){const e=t.getChangesFromVersion(s.snap);p[n][r].changes=e;const o=t.getManipulator().squasher;void 0!==o&&e.length>1&&(p[n][r].changes=o(e))}}else{const t=this.preDisposalChanges.get(e);if(t){let e=t.get(n).get(r);t.set(n,new Map);const i=o.manipulator.squasher;void 0!==i&&e.length>1&&(e=i(e)),p[n][r].changes=e}}}for(const t of Object.keys(p[n])){const i=null===(r=this.resources.get(n))||void 0===r?void 0:r.get(t);if(!i)continue;const s=o.resourceManager.getResource((0,a.deserializeId)(t)),c=i.connections[e];c&&(c.snap=s.createSnapshot(),c.pendingApproval=s.createSnapshot())}}}const f=d.pendingStatusChanges;for(const e of Object.keys(f)){const n=this.resourceConfigs[e];for(const t of[...f[e]]){const r=n.resourceManager.getResource((0,a.deserializeId)(t));r&&(p[e]||(p[e]={}),(i=p[e])[t]||(i[t]={}),p[e][t].newStatus=r.getStatus())}}let m=!0;if(Object.keys(p).length&&(m=!1),m)for(const e of o.pendingSyncerMessageTypes)if(Object.keys(d[e]).length){m=!1;break}if(m)return u.isPending=!1,void this.updateSyncerIfPending(e);u.isPending=!0,u.syncer.messageFromRemote(this.id,{changeRequests:p,closeRequests:(0,c.resourceSetToList)(d.closeRequests),openRequests:(0,c.resourceSetToList)(d.openRequests),openRequestsResults:d.openRequestsResult,changesResult:d.changesResult,pushOpenRequests:d.pushOpenRequests}).finally((()=>{u.isPending=!1,this.updateSyncerIfPending(e)})).catch(l.reportError)}},r=s.SERVICE_CONFIG},98522:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.fullChange=n.isFullChange=n.FIRST_VERSION=n.NOT_INITED=void 0,n.NOT_INITED=-1,n.FIRST_VERSION=0,n.isFullChange=function(e){return"full"===e.kind},n.fullChange=e=>({kind:"full",value:e})},76893:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.modifyUtils=n.getResourceLatestValueFactory=n.rampArray=n.getDefaultStatusHandling=n.calculateDependantResourceStatus=n.fullChangeManipulator=n.filterSet=n.sortByArr=n.isFunction=n.isPromise=n.nonReadyResourceError=n.invalidResourceError=n.disposedNonReadyResourceError=n.disposedResourceError=n.unknownResourceError=n.unknownVersionError=n.reportResourceError=void 0;const r=t(91570),o=t(86307);function i(e,n){return function(e){for(const n of e)if(!1===n.getStatus().valid)return!0;return!1}(n)?{valid:!1,message:`One of the dependencies of ${e} is invalid`}:{valid:!0}}function s(e,n,t){return n.length>1&&(t=s(e[n[0]],n.slice(1),t)),t===e[n[0]]?e:Array.isArray(e)?[...e.slice(0,n[0]-1),t,...e.slice(n[0]+1)]:{...e,[n[0]]:t}}n.reportResourceError=function(e,n,t){var o;const i=new Error(null!==(o="error running "+n+" on resource of type: "+e.getType()+" with id: "+JSON.stringify(e.getId(),null,4)+" original err: "+t.stack)&&void 0!==o?o:t.message);(0,r.reportError)(i)},n.unknownVersionError=function(e,n,t){return new Error(`unknown version '${e}' for resource '${n}'. latest is ${t}.`)},n.unknownResourceError=function(e,n){return new Error(`uninitialized resource with type '${e}' and id '${n}'. try waiting for the resource to be ready.`)},n.disposedResourceError=function(e,n){return new Error(`resource  with type '${e}' and id '${n}' has been disposed`)},n.disposedNonReadyResourceError=function(e,n){return new Error(`resource  with type '${e}' and id '${n}' is not ready and already been disposed`)},n.invalidResourceError=function(e,n,t){return new Error(`resource  with type '${e}' and id '${n}' is in invalid state: ${t}`)},n.nonReadyResourceError=function(e,n){return new Error(`resource  with type '${e}' and id '${n}' is not ready`)},n.isPromise=function(e){return e&&"function"==typeof e.then},n.isFunction=function(e){return e&&"[object Function]"==={}.toString.call(e)},n.sortByArr=function(e,n){const t=n.reduce(((e,n,t)=>(e.set(n,t),e)),new Map);return e.sort(((e,n)=>(t.get(e)||0)-(t.get(n)||0)))},n.filterSet=function(e,n){const t=new Set;for(const r of e)n(r)&&t.add(r);return t},n.fullChangeManipulator={reducer:(e,n)=>({value:n.value,invertingChanges:[{kind:n.kind,value:e}]})},n.calculateDependantResourceStatus=function(e,n,t){return void 0===t||t.valid?i(e,n):t},n.getDefaultStatusHandling=i,n.rampArray=function(e){const n=new Array(e);for(let t=0;t<e;t++)n[t]=t;return n},n.getResourceLatestValueFactory=function(e){const n={},t=new Set;return{getResourceLatestValue:async r=>{const i=(0,o.serializeId)(r);return t.add(i),(await e.getReady(r,n)).getLatest()},release:()=>{t.forEach((t=>{const r=(0,o.deserializeId)(t);e.isOpen(r)&&e.get(r).release(n)})),t.clear()}}},n.modifyUtils={replace:s,remove:function e(n,t){if(t.length>1){const r=e(n[t[0]],t.slice(1));return r===n[t[0]]?n:s(n,[t[0]],r)}if(Array.isArray(n))return[...n.slice(0,t[0]-1),...n.slice(t[0]+1)];const r={...n};return delete r[t[0]],r},add:function e(n,t,r){return t.length>1?(r=e(n[t[0]],t.slice(1),r),s(n,[t[0]],r)):r===n[t[0]]?n:Array.isArray(n)?-1===t[0]?[...n,r]:[...n.slice(0,t[0]),r,...n.slice(t[0])]:{...n,[t[0]]:r}}}},32510:(e,n,t)=>{e.exports=t(40934)},60814:(e,n,t)=>{e.exports=t(73858)},48541:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;const r=t(5163);r.__exportStar(t(17831),n);var o=t(17831);Object.defineProperty(n,"default",{enumerable:!0,get:function(){return r.__importDefault(o).default}})},17831:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163),o=t(93849),i=t(32510),s=r.__importStar(t(2206)),a=r.__importDefault(t(89111)),c=t(5689),l=t(46726),d=(0,i.defineTwoWayComputedResource)().defineEntity(s.processingEnv),u=(0,i.defineOneWayResource)().defineEntity(s.processingEnv),p=(0,i.defineComputedResource)().defineEntity(s.processingEnv);n.default=new o.Feature({id:"simpleAST",dependencies:[s.default.asDependency,a.default.asDependency,o.COM.asDependency],api:{idService:o.Service.withType().defineEntity(s.processingEnv),idServiceMapping:o.Service.withType().defineEntity(s.processingEnv),remoteIdService:o.Service.withType().defineEntity(s.processingEnv).allowRemoteAccess(),codeService:o.Service.withType().defineEntity(s.processingEnv).allowRemoteAccess(),sourceIdResource:p,sourceIdResourceMain:p.defineConsumer(c.mainEnv),idGenerator:o.Service.withType().defineEntity(o.Universal),simpleASTPlugin:o.Slot.withType().defineEntity(o.Universal),languagePlugin:o.Slot.withType().defineEntity(s.processingEnv),languageASTPlugin:o.Slot.withType().defineEntity(s.processingEnv),languageASTFallbackPlugin:o.Slot.withType().defineEntity(s.processingEnv),languageASTPassthroughPlugin:o.Slot.withType().defineEntity(s.processingEnv),simpleAST:d,simpleASTMain:d.defineConsumer(c.mainEnv),simpleASTPluginRepo:o.Service.withType().defineEntity(o.Universal),astVisualizer:o.Slot.withType().defineEntity(c.mainEnv),simpleASTDiagnostics:u,simpleASTDiagnosticsMain:u.defineConsumer(c.mainEnv),editSourceFile:o.Service.withType().defineEntity(s.processingEnv),codeFormatters:o.Slot.withType().defineEntity(s.processingEnv)}}).setup(o.Universal,(({simpleASTPlugin:e,simpleAST:n},{COM:t})=>{const r=new l.NodePluginRepo;e.stream((e=>{r.registerPlugin(e)})),l.commonSimpleAstParsers.forEach((n=>e.register(n)));const o=t.communication.getEnvironmentId(),i={};return{simpleASTPluginRepo:r,simpleAST:n,idGenerator:{generateId:e=>(i[e]||(i[e]=(0,l.createPrefixCounter)(o).nextId),i[e]())}}}))},5121:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.escapeDblQuoteHtml=n.escapeDblQuote=n.escapeSingleQuote=n.isValidIdentifierName=void 0,n.isValidIdentifierName=e=>!!e.length&&!/[^\d\w]/g.test(e),n.escapeSingleQuote=e=>e.replace(/\\/g,"\\\\").replace(/'/g,"\\'"),n.escapeDblQuote=e=>e.replace(/\\/g,"\\\\").replace(/"/g,'\\"'),n.escapeDblQuoteHtml=e=>e.replace(/&/g,"&amp;").replace(/"/g,"&quot;")},36738:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.commonSimpleAstParsers=void 0;const r=t(62764),o=t(84656),i=t(35949),s=t(48411),a=t(7688),c=t(10766),l=t(36161),d=t(8543),u=t(42143),p=t(87085);n.commonSimpleAstParsers=[i.filePlugin,o.variablePlugin,p.bindingElementPlugin,s.stringPlugin,s.numberPlugin,s.booleanPlugin,u.callPlugin,s.nullPlugin,s.undefinedPlugin,p.functionPlugin,r.arrayPlugin,a.objectPlugin,a.namedPropertyPlugin,a.computedPropertyNamePlugin,c.jsxPlugin,c.jsxPropPlugin,c.jsxTextPlugin,c.jsxExpressionPlugin,l.referencePlugin,d.propertyAccessPlugin,d.propertyAccessIndexPlugin,d.elementAccessIndexPlugin,p.templateStringPlugin,p.trinaryPlugin]},66867:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.copyNode=void 0;const r=t(85272);n.copyNode=function(e,n,t){let o=e;const i=t.getASTInfo(e);if(!i.idToNode.get(n.node.astNodeId))throw new Error(`child with id: ${n.node.astNodeId} not found`);const s=i.idToNode.get(n.newParentId);if(!s)throw new Error(`can't find new parent with id: ${n.newParentId}`);const a=(0,r.getModifier)(t,s.kind,"addChild")(s,{newChild:n.node,...n},t);return o=t.replaceNode(o,n.newParentId,a),o}},46726:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163);r.__exportStar(t(85136),n),r.__exportStar(t(87185),n),r.__exportStar(t(2807),n),r.__exportStar(t(85272),n),r.__exportStar(t(97094),n),r.__exportStar(t(87085),n),r.__exportStar(t(36738),n),r.__exportStar(t(15089),n),r.__exportStar(t(84169),n),r.__exportStar(t(36136),n),r.__exportStar(t(5121),n)},5786:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.moveNode=void 0;const r=t(87185);function o(e,n,t){const r=void 0!==n?e.getPlugin(n):void 0;if(!r)throw new Error(`no plugin for kind: ${n||"undefined"}`);return r.modifiers[t]}n.moveNode=function(e,n,t){let i=e;const s=t.getASTInfo(e),a=s.idToNode.get(n.node.astNodeId);if(!a)throw new Error(`child with id: ${n.node.astNodeId} not found`);const c=s.nodeToParent.get(a);if(!c)throw new Error(`can't find child with id: ${n.node.astNodeId}`);let l=c;if(l&&(0,r.isNodeOfKind)("jsx-prop",l)){const e=s.nodeToParent.get(c);if(!e)throw new Error("can't find property parent");l=e}const d=o(t,l.kind,"removeChild")(l,{childId:n.node.astNodeId,placeholderId:n.placeholderId,skipDispose:!0},t);i=t.replaceNode(i,l.astNodeId,d);const u=t.getASTInfo(i).idToNode.get(n.newParentId);if(!u)throw new Error(`can't find new parent with id: ${n.newParentId}`);const p=o(t,u.kind,"addChild")(u,{newChild:n.node,...n},t);return i=t.replaceNode(i,n.newParentId,p),i}},97094:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.NodePluginRepo=n.ScannedASTInfo=void 0;const r=t(84169);class o{constructor(e){this.idToNode=e.idToNode,this.nodeToParent=e.nodeToParent,this.root=e.root,this.kindToNodes=e.kindToNodes}byId(e){return this.idToNode.get(e)}byChild(e){return this.nodeToParent.get(e)}byKind(e){return this.kindToNodes.get(e)||[]}isChildOf(e,n){const t=this.nodeToParent.get(n);return!!t&&(t.astNodeId===e.astNodeId||this.isChildOf(e,t))}}n.ScannedASTInfo=o;const i=new WeakMap;n.NodePluginRepo=class{constructor(){this.plugins=new Map}registerPlugin(e){if(this.plugins.has(e.nodeKind))throw new Error("Could not register plugin. Plugin with the same node id already exist: "+e.nodeKind);this.plugins.set(e.nodeKind,e)}getPlugin(e){return this.plugins.get(e)}getChildren(e){const n=this.getPlugin(e.kind);return n&&n.getNodeChildren?n.getNodeChildren(e):[]}walkNodes(e,n){(0,r.walkProjectedNodes)(e,this.plugins,n)}transformNodes(e,n){let t=n(e);const r=this.plugins.get(e.kind);if(r&&r.getNodeChildren){const e=r.getNodeChildren(t);for(const o of e){const e=this.transformNodes(o,n);e!==o&&(t=r.replaceChild(t,o.astNodeId,e))}}return t}findNode(e,n){return(0,r.findNodeAndParents)(e,n,this.plugins)}replaceNode(e,n,t){return(0,r.replaceNode)(e,n,t,this.plugins)}getASTInfo(e){if(!i.has(e)){const n={idToNode:new Map,nodeToParent:new Map,kindToNodes:new Map,root:e};(0,r.walkProjectedNodes)(e,this.plugins,((e,t)=>(t&&n.nodeToParent.set(e,t),n.idToNode.set(e.astNodeId,e),n.kindToNodes.has(e.kind)||n.kindToNodes.set(e.kind,[]),n.kindToNodes.get(e.kind).push(e),!0))),i.set(e,new o(n))}return i.get(e)}getPlugins(){return this.plugins}}},26504:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163);r.__exportStar(t(62764),n),r.__exportStar(t(68029),n)},62764:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.arrayPlugin=n.arrayModifiers=void 0;const r=t(68029),o=t(87185),i=t(69521);n.arrayModifiers={removeChild:(e,{childId:t})=>n.arrayModifiers.removeElement(e,{elementId:t}),removeElement(e,{elementId:n}){const t=e.elements.filter((e=>e.astNodeId!==n));return(0,r.createArrayNode)({astNodeId:e.astNodeId,elements:t})},insertAtBeginning:(e,{value:n})=>(0,r.createArrayNode)({astNodeId:e.astNodeId,elements:[n,...e.elements]}),insertAtEnd:(e,{value:n})=>(0,r.createArrayNode)({astNodeId:e.astNodeId,elements:[...e.elements,n]}),addChild(e,t){if((0,o.isAddInsteadModArgs)(t))return n.arrayModifiers.setElement(e,{elementId:t.insteadOfChildId,value:t.node});if((0,o.isAddBeforeModArgs)(t))return t.beforeChildId?n.arrayModifiers.insertBefore(e,{targetId:t.beforeChildId,value:t.node}):n.arrayModifiers.insertAtEnd(e,{value:t.node});throw new Error("ArrayNode only supports add of kind add-instead or add-before")},insertBefore(e,{targetId:n,value:t}){const o=e.elements.flatMap((e=>e.astNodeId===n?[t,e]:[e]));return(0,r.createArrayNode)({astNodeId:e.astNodeId,elements:o})},insertAfter(e,{targetId:n,value:t}){const o=e.elements.flatMap((e=>e.astNodeId===n?[e,t]:[e]));return(0,r.createArrayNode)({astNodeId:e.astNodeId,elements:o})},setElement(e,{elementId:n,value:t}){const o=e.elements.map((e=>e.astNodeId===n?t:e));return(0,r.createArrayNode)({astNodeId:e.astNodeId,elements:o})},moveBefore(e,{elementId:n,targetId:t}){if(n===t)return e;const o=e.elements.find((e=>e.astNodeId===n));if(!o)throw new Error("element not found");const i=e.elements.filter((e=>e.astNodeId!==n)).flatMap((e=>e.astNodeId===t?[o,e]:[e]));if(i.length!==e.elements.length)throw new Error("target not found "+t);return(0,r.createArrayNode)({astNodeId:e.astNodeId,elements:i})},moveAfter(e,{elementId:n,targetId:t}){if(n===t)return e;const o=e.elements.find((e=>e.astNodeId===n));if(!o)throw new Error("element not found");const i=e.elements.filter((e=>e.astNodeId!==n)).flatMap((e=>e.astNodeId===t?[e,o]:[e]));if(i.length!==e.elements.length)throw new Error("target not found "+t);return(0,r.createArrayNode)({astNodeId:e.astNodeId,elements:i})}},n.arrayPlugin=(0,o.packPlugin)()({kind:"array",modifiers:n.arrayModifiers,getNodeChildren:e=>e.elements,replaceChild:(e,n,t)=>{const r=(0,i.replaceInArr)(e.elements,n,t);if("success"!==r.status)throw new Error("replace properties in object, "+r.status);return{...e,elements:r.arr}},createBlank:e=>(0,r.createArrayNode)({astNodeId:e(),elements:[]})})},68029:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.isArrayNode=n.createArrayNode=void 0;const r=t(87185);n.createArrayNode=function(e){return{kind:"array",elements:[],...e}},n.isArrayNode=e=>!!e&&(0,r.isNodeOfKind)("array",e)},62325:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163);r.__exportStar(t(67397),n),r.__exportStar(t(31995),n)},67397:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.bindingElementPlugin=void 0;const r=t(87185),o=t(77949),i=t(31995);n.bindingElementPlugin=(0,r.packPlugin)()({kind:"binding-element",modifiers:{},createBlank:e=>(0,i.createBindingElementNode)({astNodeId:e(),name:"bindingElement",initializer:(0,o.createNullNode)({astNodeId:e()})}),getNodeChildren:e=>[e.initializer],replaceChild:(e,n,t)=>{if(e.initializer.astNodeId===n)return{...e,initializer:t};throw new Error("unknown child")}})},31995:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.isBindingElementNode=n.createBindingElementNode=void 0;const r=t(87185);n.createBindingElementNode=function(e){return{kind:"binding-element",...e}},n.isBindingElementNode=function(e){return!!e&&(0,r.isNodeOfKind)("binding-element",e)}},42143:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163);r.__exportStar(t(67695),n),r.__exportStar(t(42048),n)},67695:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.callPlugin=n.callModifiers=void 0;const r=t(85272),o=t(42048),i=t(87185),s=t(94654);n.callModifiers={removeArg(e,{argId:n}){const t=(0,r.removeFromArr)(e.args,n);if("not found"===t.status)throw new Error("argument not found");return{...e,args:t.arr}},addArg(e,{arg:n,beforeArg:t}){if(t){const o=(0,r.findIdxByID)(e.args,t);if(-1===o)throw new Error("argument not found");const i=[...e.args];return i.splice(o,0,n),{...e,args:i}}const o=[...e.args];return o.push(n),{...e,args:o}},replaceArg(e,{arg:n,oldChildId:t}){const o=(0,r.replaceInArr)(e.args,t,n);if("not found"===o.status)throw new Error("argument not found");return{...e,args:o.arr}},replaceMethod:(e,{method:n})=>({...e,method:n}),moveArgBefore(e,{argId:n,targetId:t}){if(n===t)return e;const r=e.args.find((e=>e.astNodeId===n));if(!r)throw new Error("argument not found");const o=e.args.filter((e=>e.astNodeId!==n)).flatMap((e=>e.astNodeId===t?[r,e]:[e]));if(o.length!==e.args.length)throw new Error("target not found "+t);return{...e,args:o}},moveArgAfter(e,{argId:n,targetId:t}){if(n===t)return e;const r=e.args.find((e=>e.astNodeId===n));if(!r)throw new Error("argument not found");const o=e.args.filter((e=>e.astNodeId!==n)).flatMap((e=>e.astNodeId===t?[e,r]:[e]));if(o.length!==e.args.length)throw new Error("target not found "+t);return{...e,args:o}},removeArgsInRange:(e,{from:n,to:t})=>({...e,args:e.args.slice(0,n).concat(e.args.slice(null!=t?t:e.args.length))})},n.callPlugin=(0,i.packPlugin)()({kind:"call",modifiers:n.callModifiers,getNodeChildren(e){var n;return[e.method,...null!==(n=e.args)&&void 0!==n?n:[]]},replaceChild(e,n,t){if(e.method.astNodeId===n)return{...e,method:t};const o=(0,r.replaceInArr)(e.args,n,t);if("not found"===o.status)throw new Error("child not found");return{...e,args:o.arr}},createBlank:e=>(0,o.createCallNode)({astNodeId:e(),method:(0,s.createReferenceNode)({astNodeId:e(),name:"parseInt"})})})},42048:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.isCallNode=n.createCallNode=void 0;const r=t(87185);n.createCallNode=function(e){return{kind:"call",hasNewKeyword:!1,args:[],...e}},n.isCallNode=e=>!!e&&(0,r.isNodeOfKind)("call",e)},92054:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163);r.__exportStar(t(63452),n),r.__exportStar(t(56533),n)},63452:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.functionPlugin=void 0;const r=t(87185),o=t(56533);n.functionPlugin=(0,r.packPlugin)()({kind:"function",modifiers:{},createBlank:e=>(0,o.createFunctionNode)({astNodeId:e(),name:"fn"})})},56533:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.isFunctionNode=n.createFunctionNode=void 0;const r=t(87185);n.createFunctionNode=function(e){return{kind:"function",args:[],body:[],...e}},n.isFunctionNode=e=>(0,r.isNodeOfKind)("function",e)},87085:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163);r.__exportStar(t(26504),n),r.__exportStar(t(42143),n),r.__exportStar(t(92054),n),r.__exportStar(t(93145),n),r.__exportStar(t(11442),n),r.__exportStar(t(77949),n),r.__exportStar(t(84156),n),r.__exportStar(t(94654),n),r.__exportStar(t(85921),n),r.__exportStar(t(18377),n),r.__exportStar(t(33734),n),r.__exportStar(t(21218),n),r.__exportStar(t(26511),n),r.__exportStar(t(80421),n),r.__exportStar(t(67552),n),r.__exportStar(t(62325),n)},93145:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163);r.__exportStar(t(10766),n),r.__exportStar(t(85136),n)},10766:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.jsxExpressionPlugin=n.jsxPlugin=n.addChild=n.removeChildWithIndex=n.removeChild=n.getSummarizedStartSpace=n.getSummarizedEndSpace=n.getStartSpaces=n.getStartSpacesLength=n.getSummarizedSpaces=n.getEndSpaces=n.getEndSpacesLength=n.jsxSpreadPropertyPlugin=n.jsxTextPlugin=n.getJSXPropValue=n.jsxPropPlugin=n.modifiers=void 0;const r=t(87185),o=t(85136),i=t(23987),s=t(4697),a=t(5786),c=t(85272),l=t(26504);function d(e,n){return(0,o.isJSXTextNode)(e)?e.value.trim():n?(0,c.makeNodeWithNewIds)(e,n):e}n.modifiers={},n.jsxPropPlugin=(0,r.packPlugin)()({kind:"jsx-prop",modifiers:{setValue:(e,{value:n,replaceIds:t})=>t&&"string"!=typeof n&&"boolean"!=typeof n?{...e,value:(0,c.makeNodeWithNewIds)(n,t)}:{...e,value:n},addChild(e,t){if(!(0,r.isAddInsteadModArgs)(t))throw new Error("props only support add instead");return n.jsxPropPlugin.modifiers.setValue(e,{value:d(t.newChild,t.replaceIds)})},removeChild(e,{placeholderId:n}){if(!n)throw new Error("no id for node to replace prop value");return{...e,value:(0,s.createNullNode)({astNodeId:n})}}},getNodeChildren:e=>"string"!=typeof e.value&&!0!==e.value&&e.value?[e.value]:[],replaceChild:(e,n,t)=>{if("string"!=typeof e.value&&!0!==e.value&&e.value.astNodeId===n)return{...e,value:t};throw new Error("child not found")},createBlank:e=>(0,o.createJSXPropNode)({astNodeId:e(),name:"new",value:""})}),n.getJSXPropValue=d,n.jsxTextPlugin=(0,r.packPlugin)()({kind:"jsx-text-element",modifiers:{setValue:({astNodeId:e},{value:n})=>({kind:"jsx-text-element",astNodeId:e,value:(0,o.trimJsxText)(n)})},createBlank:e=>(0,o.createJSXTextNode)({astNodeId:e(),value:""})}),n.jsxSpreadPropertyPlugin=(0,r.packPlugin)()({kind:"jsx-spread-prop",modifiers:{},createBlank:e=>(0,o.createJSXSpreadPropertyNode)({astNodeId:e(),value:l.arrayPlugin.createBlank(e)}),getNodeChildren:e=>[e.value],replaceChild:(e,n,t)=>{if(e.value.astNodeId!==n)throw new Error("value not found");return{...e,value:t}}}),n.getEndSpacesLength=e=>e.length-e.trimEnd().length,n.getEndSpaces=e=>e.slice(e.length-(0,n.getEndSpacesLength)(e)),n.getSummarizedSpaces=e=>e.length?e.includes("\n")?"\n":" ":"",n.getStartSpacesLength=e=>e.length-e.trimStart().length,n.getStartSpaces=e=>e.slice(0,(0,n.getStartSpacesLength)(e)),n.getSummarizedEndSpace=e=>(0,n.getSummarizedSpaces)((0,n.getEndSpaces)(e)),n.getSummarizedStartSpace=e=>(0,n.getSummarizedSpaces)((0,n.getStartSpaces)(e));const u=(e,{propId:n})=>{const t=e.props.filter((e=>e.astNodeId!==n));return{...e,props:t}};function p(e,n){return e.findIndex((e=>e.astNodeId===n))}n.removeChild=(e,{childId:t},o)=>{const i=e.children.findIndex((e=>e.astNodeId===t));if(-1!==i)return(0,n.removeChildWithIndex)(e,{idx:i},o);for(const n of e.props)if(n.astNodeId===t||(0,r.isNodeOfKind)("jsx-prop",n)&&"object"==typeof n.value&&n.value.astNodeId===t)return u(e,{propId:n.astNodeId});return e},n.removeChildWithIndex=(e,{idx:t})=>{let o=!1,i=!1,s=!1,a=" ";if(t>0){const i=e.children[t-1];(0,r.isNodeOfKind)("jsx-text-element",i)&&(0===i.value.trim().length?o=!0:(a=(0,n.getSummarizedEndSpace)(i.value),s=!0))}if(t<e.children.length-1){const o=e.children[t+1];if((0,r.isNodeOfKind)("jsx-text-element",o))if(t==e.children.length-2&&0===o.value.trim().length)i=!0;else if(s){const r=[...e.children];return a=(0,n.getSummarizedStartSpace)(a+o.value),r.splice(t-1,3,{astNodeId:r[t-1].astNodeId,kind:"jsx-text-element",value:r[t-1].value.trimEnd()+a+o.value.trimStart()}),{...e,children:r}}}const c=[...e.children];let l=1;return o&&l++,i&&l++,c.splice(o?t-1:t,l),{...e,children:c}},n.addChild=(e,{newChild:n,...t})=>{if(!(0,r.isAddBeforeModArgs)(t)&&!(0,r.isAddAfterModArgs)(t)||void 0===t.spaceBeforeId||void 0===t.spaceAfterId)throw new Error("jsx only supports add-before, add-after with spaceBeforeId & spaceAfterId");const i=void 0===t.replaceIds?n:(0,c.makeNodeWithNewIds)(n,t.replaceIds),s=[...e.children],a=(0,r.isNodeOfKind)("jsx-text-element",i),l=function(e,n){return(0,r.isAddBeforeModArgs)(n)?n.beforeChildId?p(e.children,n.beforeChildId):e.children.length:(0,r.isAddAfterModArgs)(n)?n.afterChildId?p(e.children,n.afterChildId)+1:0:-1}(e,t),d=[],u=s[l-1],h=s[l];if((0,r.isNodeOfKind)("jsx-text-element",i)){if(u&&(0,r.isNodeOfKind)("jsx-text-element",u)){const n={...i,value:(0,o.trimJsxText)(u.value+i.value)};return s.splice(l-1,1,n),{...e,children:s}}if(h&&(0,r.isNodeOfKind)("jsx-text-element",h)){const n={...i,value:(0,o.trimJsxText)(i.value+h.value)};return s.splice(l,1,n),{...e,children:s}}}const f=!u||!(0,r.isNodeOfKind)("jsx-text-element",u),m=!h||!(0,r.isNodeOfKind)("jsx-text-element",h);if(!a&&f&&d.push((0,o.createJSXTextNode)({astNodeId:t.spaceBeforeId,value:"\n"})),d.push(i),!a&&m&&d.push((0,o.createJSXTextNode)({astNodeId:t.spaceAfterId,value:"\n"})),s.splice(l,0,...d),-1===l)throw new Error("reference child not found");return{...e,children:s}},n.jsxPlugin=(0,r.packPlugin)()({kind:"jsx-element",modifiers:{removeChild:n.removeChild,removeChildWithIndex:n.removeChildWithIndex,addChild:n.addChild,moveChild:a.moveNode,addProp:(e,{prop:n})=>function(e,n){return e.props.some((e=>e.astNodeId===n.astNodeId))}(e,n)?e:{...e,props:[...e.props,n]},replaceChild:(e,{childId:n,target:t})=>({...e,children:e.children.map((e=>e.astNodeId===n?t:e))}),setProperty(e,{propId:n,value:t}){const r=e.props.findIndex((e=>e.astNodeId===n));if(-1===r)throw new Error("child node not found");const o=e.props[r],i=[...e.props.slice(0,r),{...o,value:t},...e.props.slice(r+1)];return{...e,props:i}},setPropertyLike(e,{propLike:n}){const t=e.props.findIndex((e=>e.astNodeId===n.astNodeId));if(-1===t)throw new Error("child node not found");const r=[...e.props.slice(0,t),{...n},...e.props.slice(t+1)];return{...e,props:r}},removeProp:u},getNodeChildren:e=>"string"==typeof e.type?[...e.children,...e.props]:[...e.children,...e.props,e.type],replaceChild:(e,n,t)=>{if("object"==typeof e.type&&e.type.astNodeId===n)return{...e,type:t};const r=(0,c.replaceInArr)(e.props,n,t);if("success"==r.status)return{...e,props:r.arr};const o=(0,c.replaceInArr)(e.children,n,t);if("success"==o.status)return{...e,children:o.arr};throw new Error("child not found")},createBlank:e=>(0,o.createJSXElement)({astNodeId:e(),type:(0,i.createUnparsedNode)({astNodeId:e(),code:""})})}),n.jsxExpressionPlugin=(0,r.packPlugin)()({kind:"jsx-expression",modifiers:{setExpression:(e,{expression:n})=>({...e,expression:n}),removeChild(e,{placeholderId:n}){if(!n)throw new Error("can't remove expression without placeholder id");return{...e,expression:(0,s.createNullNode)({astNodeId:n})}},addChild(e,n){if(!(0,r.isAddInsteadModArgs)(n))throw new Error("jsx-expression only supports add-instead");return{...e,expression:n.replaceIds?(0,c.makeNodeWithNewIds)(n.newChild,n.replaceIds):n.newChild}}},getNodeChildren:e=>e.expression?[e.expression]:[],replaceChild:(e,n,t)=>{if(!e.expression||e.expression.astNodeId!==n)throw new Error("child not found");return{...e,expression:t}},createBlank:e=>(0,o.createJSXExpressionNode)({astNodeId:e(),expression:(0,s.createBooleanNode)({astNodeId:e(),value:!0})})})},85136:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.createJSXExpressionNode=n.createJSXSpreadPropertyNode=n.createJSXTextNode=n.createJSXPropNode=n.createJSXElement=n.trimJsxText=n.isJSXStringNode=n.isJSXSpreadNode=n.isJSXTextNode=n.isJSXProp=n.isJSXExpressionNode=n.isJSXElementNode=void 0;const r=t(87185);n.isJSXElementNode=e=>!!e&&(0,r.isNodeOfKind)("jsx-element",e),n.isJSXExpressionNode=e=>!!e&&(0,r.isNodeOfKind)("jsx-expression",e),n.isJSXProp=e=>!!e&&(0,r.isNodeOfKind)("jsx-prop",e),n.isJSXTextNode=e=>!!e&&(0,r.isNodeOfKind)("jsx-text-element",e),n.isJSXSpreadNode=e=>!!e&&(0,r.isNodeOfKind)("jsx-spread-prop",e),n.isJSXStringNode=e=>!!e&&(0,r.isNodeOfKind)("string",e),n.trimJsxText=e=>e.split(/(\s+)/).reduce(((e,n,t)=>t%2==0?e+n:n.includes("\n")?e+"\n":e+" "),""),n.createJSXElement=function(e){return{kind:"jsx-element",children:[],props:[],...e}},n.createJSXPropNode=function(e){return{kind:"jsx-prop",...e}},n.createJSXTextNode=function(e){return{kind:"jsx-text-element",...e,value:(0,n.trimJsxText)(e.value)}},n.createJSXSpreadPropertyNode=function(e){return{kind:"jsx-spread-prop",...e,value:e.value}},n.createJSXExpressionNode=function(e){return{kind:"jsx-expression",...e}}},11442:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163);r.__exportStar(t(7688),n),r.__exportStar(t(61285),n),r.__exportStar(t(94520),n)},7688:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.computedPropertyNamePlugin=n.namedPropertyPlugin=n.objectPlugin=n.objectModifiers=void 0;const r=t(61285),o=t(87185),i=t(4697),s=t(69521),a=t(77949);n.objectModifiers={addProperty(e,{name:n,value:t,propertyId:o}){const i=(0,r.createPropertyNode)({astNodeId:o,name:n,initializer:t});return(0,r.createObjectNode)({astNodeId:e.astNodeId,properties:[...e.properties,i]})},removeProperty(e,{childId:n}){const t=e.properties.findIndex((e=>e.astNodeId===n));if(-1===t)throw new Error("child node not found");const o=e.properties[t];return(0,r.createObjectNode)({astNodeId:e.astNodeId,properties:[...e.properties.filter((e=>e!==o))]})},setProperty(e,{childId:n,value:t}){const i=e.properties.findIndex((e=>e.astNodeId===n));if(-1===i)throw new Error("child node not found");const s=e.properties[i];if(!(0,o.isNodeOfKind)("property",s))throw new Error("Cannot set property for non property node");const a=[...e.properties.slice(0,i),{...s,initializer:t},...e.properties.slice(i+1)];return(0,r.createObjectNode)({astNodeId:e.astNodeId,properties:a})},renameProperty(e,{childId:n,newName:t}){const r=e.properties.findIndex((e=>e.astNodeId===n));if(-1===r)throw new Error("child node not found");const s=e.properties[r];if(!(0,o.isNodeOfKind)("property",s))throw new Error("could not rename spread");const a=new Array(e.properties.length);for(let n=0;n<e.properties.length;n++){const r=e.properties[n];a[n]=r===s?{...s,name:(0,i.createStringNode)({astNodeId:s.name.astNodeId,value:t})}:r}return{...e,properties:a}}},n.objectPlugin=(0,o.packPlugin)()({kind:"object",modifiers:n.objectModifiers,createBlank:e=>(0,r.createObjectNode)({astNodeId:e()}),getNodeChildren:e=>e.properties,replaceChild:(e,n,t)=>{const r=(0,s.replaceInArr)(e.properties,n,t);if("success"!==r.status)throw new Error("replace properties in object, "+r.status);return{...e,properties:r.arr}}}),n.namedPropertyPlugin=(0,o.packPlugin)()({kind:"property",modifiers:{removeChild(e,{childId:n,placeholderId:t}){const r=(0,a.isStringNode)(e.name)?e.name.value:"";if(n!==e.initializer.astNodeId)throw new Error("property ${name} can only remove initializer");if(!t)throw new Error(`property ${r} needs a placeholderId to remove value, and replace it with null`);return{...e,initializer:(0,i.createNullNode)({astNodeId:t})}}},createBlank:e=>(0,r.createPropertyNode)({astNodeId:e(),name:(0,i.createStringNode)({astNodeId:e(),value:""}),initializer:{astNodeId:e(),kind:"undefined"}}),getNodeChildren:e=>[e.name,e.initializer],replaceChild:(e,n,t)=>{if(e.initializer.astNodeId===n)return{...e,initializer:t};if(e.name.astNodeId===n)return{...e,name:t};throw new Error("child not found")}}),n.computedPropertyNamePlugin=(0,o.packPlugin)()({kind:"computed-property-name",modifiers:{},createBlank:e=>(0,r.createComputedPropertyNameNode)({astNodeId:e(),expression:(0,i.createStringNode)({astNodeId:e(),value:""})}),getNodeChildren:e=>[e.expression],replaceChild:(e,n,t)=>{if(e.expression.astNodeId===n)return{...e,expression:t};throw new Error("child not found")}})},61285:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.isObjectNode=n.createObjectNode=n.isComputedPropertyNameNode=n.createComputedPropertyNameNode=n.isPropertyNode=n.createPropertyNode=void 0;const r=t(87185);n.createPropertyNode=function(e){return{kind:"property",...e}},n.isPropertyNode=e=>!!e&&(0,r.isNodeOfKind)("property",e),n.createComputedPropertyNameNode=function(e){return{kind:"computed-property-name",...e}},n.isComputedPropertyNameNode=e=>!!e&&(0,r.isNodeOfKind)("computed-property-name",e),n.createObjectNode=function(e){return{kind:"object",properties:[],...e}},n.isObjectNode=e=>!!e&&(0,r.isNodeOfKind)("object",e)},94520:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.getSimpleObjectProp=void 0;const r=t(87185);n.getSimpleObjectProp=(e,n)=>e.find((e=>(0,r.isNodeOfKind)("property",e)&&(0,r.isNodeOfKind)("string",e.name)&&e.name.value===n))},4697:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.createUndefinedNode=n.createNullNode=n.createBooleanNode=n.createNumberNode=n.createStringNode=void 0,n.createStringNode=function(e){return{kind:"string",...e}},n.createNumberNode=function(e){return{kind:"number",...e}},n.createBooleanNode=function(e){return{kind:"boolean",...e}},n.createNullNode=function(e){return{kind:"null",...e}},n.createUndefinedNode=function(e){return{kind:"undefined",...e}}},77949:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163);r.__exportStar(t(48411),n),r.__exportStar(t(82938),n),r.__exportStar(t(4697),n)},48411:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.undefinedPlugin=n.nullPlugin=n.booleanPlugin=n.numberPlugin=n.stringPlugin=n.booleanModifiers=n.numberModifiers=n.stringModifiers=void 0;const r=t(4697),o=t(87185);n.stringModifiers={setValue:(e,n)=>(0,r.createStringNode)({astNodeId:e.astNodeId,value:n.value})},n.numberModifiers={setValue:(e,n)=>(0,r.createNumberNode)({astNodeId:e.astNodeId,value:n.value})},n.booleanModifiers={setValue:(e,n)=>(0,r.createBooleanNode)({astNodeId:e.astNodeId,value:n.value})},n.stringPlugin=(0,o.packPlugin)()({kind:"string",modifiers:n.stringModifiers,createBlank:e=>(0,r.createStringNode)({astNodeId:e(),value:""}),squash:e=>{const n=[],t=new Set;for(let r=e.length-1;r>=0;r--){const o=e[r];"setValue"===o.modification?t.has(o.targetId)||(t.add(o.targetId),n.unshift(o)):n.unshift(o)}return n}}),n.numberPlugin=(0,o.packPlugin)()({kind:"number",modifiers:n.numberModifiers,createBlank:e=>(0,r.createNumberNode)({astNodeId:e(),value:0})}),n.booleanPlugin=(0,o.packPlugin)()({kind:"boolean",modifiers:n.booleanModifiers,createBlank:e=>(0,r.createBooleanNode)({astNodeId:e(),value:!0})}),n.nullPlugin=(0,o.packPlugin)()({kind:"null",modifiers:{},createBlank:e=>({kind:"null",astNodeId:e()})}),n.undefinedPlugin=(0,o.packPlugin)()({kind:"undefined",modifiers:{},createBlank:e=>({kind:"undefined",astNodeId:e()})})},82938:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.isUndefinedNode=n.isNullNode=n.isBooleanNode=n.isNumberNode=n.isStringNode=void 0;const r=t(87185);n.isStringNode=e=>!!e&&(0,r.isNodeOfKind)("string",e),n.isNumberNode=e=>(0,r.isNodeOfKind)("number",e),n.isBooleanNode=e=>(0,r.isNodeOfKind)("boolean",e),n.isNullNode=e=>!!e&&(0,r.isNodeOfKind)("null",e),n.isUndefinedNode=e=>(0,r.isNodeOfKind)("undefined",e)},84156:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163);r.__exportStar(t(8543),n),r.__exportStar(t(51201),n)},8543:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.elementAccessIndexPlugin=n.elementAccessIndexModifiers=n.propertyAccessIndexPlugin=n.propertyAccessIndexModifiers=n.propertyAccessPlugin=n.propertyAccessModifiers=void 0;const r=t(51201),o=t(87185),i=t(89038),s=t(48411);n.propertyAccessModifiers={setValue:(e,{reference:n,accessPath:t})=>(0,r.createPropertyAccessNode)({astNodeId:e.astNodeId,reference:n,accessPath:t})},n.propertyAccessPlugin=(0,o.packPlugin)()({kind:"property-access",modifiers:n.propertyAccessModifiers,createBlank:e=>(0,r.createPropertyAccessNode)({astNodeId:e(),reference:s.undefinedPlugin.createBlank(e),accessPath:[]}),getNodeChildren:e=>[e.reference,...e.accessPath],replaceChild:(e,n,t)=>{if(e.reference.astNodeId===n){if((0,i.isAnyReferenceNode)(t)||(0,o.isNodeOfKind)("UnparsedNode",t))return{...e,reference:t};throw new Error("Cannot replace reference with non reference or unparsed")}throw new Error("Child not found")}}),n.propertyAccessIndexModifiers={},n.propertyAccessIndexPlugin=(0,o.packPlugin)()({kind:"property-access-index",modifiers:{},createBlank:e=>(0,r.createPropertyAccessIndexNode)({astNodeId:e(),accessKey:"new"})}),n.elementAccessIndexModifiers={},n.elementAccessIndexPlugin=(0,o.packPlugin)()({kind:"element-access-index",modifiers:{},createBlank:e=>(0,r.createElementAccessIndexNode)({astNodeId:e(),accessKey:"new-accesskey"})})},51201:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.createAccessIndexNode=n.isSimpleAccessPathElement=n.isSimplePropertyAccessNode=n.createPropertyAccessNode=n.isSimpleElementAccessIndexNode=n.isSimplePropertyAccessIndexNode=n.createElementAccessIndexNode=n.createPropertyAccessIndexNode=void 0;const r=t(23987),o=t(89038),i=t(5121);function s(e){return{kind:"property-access-index",...e}}function a(e){return{kind:"element-access-index",...e}}function c(e){return!!e&&"property-access-index"===e.kind}function l(e){return!!e&&"element-access-index"===e.kind}n.createPropertyAccessIndexNode=s,n.createElementAccessIndexNode=a,n.isSimplePropertyAccessIndexNode=c,n.isSimpleElementAccessIndexNode=l,n.createPropertyAccessNode=function(e){return{kind:"property-access",...e}},n.isSimplePropertyAccessNode=function(e){return!!e&&"property-access"===e.kind},n.isSimpleAccessPathElement=function(e){return!!e&&(c(e)||l(e)||(0,o.isSimpleReferenceNode)(e)||(0,r.isUnparsedNode)(e))},n.createAccessIndexNode=function(e,n){return(0,i.isValidIdentifierName)(e)?s({astNodeId:n(),accessKey:e}):a({astNodeId:n(),accessKey:isNaN(Number(e))?e:Number(e)})}},94654:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163);r.__exportStar(t(36161),n),r.__exportStar(t(89038),n)},36161:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.referencePlugin=n.referenceModifiers=void 0;const r=t(87185),o=t(89038);n.referenceModifiers={changeModuleSpecifier:(e,{specifier:n})=>(0,o.isSimpleFileReferenceNode)(e)?{...e,specifier:n}:{...e}},n.referencePlugin=(0,r.packPlugin)()({kind:"ref",modifiers:n.referenceModifiers,createBlank:e=>(0,o.createReferenceNode)({astNodeId:e(),name:"new"})})},89038:(e,n)=>{"use strict";function t(e){return"ref"===(null==e?void 0:e.kind)&&"in-file"===e.refType}function r(e){return"ref"===(null==e?void 0:e.kind)&&"between-file"===e.refType}Object.defineProperty(n,"__esModule",{value:!0}),n.createFileReferenceNode=n.createReferenceNode=n.isAnyReferenceNode=n.isSimpleFileReferenceNode=n.isSimpleReferenceNode=n.isReferenceNode=void 0,n.isReferenceNode=function(e){return!!e&&"ref"===e.kind},n.isSimpleReferenceNode=t,n.isSimpleFileReferenceNode=r,n.isAnyReferenceNode=function(e){return t(e)||r(e)},n.createReferenceNode=function(e){return{kind:"ref",refType:"in-file",...e}},n.createFileReferenceNode=function(e){return{refType:"between-file",kind:"ref",...e}}},85921:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163);r.__exportStar(t(35949),n),r.__exportStar(t(65491),n)},35949:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.filePlugin=void 0;const r=t(87185),o=t(65491),i=t(69521);n.filePlugin=(0,r.packPlugin)()({kind:"root",modifiers:{addStatement(e,{newStatement:n,beforeStatementId:t}){const r=[...e.statements];if(t){const e=(0,i.findIdxByID)(r,t);if(-1===e)throw new Error("reference node not found");r.splice(e,0,n)}else r.push(n);return{...e,statements:r}},removeStatement(e,{statementId:n}){const t=e.statements.filter((e=>e.astNodeId!==n));return{...e,statements:t}}},createBlank:e=>(0,o.createRootNode)({astNodeId:e(),statements:[]}),getNodeChildren:e=>e.statements,replaceChild:(e,n,t)=>{const r=e.statements.findIndex((e=>e.astNodeId===n));if(-1===r)throw new Error("statement not found in file");const o=[...e.statements];return o.splice(r,1,t),{...e,statements:o}}})},65491:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.isSourceFileNode=n.createRootNode=void 0;const r=t(87185);n.createRootNode=function(e){return{kind:"root",...e}},n.isSourceFileNode=e=>!!e&&(0,r.isNodeOfKind)("root",e)},18377:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163);r.__exportStar(t(60932),n),r.__exportStar(t(3097),n)},60932:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.templateStringTextPlugin=n.templateStringPlugin=n.templateStringModifiers=void 0;const r=t(3097),o=t(87185),i=t(69521);function s(e,n,t){const o=e.elements[t-1],i=e.elements[t],s=[...e.elements];if((0,r.isTemplateText)(n)){const a=s.length>1?n.astNodeId:e.astNodeId+"_text";if(o&&(0,r.isTemplateText)(o)){const e=(0,r.createTemplateText)({astNodeId:a,text:o.text+n.text});s.splice(t-1,1,e)}else if(i&&(0,r.isTemplateText)(i)){const e=(0,r.createTemplateText)({astNodeId:a,text:n.text+i.text});s.splice(t,1,e)}else s.length?s.splice(t,0,n):s.push((0,r.createTemplateText)({astNodeId:a,text:n.text}))}else s.splice(t,0,n);return(0,r.createTemplateNode)({astNodeId:e.astNodeId,elements:s})}n.templateStringModifiers={removeElement(e,{elementId:n}){const t=(0,i.findIdxByID)(e.elements,n);if(-1===t)throw Error("node to remove not found");const o=e.elements[t];if(!(0,r.isTemplateText)(o)){if(1===e.elements.filter((e=>!(0,r.isTemplateText)(e))).length){const n=[(0,r.createTemplateText)({astNodeId:e.astNodeId+"_text",text:e.elements.reduce(((e,n)=>(0,r.isTemplateText)(n)?e+n.text:e),"")})];return(0,r.createTemplateNode)({astNodeId:e.astNodeId,elements:n})}{const n=e.elements[t-1],o=e.elements[t+1];if(o&&n&&(0,r.isTemplateText)(n)&&(0,r.isTemplateText)(o)){const i=[...e.elements.slice(0,t-1),(0,r.createTemplateText)({astNodeId:n.astNodeId,text:n.text+o.text}),...e.elements.slice(t+2)];return(0,r.createTemplateNode)({astNodeId:e.astNodeId,elements:i})}}}const s=e.elements.filter((e=>e.astNodeId!==n));return(0,r.createTemplateNode)({astNodeId:e.astNodeId,elements:s})},insertAtBeginning:(e,{value:n})=>s(e,n,0),insertAtEnd:(e,{value:n})=>s(e,n,e.elements.length),insertBefore(e,{targetId:n,value:t}){const r=e.elements.findIndex((e=>e.astNodeId===n));return s(e,t,r)},insertAfter(e,{targetId:n,value:t}){const r=e.elements.findIndex((e=>e.astNodeId===n));return s(e,t,r+1)}},n.templateStringPlugin=(0,o.packPlugin)()({kind:"template-string",modifiers:n.templateStringModifiers,createBlank:e=>(0,r.createTemplateNode)({astNodeId:e()}),getNodeChildren:e=>e.elements,replaceChild:(e,n,t)=>{const r=(0,i.replaceInArr)(e.elements,n,t);if("success"!==r.status)throw new Error("replace properties in object, "+r.status);return{...e,elements:r.arr}}}),n.templateStringTextPlugin=(0,o.packPlugin)()({kind:"template-string-text",modifiers:{},createBlank:e=>(0,r.createTemplateText)({astNodeId:e()})})},3097:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.isTemplateText=n.createTemplateText=n.isTemplateStringNode=n.createTemplateNode=void 0;const r=t(87185);n.createTemplateNode=function(e){return{kind:"template-string",elements:[],...e}},n.isTemplateStringNode=function(e){return(0,r.isNodeOfKind)("template-string",e)},n.createTemplateText=function(e){return{kind:"template-string-text",text:"",...e}},n.isTemplateText=function(e){return(0,r.isNodeOfKind)("template-string-text",e)}},80421:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.trinaryPlugin=void 0;const r=t(85272),o=t(87185),i=t(4697),s=t(67552),a={};function c(e,n,t){var r;const o={...e};return e.condition.astNodeId===n&&(o.condition=t),(null===(r=e.whenFalse)||void 0===r?void 0:r.astNodeId)===n&&(o.whenFalse=t),e.whenTrue.astNodeId===n&&(o.whenTrue=t),o}n.trinaryPlugin=(0,o.packPlugin)()({kind:"trinary",modifiers:a,createBlank:e=>(0,s.createTrinaryNode)({astNodeId:e(),condition:(0,i.createBooleanNode)({astNodeId:e(),value:!0}),whenTrue:(0,i.createNullNode)({astNodeId:e()}),whenFalse:(0,i.createNullNode)({astNodeId:e()})}),getNodeChildren:e=>e.whenFalse?[e.condition,e.whenTrue,e.whenFalse]:[e.condition,e.whenTrue],replaceChild:c}),a.addChild=(e,n)=>{if(!(0,o.isAddInsteadModArgs)(n))throw new Error("ternary only supports add-instead");const t=n.replaceIds?(0,r.makeNodeWithNewIds)(n.newChild,n.replaceIds):n.newChild;return c(e,n.insteadOfChildId,t)},a.removeChild=(e,{childId:n,placeholderId:t})=>t?c(e,n,(0,i.createNullNode)({astNodeId:t})):e},67552:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.isTrinaryNode=n.createTrinaryNode=void 0;const r=t(87185);n.createTrinaryNode=function(e){return{kind:"trinary",...e}},n.isTrinaryNode=function(e){return!!e&&(0,r.isNodeOfKind)("trinary",e)}},26511:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163);r.__exportStar(t(66180),n),r.__exportStar(t(10700),n)},66180:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.unparsedWithRootsPlugin=void 0;const r=t(85272),o=t(87185),i=t(10700);n.unparsedWithRootsPlugin=(0,o.packPlugin)()({kind:"unparsed-with-roots",modifiers:{},createBlank:e=>(0,i.createUnparsedWithRoots)({astNodeId:e(),roots:[]}),getNodeChildren:e=>e.roots,replaceChild:(e,n,t)=>{const o=(0,r.replaceInArr)(e.roots,n,t);if("not found"===o.status)throw new Error("node not found in expression");return{...e,roots:o.arr}}})},10700:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.createUnparsedWithRoots=n.isUnparsedWithParsedRoots=void 0;const r=t(87185);n.isUnparsedWithParsedRoots=function(e){return!!e&&(0,r.isNodeOfKind)("unparsed-with-roots",e)},n.createUnparsedWithRoots=function(e){return{kind:"unparsed-with-roots",roots:[],...e}}},33734:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),t(5163).__exportStar(t(23987),n)},23987:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.isUnparsedNode=n.createUnparsedNode=void 0;const r=t(87185);n.createUnparsedNode=function(e){return{kind:"UnparsedNode",...e}},n.isUnparsedNode=function(e){return(0,r.isNodeOfKind)("UnparsedNode",e)}},21218:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163);r.__exportStar(t(84656),n),r.__exportStar(t(32456),n)},84656:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.variablePlugin=n.variableModifiers=void 0;const r=t(87185),o=t(32456);n.variableModifiers={inlineRename:(e,{name:n})=>({...e,name:n}),changeVarKind:(e,{varKind:n})=>({...e,varKind:n})},n.variablePlugin=(0,r.packPlugin)()({kind:"variable",modifiers:n.variableModifiers,createBlank:e=>(0,o.createVariableNode)({astNodeId:e(),name:"new",varKind:"const"}),getNodeChildren:e=>{const n=[];return"string"!=typeof e.name&&n.push(e.name),e.initializer&&n.push(e.initializer),n},replaceChild:(e,n,t)=>{if(e.initializer&&e.initializer.astNodeId===n)return{...e,initializer:t};if("string"!=typeof e.name&&e.name.astNodeId===n)return{...e,name:t};throw new Error("unknown child")}})},32456:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.isVariableNode=n.createVariableNode=void 0;const r=t(87185);n.createVariableNode=function(e){return{kind:"variable",varKind:"const",...e}},n.isVariableNode=function(e){return(0,r.isNodeOfKind)("variable",e)}},36136:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.endNode=n.isEndNode=n.isStartNode=n.startNode=n.ASTChange=void 0,n.ASTChange=function(e,n,t,r){const o={from:e,to:n,newContent:t};return r&&(o.removedIds=r),o},n.startNode=function(e,n){return{id:e,kind:"start",nodeKind:n}},n.isStartNode=function(e){return"string"!=typeof e&&"start"===e.kind},n.isEndNode=function(e){return"string"!=typeof e&&"end"===e.kind},n.endNode=function(e){return{id:e,kind:"end"}}},15089:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.createPrefixCounter=void 0,n.createPrefixCounter=function(e,n=0){let t=n;return{nextId:()=>e+t++,currentCount:()=>t}}},84169:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.findNodeAndParents=n.findNode=n.replaceNode=n.cloneNode=n.visitAllNodes=n.walkProjectedNodes=void 0;const r=t(36738),o=t(87085);function i(e,n,t,r){if(e&&t(e,r)){const r=n.get(e.kind);if(r&&r.getNodeChildren){const o=r.getNodeChildren(e);for(const r of o)i(r,n,t,e)}}}function s(e,n,t){var r,o;if(e.astNodeId===n)return{node:e,parents:[]};const i=null===(o=null===(r=t.get(e.kind))||void 0===r?void 0:r.getNodeChildren)||void 0===o?void 0:o.call(r,e);if(i)for(const r of i){const o=s(r,n,t);if(o)return{node:o.node,parents:o.parents.concat(e)}}return null}n.walkProjectedNodes=i,n.visitAllNodes=function(e,n,t,r){const s=(e,t)=>i(e,n,a,t);function a(e){return t(e,r),(0,o.isCallNode)(e)&&e.args.forEach((n=>s(n,e))),(0,o.isFunctionNode)(e)&&e.body.forEach((n=>s(n,e))),(0,o.isArrayNode)(e)&&e.elements.forEach((n=>s(n,e))),!0}s(e,r)},n.cloneNode=function(e,n,t=new Map(r.commonSimpleAstParsers.map((e=>[e.nodeKind,e])))){const o=JSON.parse(JSON.stringify(e));return i(o,t,(e=>(e.astNodeId=n(),!0))),o},n.replaceNode=function(e,n,t,r){const o=s(e,n,r);if(!o)throw new Error(`Could not find node or parents of nodeId: ${n}`);let i=t,a=n;for(let e=0;e<o.parents.length;e++){const n=o.parents[e],t=r.get(n.kind);if(!t||!t.replaceChild)throw new Error(`node with kind ${n.kind} doesn't support replaceNode action`);i=t.replaceChild(n,a,i),a=i.astNodeId}return i},n.findNode=function(e,n,t){let r;return i(e,n,(e=>!t(e)||(r=e,!1))),r},n.findNodeAndParents=s},2807:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163);r.__exportStar(t(78490),n),r.__exportStar(t(62973),n)},62973:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.PluggableNodeManipulator=void 0;const r=t(60814),o=t(85272);n.PluggableNodeManipulator=class{constructor(){this.merger=(e,n,t)=>({changesToApply:[...t],changesRevoked:[]}),this.squasher=e=>{const n=(0,o.findLastIndex)(e,(e=>"full"===e.kind));let t;if(-1!==n){const r=e.length-n-1;t=e[r],e=e.slice(r+1)}if(t||e.find((e=>"replace"===e.kind)))return t?[t,...e]:e;let r=e;for(const e of this.repo.getPlugins().values())e.squash&&(r=e.squash(r));return r}}setNodeRepo(e){this.repo=e}reducer(e,n){if("full"===n.kind)return{value:n.value,invertingChanges:[(0,r.fullChange)(e)]};if("replace"===n.kind){const t=this.repo.findNode(e,n.oldNode.astNodeId);return{value:this.repo.replaceNode(e,n.oldNode.astNodeId,n.oldNode),invertingChanges:[{kind:"replace",oldNode:t}]}}const t=this.repo.findNode(e,n.targetId);if(!t)throw new Error("target node not found");const o=this.repo.getPlugin(t.node.kind);try{const r=o.modifiers[n.modification](t.node,n.modificationArgs,this.repo);return{value:this.repo.replaceNode(e,n.targetId,r),invertingChanges:[{kind:"replace",oldNode:t}]}}catch(n){return{value:e,invertingChanges:[]}}}}},78490:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.SimpleAstResource=void 0;const r=t(60814);class o extends r.Resource{getModification(e,n,t){return{kind:"mod",nodeKind:e.kind,targetId:e.astNodeId,modification:n,modificationArgs:t}}applyModification(e,n,t){this.applyChange(this.getModification(e,n,t))}getModificationById(e,n,t,r){return{kind:"mod",nodeKind:n,targetId:e,modification:t,modificationArgs:r}}applyModificationById(e,n,t,r){this.applyChange(this.getModificationById(e,n,t,r))}}n.SimpleAstResource=o},51381:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.getModifier=void 0,n.getModifier=function(e,n,t){const r=void 0!==n?e.getPlugin(n):void 0;if(!r)throw new Error(`no plugin for kind: ${n||"undefined"}`);return r.modifiers[t]}},69521:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.findIdxByID=n.removeFromArr=n.replaceInArr=void 0,n.replaceInArr=(e,n,...t)=>{const r=e.findIndex((e=>e.astNodeId===n));if(-1===r)return{status:"not found",arr:e};const o=[...e];return o.splice(r,1,...t),{status:"success",arr:o}},n.removeFromArr=(e,n)=>{const t=e.findIndex((e=>e.astNodeId===n));if(-1===t)return{status:"not found",arr:e};const r=[...e];return r.splice(t,1),{status:"success",arr:r}},n.findIdxByID=function(e,n){return e.findIndex((e=>e.astNodeId===n))}},85272:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163);r.__exportStar(t(69521),n),r.__exportStar(t(50058),n),r.__exportStar(t(51381),n),r.__exportStar(t(9242),n)},9242:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.makeNodeWithNewIds=void 0,n.makeNodeWithNewIds=function(e,n){return JSON.parse(JSON.stringify(e,((e,t)=>"astNodeId"!==e?t:n[t]||t)))}},50058:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.findLastIndex=n.getComponentName=n.deriveComponentNameFromPath=void 0;const r=t(5163).__importDefault(t(73654)),o=t(91570);function i(e){const n=r.default.win32.parse(e);let t=n.name;return"index"===t&&(t=r.default.win32.basename(n.dir)),t=(0,o.toPascalCase)(t),t=t.replace(/^[^A-Z]+/,""),t||"AnonymousComponent"}n.deriveComponentNameFromPath=i,n.getComponentName=function(e,n,t){return n&&"default"!==n?n:t&&"default"!==t?t:i(e)},n.findLastIndex=function(e,n){let t=e.length;for(;t--;)if(n(e[t]))return t;return-1}},87185:(e,n)=>{"use strict";function t(e){const n=Object.keys(e);return!!n.includes("deeplyParsed")&&!!n.includes("deeplyLiteral")}function r(e,n){return n&&n.kind===e}var o;Object.defineProperty(n,"__esModule",{value:!0}),n.DiagnosticCategory=n.sASTChange=n.isNodeOfKind=n.packPlugin=n.isAddInsteadModArgs=n.isAddAfterModArgs=n.isAddBeforeModArgs=n.NodeApi=n.isDeeplyParsed=n.isComplexNode=void 0,n.isComplexNode=t,n.isDeeplyParsed=function(e){return t(e)?e.deeplyParsed:!r("unparsed",e)},n.NodeApi=class{constructor(e,n){this.node=e,this.applyModifiction=n}},n.isAddBeforeModArgs=function(e){return void 0!==e&&(!e.kind||"add-before"===e.kind)},n.isAddAfterModArgs=function(e){return void 0!==e&&(!e.kind||"add-after"===e.kind)},n.isAddInsteadModArgs=function(e){return"add-instead"===(null==e?void 0:e.kind)},n.packPlugin=function(){return({kind:e,modifiers:n,getNodeChildren:t,replaceChild:r,squash:o,createBlank:i})=>({nodeKind:e,modifiers:n,getNodeChildren:t,replaceChild:r,squash:o,createBlank:i})},n.isNodeOfKind=r,n.sASTChange=(e,n,t,r)=>({kind:"mod",nodeKind:e.nodeKind,modification:n,targetId:t,modificationArgs:r}),(o=n.DiagnosticCategory||(n.DiagnosticCategory={}))[o.Warning=0]="Warning",o[o.Error=1]="Error",o[o.Suggestion=2]="Suggestion",o[o.Message=3]="Message"},94400:(e,n,t)=>{e.exports=t(48541)},9240:(e,n,t)=>{e.exports=t(46726)},26427:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;const r=t(5163);var o=t(16894);Object.defineProperty(n,"default",{enumerable:!0,get:function(){return r.__importDefault(o).default}}),r.__exportStar(t(16894),n)},16894:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.RECOMPUTE_BOARD_LIST_MARK=n.COMPUTE_BOARD_LIST_MARK=void 0;const r=t(5163),o=t(93849),i=t(5689),s=r.__importDefault(t(93104)),a=r.__importStar(t(2206)),c=r.__importDefault(t(94400)),l=r.__importDefault(t(91821)),d=r.__importDefault(t(58729)),u=r.__importDefault(t(72975)),p=r.__importDefault(t(89111)),h=r.__importDefault(t(83260)),f=t(32510),m=t(3092);n.COMPUTE_BOARD_LIST_MARK="COMPUTE_BOARD_LIST_MARK",n.RECOMPUTE_BOARD_LIST_MARK="RECOMPUTE_BOARD_LIST_MARK";const g=(0,f.defineComputedResource)().defineEntity(a.processingEnv),y=(0,f.defineTwoWayResource)().defineEntity(a.processingEnv),_=(0,f.defineComputedResource)().defineEntity(a.processingEnv);n.default=new o.Feature({id:"simulationCapabilities",dependencies:[s.default.asDependency,a.default.asDependency,u.default.asDependency,l.default.asDependency,c.default.asDependency,p.default.asDependency,h.default.asDependency,d.default.asDependency],api:{boardListManager:g,boardListManagerMain:g.defineConsumer(i.mainEnv),boardService:o.Service.withType().defineEntity(i.mainEnv),boardProcessingService:o.Service.withType().defineEntity(a.processingEnv).allowRemoteAccess(),demoErrorManager:y,demoErrorManagerMain:y.defineConsumer(i.mainEnv),environmentPropsManager:_,environmentPropsManagerMain:_.defineConsumer(i.mainEnv),boardsPathConfig:a.default.api.pluggableProjectConfig.entry(m.defaultBoardsPath,"boardsPath")}}).setup(o.Universal,(({},{simpleAST:{simpleASTPlugin:e}})=>{e.register(m.jsxFunctionPlugin),e.register(m.jsxFilePlugin),e.register(m.jsxOwnerPlugin)}))},11963:(e,n)=>{"use strict";var t;Object.defineProperty(n,"__esModule",{value:!0}),n.DemoErrorType=n.defaultBoardName=n.defaultNewBoardName=n.boardExtension=n.defaultBoardsPath=void 0,n.defaultBoardsPath="src/_codux/boards",n.boardExtension=".board.tsx",n.defaultNewBoardName="New Board",n.defaultBoardName="Board",(t=n.DemoErrorType||(n.DemoErrorType={}))[t.CompilationError=0]="CompilationError",t[t.FormatError=1]="FormatError",t[t.RuntimeError=2]="RuntimeError"},3092:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163);r.__exportStar(t(11963),n),r.__exportStar(t(3670),n),r.__exportStar(t(58059),n),r.__exportStar(t(48913),n),r.__exportStar(t(54418),n),r.__exportStar(t(54276),n),r.__exportStar(t(39771),n),r.__exportStar(t(34249),n),r.__exportStar(t(76012),n),r.__exportStar(t(56284),n)},54418:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.jsxFilePlugin=void 0;const r=t(54276),o=t(9240),i=t(5786),s=t(66867);n.jsxFilePlugin=(0,o.packPlugin)()({kind:"jsx-file",modifiers:{moveNode:i.moveNode,copyNode:s.copyNode,updateModuleSpecifiersForPathChange:(e,n,t)=>e},createBlank:e=>(0,r.createJsxRootNode)({astNodeId:e(),owners:[],boards:[],nonJsxOwners:[]}),getNodeChildren:e=>[...e.owners,...e.nonJsxOwners,...e.boards],replaceChild:(e,n,t)=>{const r=(0,o.removeFromArr)(e.nonJsxOwners,n);if("success"===r.status)return{...e,nonJsxOwners:r.arr,owners:[...e.owners,t]};const i=(0,o.replaceInArr)(e.owners,n,t),s=(0,o.replaceInArr)(e.boards,n,t);if([i,s].every((({status:e})=>"not found"===e)))throw new Error("owner not found in file");return{...e,owners:i.arr,boards:s.arr}}})},54276:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.createJsxRootNode=n.isJsxFile=void 0;const r=t(9240);n.isJsxFile=function(e){return!!e&&(0,r.isNodeOfKind)("jsx-file",e)},n.createJsxRootNode=function(e){return{kind:"jsx-file",...e}}},76012:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.jsxFunctionPlugin=void 0;const r=t(56284),o=t(9240);function i(e,n,t){const r=e.returnRoots.findIndex((e=>e.returnValue.astNodeId===n));if(-1!==r){const n=[...e.returnRoots];return n.splice(r,1,{conditions:[],returnValue:t}),{...e,returnRoots:n}}{const r=(0,o.replaceInArr)(e.nonReturnRoots,n,t);if("not found"!==r.status)return{...e,nonReturnRoots:r.arr};throw new Error("owner jsx expression not found in file")}}n.jsxFunctionPlugin=(0,o.packPlugin)()({kind:"jsx-function",modifiers:{addChild:function(e,n){if(!(0,o.isAddInsteadModArgs)(n))throw new Error("jsx-function only supports add-instead");return i(e,n.insteadOfChildId,n.newChild)}},createBlank:e=>(0,r.createJsxOwnerFunction)({astNodeId:e(),names:[]}),getNodeChildren:e=>[...e.returnRoots.map((e=>e.returnValue)),...e.nonReturnRoots],replaceChild:i})},56284:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.createJsxOwnerFunction=n.isJSXFunction=void 0;const r=t(9240);n.isJSXFunction=function(e){return!!e&&(0,r.isNodeOfKind)("jsx-function",e)},n.createJsxOwnerFunction=function(e){return{kind:"jsx-function",returnRoots:[],nonReturnRoots:[],...e}}},39771:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.jsxOwnerPlugin=void 0;const r=t(34249),o=t(9240);n.jsxOwnerPlugin=(0,o.packPlugin)()({kind:"jsx-owner",modifiers:{},createBlank:e=>(0,r.createJsxOwner)({astNodeId:e()}),getNodeChildren:e=>e.roots,replaceChild:(e,n,t)=>{const r=(0,o.replaceInArr)(e.roots,n,t);if("not found"!==r.status)return{...e,roots:r.arr};throw new Error("owner jsx expression not found in file")}})},34249:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.createJsxOwner=n.isJsxOwner=void 0;const r=t(9240);n.isJsxOwner=function(e){return(0,r.isNodeOfKind)("jsx-owner",e)},n.createJsxOwner=function(e){return{kind:"jsx-owner",roots:[],names:[],...e}}},90042:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),t(5163).__exportStar(t(7353),n)},7353:(e,n)=>{"use strict";var t;Object.defineProperty(n,"__esModule",{value:!0}),n.boardListManipulator=n.boardListReducer=n.sortBoardsByFile=n.sortBoards=n.createUpdateFileBoardsChange=n.BoardListChangeKind=void 0,function(e){e.UPDATE_FILE="update-file-boards",e.UPDATE_MODIFIED="update-modified"}(t=n.BoardListChangeKind||(n.BoardListChangeKind={})),n.createUpdateFileBoardsChange=(e,n)=>({kind:t.UPDATE_FILE,path:e,listItems:n}),n.sortBoards=(e,n)=>e.name>n.name?1:-1,n.sortBoardsByFile=(e,n)=>e.boardPath>n.boardPath?1:-1,n.boardListReducer=(e,r)=>{switch(r.kind){case"full":return{value:r.value,invertingChanges:[{kind:"full",value:e}]};case t.UPDATE_FILE:return{value:[...e.filter((({boardPath:e})=>e!==r.path)),...r.listItems].sort(n.sortBoards),invertingChanges:[{kind:"full",value:e}]};case t.UPDATE_MODIFIED:{const n=e.find((({boardPath:e})=>e===r.boardPath));return n?{value:[...e.filter((e=>e.boardPath!==r.boardPath)),{...n,isModified:r.isModified}],invertingChanges:[{kind:"full",value:e}]}:{value:e,invertingChanges:[]}}}},n.boardListManipulator={reducer:n.boardListReducer}},48913:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),t(5163).__exportStar(t(90042),n)},3670:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0})},58059:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.isBoardPath=n.getComponentBoards=n.getStatementNode=n.getBoardNode=n.resetDemoErrors=n.clearDemoError=n.setDemoError=n.getTypeOfMostSevereDemoError=n.incrementBoardName=n.cleanupBoardName=n.compareBoardNames=n.parseComponentRef=n.getComponentRefObject=n.getComponentRef=void 0;const r=t(91570),o=t(11963),i=t(9240),s=t(26709);n.getComponentRef=(e,n)=>`${e}#${n}`,n.getComponentRefObject=e=>{const[n,t]=e.split("#");return{filePath:n,exportName:t}},n.parseComponentRef=e=>{const[n,t]=e.split("#");return n&&t?{filePath:n,exportName:t}:void 0},n.compareBoardNames=function(e,n){return e.localeCompare(n)},n.cleanupBoardName=function(e){return e.replace(/[^\w\s'.,-]/g,"")},n.incrementBoardName=function(e){const[,n,t]=e.match(/(.*?)(\d*$)/);return n+(t?Number(t)+1:" 1")},n.getTypeOfMostSevereDemoError=e=>(0,r.getObjectKeys)(e).map(Number)[0],n.setDemoError=(e,n,t)=>{e.applyChange({kind:"add",path:["errors",n],value:t})},n.clearDemoError=(e,n)=>{const{errors:t}=e.getLatest();n in t&&e.applyChange({kind:"remove",path:["errors",n]})},n.resetDemoErrors=e=>{const{errors:n}=e.getLatest(),t=(0,r.enumValues)(o.DemoErrorType);for(const r of t)r in n&&e.applyChange({kind:"remove",path:["errors",r]})},n.getBoardNode=e=>(0,n.getStatementNode)(e,s.isBoardNode),n.getStatementNode=(e,n)=>{const t=e.getLatest();if((0,i.isSourceFileNode)(t))return t.statements.find(n)},n.getComponentBoards=(e,t)=>e.filter((e=>{var r;return null===(r=e.components)||void 0===r?void 0:r.some((e=>(0,n.getComponentRef)(e.filePath,e.exportName)===t))})),n.isBoardPath=e=>e.endsWith(".board.ts")||e.endsWith(".board.tsx")},93673:(e,n,t)=>{e.exports=t(26427)},98066:(e,n,t)=>{e.exports=t(3092)},26904:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;const r=t(5163);var o=t(59320);Object.defineProperty(n,"default",{enumerable:!0,get:function(){return r.__importDefault(o).default}}),r.__exportStar(t(59320),n)},59320:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.simulationElementRects=n.simulationPreviewDataManager=n.EXCLUDE_EDITING_TRANSFORMERS_QUERY_FLAG=n.previewEnv=void 0;const r=t(5163),o=t(93849),i=r.__importStar(t(32510)),s=t(5689),a=r.__importStar(t(93104)),c=r.__importDefault(t(25447)),l=r.__importDefault(t(93208)),d=r.__importDefault(t(1529)),u=r.__importDefault(t(7967)),p=r.__importStar(t(2206)),h=r.__importDefault(t(93673)),f=r.__importDefault(t(73561)),m=r.__importDefault(t(8746));n.previewEnv=new o.Environment("preview","iframe","multi",[a.codeExecutionRenderer]),n.EXCLUDE_EDITING_TRANSFORMERS_QUERY_FLAG="excludeEditingTransformers";const g=o.Service.withType().defineEntity(n.previewEnv),y=(0,i.defineTwoWayResource)().defineEntity(s.mainEnv);n.simulationPreviewDataManager=(0,i.defineOneWayResource)().defineEntity(p.processingEnv),n.simulationElementRects=(0,i.defineOneWayResource)().defineEntity(n.previewEnv);const _=(0,i.defineOneWayResource)().defineEntity(n.previewEnv),b=(0,i.defineOneWayResource)().defineEntity(n.previewEnv);n.default=new o.Feature({id:"simulationPreview",dependencies:[a.default.asDependency,o.COM.asDependency,l.default.asDependency,p.default.asDependency,c.default.asDependency,i.default.asDependency,h.default.asDependency,d.default.asDependency,f.default.asDependency,u.default.asDependency,m.default.asDependency],api:{simulationWindowController:g.allowRemoteAccess((0,o.declareComEmitter)("addCanvasIsEmptyListener","removeCanvasIsEmptyListener")),previewController:o.Service.withType().defineEntity(n.previewEnv).allowRemoteAccess((0,o.declareComEmitter)("subscribe","unsubscribe")),previewRenderers:o.MapSlot.withType().defineEntity(n.previewEnv),demoErrorManager:h.default.api.demoErrorManager.defineConsumer(n.previewEnv),consoleResourceManager:y,consoleResourceManagerPreview:y.defineConsumer(n.previewEnv),globalPreviewData:o.Slot.withType().defineEntity(p.processingEnv),simulationElementRects:n.simulationElementRects,simulationPreviewDataManager:n.simulationPreviewDataManager,canvasSizeManager:_,canvasMarginManager:b,previewWindowEventEmitter:o.Service.withType().defineEntity(n.previewEnv).allowRemoteAccess((0,o.declareComEmitter)("subscribe","unsubscribe")),previewHostService:o.Service.withType().defineEntity(s.mainEnv),boardInitializers:o.Slot.withType().defineEntity(n.previewEnv),rendererConfig:new o.Config({persistStateOnChange:!0})}})},23926:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163),o=t(93849),i=r.__importDefault(t(78435)),s=t(60814),a=t(12535),c=t(98066),l=r.__importStar(t(59320)),d=t(80673),u=t(24100),p=t(30398),h=t(30259),f=t(2206),m=t(20049),g=t(25173),y=t(98804),_=t(12061),b=t(91570),v=t(21636),w=t(62202),E=t(89457),S=t(70669),T=t(12381);class C extends Error{constructor(){super(...arguments),this.name="FormatError"}}class k extends Error{constructor(){super(...arguments),this.name="CompilationError"}}l.default.setup(l.previewEnv,(({run:e,onDispose:n,consoleResourceManager:t,previewRenderers:r,simulationPreviewDataManager:I,simulationElementRects:R,canvasMarginManager:O,canvasSizeManager:P,boardInitializers:D,rendererConfig:{persistStateOnChange:M}},{codeExecution:{windowController:x,createRenderer:N,resolver:A,windowEventEmitter:F,executionResourceFactoryRenderer:L},simulationCapabilities:{demoErrorManager:j},COM:{communication:B},project:{pluggableProjectConfig:U},shortcuts:{shortcutStrategyManager:W}})=>{const H=window===window.parent,q=new URLSearchParams(window.location.search.slice(1)).get(l.EXCLUDE_EDITING_TRANSFORMERS_QUERY_FLAG),V=!!q&&"true"===q,z=U.consume({}),$=j.consume({}),G=t.consume({resourceConstructor:h.ConsoleResource}),K=O.provide({handler:{provide:()=>({value:null})},resourceConstructor:s.JSONResource}),Y=P.provide({handler:{provide:()=>({value:null})},resourceConstructor:s.JSONResource});n((0,g.blockNativeSaveAs)());const X=z.get(f.PROJECT_CONFIG_NAME,l.previewEnv),J=R.provide({handler:{provide:()=>({value:{}})},resourceConstructor:s.JSONResource}),Q=new p.CanvasResourcesSyncer(K,Y,J);n((()=>Q.dispose()));const Z={},ee=J.get(Z);n((()=>ee.release(Z)));const ne=I.consume({resourceConstructor:s.JSONResource}).get(B.getEnvironmentId(),l.previewEnv),te=new u.SimulationPreviewController(ne,r),re=B.getEnvironmentId();H||n((0,y.captureConsole)(G,re));const oe=new m.UncaughtErrorHandler({demoErrorRM:$,consoleRM:G,previewEnvironmentId:re,isMainWindow:H}),ie=te.getBoardPath(),se={async renderExport(){let e=!1;oe.setBoardPath(ie);const t={},r=$.get(ie,t),o=H?null:G.get(re,t),l=new ResizeObserver((()=>{const e=x.getStageDimensions(),n=ee.getLatest();(0,i.default)(n,e)||ee.applyChange((0,s.fullChange)({canvas:e.canvas,window:e.window}))}));l.observe(document.body),n((()=>l.disconnect()));const{resolvedRequest:u}=await A.resolveFromFile(ie,"react"),{canPersistState:p,registerCanPersistState:h}=(0,T.makeCanPersistState)();try{const t=await N({entries:["react","react-dom"],manuallyRequiredEntries:[E.rawReactIs,(0,E.requireRawReactDevtools)(u),S.rawReactRefresh],excludeEditingTransformers:V,beforeRender:({canvas:e})=>{l.observe(e),Q.start(e)},ensureRenderable:e=>{try{return(0,a.getBoardFromModule)(e)}catch(e){throw new C((0,b.toError)(e).message)}},onModuleSystemReady:e=>((0,E.initializeReactDevtools)(e.requireModule),M&&(0,S.initializeReactRefresh)(e.requireModule),D.stream((e=>e())),(0,a.addReactToWindow)(A,ie,e.requireModule).catch((e=>{throw new k((0,b.toError)(e).message)}))),environmentVariables:{NODE_ENV:"development",refresh_enabled:"refresh_enabled"}});n((()=>t.cleanup(ie)));const i=()=>{null==o||o.clear(),(0,c.resetDemoErrors)(r),null==o||o.sendMessage(d.CodeExecutionMessageType.previewRenderStart),null==f||f(),f=void 0,null==s||s(),s=void 0,null==m||m(),m=void 0};let s,f,m;const g=(0,b.enforceSequentialExecution)((async()=>{const n=M&&p();await Promise.all([r.ready,null==o?void 0:o.ready,n?void 0:t.cleanup(ie)]),i();const l=t.getExecutionResource(ie);if(void 0===f&&(f=(0,a.registerToFileChanges)(l,t.moduleSystem,g)),void 0===s){const e=(e,n)=>{n.has(l)&&g()};L.subscribeToAny(e),s=()=>{L.unsubscribeFromAny(e)}}void 0===m&&({unsubscribe:m}=h(l));try{const{render:o,requireRenderable:i}=await t.prepareRender(ie,l),s=i();x.isCanvasEmpty()||!n?await o(s):(0,S.refresh)(),e=!0,(0,c.clearDemoError)(r,c.DemoErrorType.RuntimeError)}catch(n){e=!1,n instanceof C?(0,c.setDemoError)(r,c.DemoErrorType.FormatError,n.message):n instanceof k?(0,c.setDemoError)(r,c.DemoErrorType.CompilationError,n.message):(n instanceof Error&&(0,c.setDemoError)(r,c.DemoErrorType.RuntimeError,n.message),null==o||o.sendMessage(d.CodeExecutionMessageType.consoleError,(0,b.toError)(n).message||v.content.unknownRuntimeError))}finally{x.getStage()&&!e&&await t.cleanup(ie)}}));await g()}catch(n){if(e=!1,n instanceof C)(0,c.setDemoError)(r,c.DemoErrorType.FormatError,n.message);else{if(!(n instanceof k))throw n instanceof Error&&(0,c.setDemoError)(r,c.DemoErrorType.RuntimeError,n.message),n;(0,c.setDemoError)(r,c.DemoErrorType.CompilationError,n.message)}}}},ae="compiled";r.register(ae,se);const ce=W.consume({resourceConstructor:w.ShortcutStrategyResource}).get({},l.default),le=e=>(0,w.performShortcutStrategy)(e,ce);return(0,_.isIsolatedRender)()||window.addEventListener("keydown",le),n((()=>{ce.release(l.default),window.removeEventListener("keydown",le)})),e((async()=>{const e={},n=$.get(ie,e);await Promise.all([X.ready,n.ready]),te.setRenderer(ae),te.renderSimulation().catch((e=>{(0,c.setDemoError)(n,c.DemoErrorType.CompilationError,(0,b.stringifyErrorStack)(e)),(0,o.reportError)(e)})).finally((()=>n.release(e)))})),{simulationElementRects:J,simulationWindowController:x,previewController:te,demoErrorManager:$,simulationPreviewData:ne,consoleResourceManagerPreview:G,canvasMarginManager:K,canvasSizeManager:Y,previewWindowEventEmitter:F}}))},25173:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.blockNativeSaveAs=void 0,n.blockNativeSaveAs=function(){const e=e=>(e=>(e.ctrlKey||e.metaKey)&&"s"===e.key)(e)&&e.preventDefault();return window.addEventListener("keydown",e),()=>window.removeEventListener("keydown",e)}},12381:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.makeCanPersistState=void 0,n.makeCanPersistState=function(){let e=!1,n=!1;return{registerCanPersistState(t){e=!1;const r=t=>{if(!n)for(const r of[...t.changed,...t.added]){const t=r.getId().filePath;if(null==t?void 0:t.endsWith(".board.tsx"))return void(e=!0);const o=null==r?void 0:r.getLatest();if("string"==typeof o&&o.search(/extends .*Component/)>=0)return void(n=!0)}};return t.subscribe(r),{unsubscribe:()=>t.unsubscribe(r)}},canPersistState:()=>!e&&!n}}},30398:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.CanvasResourcesSyncer=void 0;const r=t(60814),o=t(91570);class i extends o.AnimationFrameScheduler{constructor(e,n,t){super(),this.canvasMarginResource=e.get({},this),this.canvasSizeResource=n.get({},this),this.simulationElementRects=t.get({},this)}onDispose(){this.canvasMarginResource.release(this),this.canvasSizeResource.release(this)}onAnimationFrame(e){if(null===e.offsetParent)return;const{marginTop:n,marginRight:t,marginBottom:o,marginLeft:i}=getComputedStyle(e),{height:s,width:a}=e.getBoundingClientRect(),c=this.canvasMarginResource.getLatest(),l={top:Math.ceil(parseInt(n,10)),bottom:Math.ceil(parseInt(o,10)),left:Math.ceil(parseInt(i,10)),right:Math.ceil(parseInt(t,10))},d=!(0,r.jsonEquals)(c,l);d&&this.canvasMarginResource.applyChange((0,r.fullChange)(l));const u=this.canvasSizeResource.getLatest(),p={height:s,width:a},h=!(0,r.jsonEquals)(u,p);h&&this.canvasSizeResource.applyChange((0,r.fullChange)(p)),(d||h)&&this.simulationElementRects.applyChange((0,r.fullChange)({...this.simulationElementRects.getLatest(),canvas:e.getBoundingClientRect()}))}}n.CanvasResourcesSyncer=i},98804:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.captureConsole=void 0;const r=t(91832),o=t(91570),i=e=>{var n;return null!==(n=e.ready)&&void 0!==n?n:Promise.resolve()};function s(e){if("string"==typeof e)return e;if(e instanceof Error)return(0,o.stringifyErrorStack)(e);try{return JSON.stringify(e,null,4)}catch(n){return String(e)}}function a(e){return e.map(s).join(" ")}n.captureConsole=function(e,n){const{log:t,error:s,info:c,warn:l}=console,d={},u=e.get(n,d);return console.log=(...e)=>{i(u).then((()=>{u.sendMessage(r.CodeExecutionMessageType.consoleLog,a(e))})).catch(o.reportError),t(...e)},console.error=(...e)=>{i(u).then((()=>{u.sendMessage(r.CodeExecutionMessageType.consoleError,a(e))})).catch(o.reportError),s(...e)},console.info=(...e)=>{i(u).then((()=>{u.sendMessage(r.CodeExecutionMessageType.consoleInfo,a(e))})).catch(o.reportError),c(...e)},console.warn=(...e)=>{i(u).then((()=>{u.sendMessage(r.CodeExecutionMessageType.consoleWarn,a(e))})).catch(o.reportError),l(...e)},()=>{console.log=t,console.error=s,console.info=c,console.warn=l,u.release(d)}}},21636:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.content=void 0,n.content={unknownRuntimeError:"Something went wrong while rendering your component. Check the console for more information."}},89457:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.initializeReactDevtools=n.rawReactIs=n.requireRawReactDevtools=n.reactDevtoolsSpecifier=void 0,n.reactDevtoolsSpecifier="react-devtools-inline",n.requireRawReactDevtools=function(e){return{name:n.reactDevtoolsSpecifier,contents:t(3654).Z,dependencies:[{specifier:"react-is",resolvedRequest:"react-is"},{specifier:"react",resolvedRequest:e}]}},n.rawReactIs={name:"react-is",contents:t(98024).Z},n.initializeReactDevtools=function(e){const{initialize:t}=e(n.reactDevtoolsSpecifier);t(window)}},70669:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.refresh=n.initializeReactRefresh=n.rawReactRefresh=void 0;const r="react-refresh/runtime";let o;n.rawReactRefresh={name:r,contents:t(51544).Z},n.initializeReactRefresh=function(e){if(void 0!==o)return;const{injectIntoGlobalHook:n,performReactRefresh:t}=e(r);o=t,n(window)},n.refresh=function(){if(void 0===o)throw new Error("Please call `initializeReactRefresh(...) before calling update");o()}},30259:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.ConsoleResource=void 0;const r=t(60814);class o extends r.Resource{sendMessage(e,n,t){this.applyChange({kind:"add",path:["messages"],value:{type:e,message:n,additionalInfo:t}})}clear(){this.applyChange({kind:"replace",path:["messages"],value:[]})}}n.ConsoleResource=o},24100:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.SimulationPreviewController=void 0;const r=t(53433),o=t(93849);n.SimulationPreviewController=class{constructor(e,n){this.previewData=e,this.renderers=n,this.events=new r.EventEmitter;const t=new URLSearchParams(window.location.search).get("boardPath");if(!t)throw new Error("cannot init preview without providing boardPath");this.boardPath=t,e.subscribe((()=>{this.renderSimulation().catch(o.reportError)}))}getBoardPath(){return this.boardPath}setRenderer(e){this.rendererType=e}async renderSimulation(){this.events.emit("event",{type:"beforeRender"}),this.previewData.isReady()||await this.previewData.ready;try{const e=this.renderers.get(this.rendererType);if(!e)throw new Error(`Unable to find renderer ${this.rendererType} for the preview`);await e.renderExport()}finally{this.events.emit("event",{type:"afterRender"})}}subscribe(e){this.events.subscribe("event",e)}unsubscribe(e){this.events.unsubscribe("event",e)}}},20049:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.UncaughtErrorHandler=void 0;const r=t(91570),o=t(98066),i=t(91832),s=t(21636);n.UncaughtErrorHandler=class{constructor(e){this.handleErrorEvent=e=>{const n=(0,r.stringifyErrorStack)(e.error)||s.content.unknownRuntimeError;this.addErrorToSimulation(n).catch(r.noop)},this.handlePromiseRejectionEvent=e=>{const n=(0,r.toError)(e.reason).message||s.content.unknownRuntimeError;this.addErrorToSimulation(n).catch(r.noop),this.addErrorToConsoleResourceIfNeeded(n).catch(r.noop)},this.demoErrorRM=e.demoErrorRM,this.consoleRM=e.consoleRM,this.previewEnvironmentId=e.previewEnvironmentId,this.isMainWindow=e.isMainWindow,window.addEventListener("error",this.handleErrorEvent),window.addEventListener("unhandledrejection",this.handlePromiseRejectionEvent)}setBoardPath(e){this.boardPath=e}async addErrorToSimulation(e){if(this.boardPath){const n=await this.demoErrorRM.getReady(this.boardPath);(0,o.setDemoError)(n,o.DemoErrorType.RuntimeError,e)}}async addErrorToConsoleResourceIfNeeded(e){this.isMainWindow||(await this.consoleRM.getReady(this.previewEnvironmentId)).sendMessage(i.CodeExecutionMessageType.consoleError,e)}}},80673:(e,n)=>{"use strict";var t;Object.defineProperty(n,"__esModule",{value:!0}),n.ENVIRONMENT_PROPERTIES_KEYS=n.CodeExecutionMessageType=n.SIMULATION_CANVAS_CLASS_NAME=void 0,n.SIMULATION_CANVAS_CLASS_NAME="simulationCanvas",(t=n.CodeExecutionMessageType||(n.CodeExecutionMessageType={}))[t.consoleError=0]="consoleError",t[t.consoleWarn=1]="consoleWarn",t[t.consoleLog=2]="consoleLog",t[t.consoleInfo=3]="consoleInfo",t[t.previewRenderStart=4]="previewRenderStart",n.ENVIRONMENT_PROPERTIES_KEYS=["windowHeight","windowWidth","windowBackgroundColor","canvasHeight","canvasWidth","canvasBackgroundColor","canvasMargin","canvasPadding"]},91832:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163);r.__exportStar(t(31705),n),r.__exportStar(t(80673),n)},31705:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0})},4511:(e,n,t)=>{e.exports=t(26904)},17362:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;const r=t(5163);r.__exportStar(t(44069),n);var o=t(44069);Object.defineProperty(n,"default",{enumerable:!0,get:function(){return r.__importDefault(o).default}})},44069:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(93849),o=t(5689);n.default=new r.Feature({id:"storage",dependencies:[],api:{localStorageService:r.Service.withType().defineEntity(o.mainEnv),sessionStorageService:r.Service.withType().defineEntity(o.mainEnv)}})},83654:(e,n,t)=>{e.exports=t(17362)},64578:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163),o=t(93849),i=r.__importDefault(t(45059)),s=r.__importDefault(t(33142)),a=r.__importDefault(t(7959)),c=r.__importDefault(t(23719)),l=r.__importDefault(t(18380)),d=r.__importStar(t(43934)),u=r.__importDefault(t(2618)),p=r.__importStar(t(30383)),h=r.__importDefault(t(83260)),f=r.__importDefault(t(97569)),m=r.__importDefault(t(4511)),g=r.__importDefault(t(20471)),y=r.__importDefault(t(82039)),_=r.__importDefault(t(82983)),b=t(32510),v=(0,b.defineComputedResource)().defineEntity(d.processingEnv);n.default=new o.Feature({id:"stylable-playground",dependencies:[i.default.asDependency,s.default.asDependency,f.default.asDependency,a.default.asDependency,l.default.asDependency,g.default.asDependency,y.default.asDependency,_.default.asDependency,c.default.asDependency,d.default.asDependency,u.default.asDependency,m.default.asDependency,p.StylableCompiler.asDependency,p.default.asDependency,p.StylableLanguageService.asDependency,h.default.asDependency],api:{compiled:v,stylablePlaygroundOptions:new o.Config({key:"default value"}),stylableMetaManager:(0,b.defineComputedResource)().defineEntity(d.processingEnv)}})},72334:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.StylableCompiler=n.StylableLanguageService=n.default=void 0;const r=t(5163);var o=t(70286);Object.defineProperty(n,"default",{enumerable:!0,get:function(){return r.__importDefault(o).default}});var i=t(13427);Object.defineProperty(n,"StylableLanguageService",{enumerable:!0,get:function(){return r.__importDefault(i).default}}),r.__exportStar(t(70286),n);var s=t(84081);Object.defineProperty(n,"StylableCompiler",{enumerable:!0,get:function(){return r.__importDefault(s).default}})},84081:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163),o=t(93849),i=t(2206),s=r.__importDefault(t(25447)),a=r.__importDefault(t(93104)),c=r.__importDefault(t(70286));n.default=new o.Feature({id:"stylableCompiler",dependencies:[c.default.asDependency,s.default.asDependency,a.default.asDependency],api:{onProcessSlot:o.Slot.withType().defineEntity(i.processingEnv)}})},13427:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163),o=t(93849),i=r.__importStar(t(2206)),s=r.__importDefault(t(83341)),a=r.__importDefault(t(70286));n.default=new o.Feature({id:"stylableLanguageService",dependencies:[i.default.asDependency,s.default.asDependency,a.default.asDependency],api:{stylable:o.Service.withType().defineEntity(i.processingEnv)}})},70286:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163),o=r.__importDefault(t(93104)),i=t(93849),s=r.__importStar(t(2206)),a=r.__importDefault(t(82026));n.default=new i.Feature({id:"stylable",dependencies:[o.default.asDependency,s.default.asDependency,a.default.asDependency],api:{createStylable:i.Service.withType().defineEntity(s.processingEnv),createCalcDepthContext:i.Service.withType().defineEntity(s.processingEnv)}})},30383:(e,n,t)=>{e.exports=t(72334)},94998:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;const r=t(5163);var o=t(30600);Object.defineProperty(n,"default",{enumerable:!0,get:function(){return r.__importDefault(o).default}}),r.__exportStar(t(30600),n)},30600:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.ANALYZE_FILES_MARK=void 0;const r=t(5163),o=t(93849),i=r.__importDefault(t(89111)),s=r.__importStar(t(2206)),a=r.__importDefault(t(58729)),c=r.__importStar(t(32510)),l=r.__importDefault(t(93104)),d=r.__importDefault(t(83260)),u=t(5689),p=o.Config.withType().defineEntity({maxWorkTime:130,minSleepTime:50,changeBufferTime:2e3,splitPerFiles:100});n.ANALYZE_FILES_MARK="ANALYZE_FILES_MARK";const h=(0,c.defineIncrementalComputedResource)().defineEntity(s.processingEnv),f=(0,c.defineOneWayResource)().defineEntity(s.processingEnv);n.default=new o.Feature({id:"typescriptAssets",dependencies:[i.default.asDependency,s.default.asDependency,c.default.asDependency,a.default.asDependency,l.default.asDependency,d.default.asDependency],api:{assetsReevaluateService:o.Service.withType().defineEntity(s.processingEnv).allowRemoteAccess(),assetTaggerSlots:o.Slot.withType().defineEntity(s.processingEnv),assets:h,assetsMain:h.defineConsumer(u.mainEnv),openAssets:f,openAssetsMain:f.defineConsumer(u.mainEnv),componentsDiscoveryConfig:s.default.api.pluggableProjectConfig.entry({},"componentsDiscovery"),assetDiscoveryConfig:p}})},71815:(e,n,t)=>{e.exports=t(94998)},97607:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;const r=t(5163);r.__exportStar(t(59237),n);var o=t(59237);Object.defineProperty(n,"default",{enumerable:!0,get:function(){return r.__importDefault(o).default}})},59237:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.workerTranspilerEnv=n.tsWebWorkerEnvName=void 0;const r=t(5163),o=t(93849),i=r.__importStar(t(2206)),s=r.__importDefault(t(25447)),a=r.__importDefault(t(93104)),c=r.__importDefault(t(89111)),l=r.__importDefault(t(19608));n.tsWebWorkerEnvName="ts-webworker",n.workerTranspilerEnv=new o.Environment(n.tsWebWorkerEnvName,"webworker","multi"),n.default=new o.Feature({id:"typescriptCompiler",dependencies:[o.COM.asDependency,i.default.asDependency,s.default.asDependency,a.default.asDependency,c.default.asDependency,l.default.asDependency],api:{transformersController:o.Service.withType().defineEntity(i.processingEnv)},context:{processingContext:i.processingEnv.withContext()}})},38055:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163),o=t(93104),i=r.__importStar(t(14879));r.__importDefault(t(59237)).default.setup(o.codeExecutionRenderer,((e,{codeExecution:{injectedLibraries:n}})=>{n.register("@wixc3/typescript-compiler-feature/dist/preview/error-renderer",i)}))},14879:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.createErrorRenderer=void 0;const r=t(68834);n.createErrorRenderer=e=>{const n=n=>e.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"currentColor",viewBox:"0 0 24 24",...n},e.createElement("path",{d:"M8.08659624,16.8128987 C9.02445082,17.5561586 10.2103931,18 11.5,18 C14.5375661,18 17,15.5375661 17,12.5 C17,11.2103931 16.5561586,10.0244508 15.8128987,9.08659624 L8.08659624,16.8128987 Z M7.36202553,16.1232558 L15.1232558,8.36202553 C14.1555486,7.51400473 12.8878004,7 11.5,7 C8.46243388,7 6,9.46243388 6,12.5 C6,13.8878004 6.51400473,15.1555486 7.36202553,16.1232558 Z M11.5,19 C7.91014913,19 5,16.0898509 5,12.5 C5,8.91014913 7.91014913,6 11.5,6 C15.0898509,6 18,8.91014913 18,12.5 C18,16.0898509 15.0898509,19 11.5,19 Z"}));return function(){return e.createElement("div",{className:r.classes.root},e.createElement(n,{className:r.classes.icon}),"Error")}}},83260:(e,n,t)=>{e.exports=t(97607)},48150:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;const r=t(5163);r.__exportStar(t(17166),n);var o=t(17166);Object.defineProperty(n,"default",{enumerable:!0,get:function(){return r.__importDefault(o).default}})},17166:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163),o=t(93849),i=r.__importStar(t(2206)),s=r.__importDefault(t(83341)),a=r.__importDefault(t(25447)),c=r.__importDefault(t(93104)),l=r.__importDefault(t(58729)),d=r.__importDefault(t(73561)),u=(0,t(32510).defineComputedResource)().defineEntity(i.processingEnv);n.default=new o.Feature({id:"typescript",dependencies:[i.default.asDependency,s.default.asDependency,a.default.asDependency,c.default.asDependency,l.default.asDependency,d.default.asDependency],api:{languageIntellisense:o.Service.withType().defineEntity(i.processingEnv),editorConfig:o.Service.withType().defineEntity(i.processingEnv),formattingProjectConfig:i.default.api.pluggableProjectConfig.entry(null,"formatting"),compilationTransformers:o.Slot.withType().defineEntity(i.processingEnv),languageServices:o.Service.withType().defineEntity(i.processingEnv).allowRemoteAccess(),parsedTsConfigs:u},context:{typescriptContext:i.processingEnv.withContext()}})},89111:(e,n,t)=>{e.exports=t(48150)},73837:function(e,n,t){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;var o=t(89102);Object.defineProperty(n,"default",{enumerable:!0,get:function(){return r(o).default}})},89102:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163),o=t(93849),i=t(2206),s=r.__importDefault(t(8746));n.default=new o.Feature({id:"userApplicationServer",dependencies:[s.default.asDependency],api:{userApplicationServerInterface:o.Service.withType().defineEntity(i.processingEnv).allowRemoteAccess(),serverRootSlot:o.Slot.withType().defineEntity(i.processingEnv),applicationHandlerSlot:o.Slot.withType().defineEntity(i.processingEnv)}})},19608:(e,n,t)=>{e.exports=t(73837)},31095:function(e,n,t){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;var o=t(82745);Object.defineProperty(n,"default",{enumerable:!0,get:function(){return r(o).default}})},82745:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(5163),o=t(93849),i=r.__importStar(t(2206));n.default=new o.Feature({id:"wcsServer",dependencies:[o.COM.asDependency,o.RuntimeMetadata.asDependency,i.default.asDependency],api:{wcsServerRunningOptionsService:o.Service.withType().defineEntity(i.processingEnv).allowRemoteAccess(),wcsServerHandlerSlot:o.Slot.withType().defineEntity(i.processingEnv),httpServerPortConfig:i.default.api.pluggableProjectConfig.entry(0,"httpServerPort"),serverConfig:o.Config.withType().defineEntity({disable:!1})},context:{serverInitializer:i.processingEnv.withContext()}})},8746:(e,n,t)=>{e.exports=t(31095)},5163:(e,n,t)=>{"use strict";t.r(n),t.d(n,{__assign:()=>i,__asyncDelegator:()=>C,__asyncGenerator:()=>T,__asyncValues:()=>k,__await:()=>S,__awaiter:()=>f,__classPrivateFieldGet:()=>D,__classPrivateFieldIn:()=>x,__classPrivateFieldSet:()=>M,__createBinding:()=>g,__decorate:()=>a,__esDecorate:()=>l,__exportStar:()=>y,__extends:()=>o,__generator:()=>m,__importDefault:()=>P,__importStar:()=>O,__makeTemplateObject:()=>I,__metadata:()=>h,__param:()=>c,__propKey:()=>u,__read:()=>b,__rest:()=>s,__runInitializers:()=>d,__setFunctionName:()=>p,__spread:()=>v,__spreadArray:()=>E,__spreadArrays:()=>w,__values:()=>_});var r=function(e,n){return r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(e[t]=n[t])},r(e,n)};function o(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Class extends value "+String(n)+" is not a constructor or null");function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)}var i=function(){return i=Object.assign||function(e){for(var n,t=1,r=arguments.length;t<r;t++)for(var o in n=arguments[t])Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o]);return e},i.apply(this,arguments)};function s(e,n){var t={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&n.indexOf(r)<0&&(t[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var o=0;for(r=Object.getOwnPropertySymbols(e);o<r.length;o++)n.indexOf(r[o])<0&&Object.prototype.propertyIsEnumerable.call(e,r[o])&&(t[r[o]]=e[r[o]])}return t}function a(e,n,t,r){var o,i=arguments.length,s=i<3?n:null===r?r=Object.getOwnPropertyDescriptor(n,t):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,n,t,r);else for(var a=e.length-1;a>=0;a--)(o=e[a])&&(s=(i<3?o(s):i>3?o(n,t,s):o(n,t))||s);return i>3&&s&&Object.defineProperty(n,t,s),s}function c(e,n){return function(t,r){n(t,r,e)}}function l(e,n,t,r,o,i){function s(e){if(void 0!==e&&"function"!=typeof e)throw new TypeError("Function expected");return e}for(var a,c=r.kind,l="getter"===c?"get":"setter"===c?"set":"value",d=!n&&e?r.static?e:e.prototype:null,u=n||(d?Object.getOwnPropertyDescriptor(d,r.name):{}),p=!1,h=t.length-1;h>=0;h--){var f={};for(var m in r)f[m]="access"===m?{}:r[m];for(var m in r.access)f.access[m]=r.access[m];f.addInitializer=function(e){if(p)throw new TypeError("Cannot add initializers after decoration has completed");i.push(s(e||null))};var g=(0,t[h])("accessor"===c?{get:u.get,set:u.set}:u[l],f);if("accessor"===c){if(void 0===g)continue;if(null===g||"object"!=typeof g)throw new TypeError("Object expected");(a=s(g.get))&&(u.get=a),(a=s(g.set))&&(u.set=a),(a=s(g.init))&&o.push(a)}else(a=s(g))&&("field"===c?o.push(a):u[l]=a)}d&&Object.defineProperty(d,r.name,u),p=!0}function d(e,n,t){for(var r=arguments.length>2,o=0;o<n.length;o++)t=r?n[o].call(e,t):n[o].call(e);return r?t:void 0}function u(e){return"symbol"==typeof e?e:"".concat(e)}function p(e,n,t){return"symbol"==typeof n&&(n=n.description?"[".concat(n.description,"]"):""),Object.defineProperty(e,"name",{configurable:!0,value:t?"".concat(t," ",n):n})}function h(e,n){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(e,n)}function f(e,n,t,r){return new(t||(t=Promise))((function(o,i){function s(e){try{c(r.next(e))}catch(e){i(e)}}function a(e){try{c(r.throw(e))}catch(e){i(e)}}function c(e){var n;e.done?o(e.value):(n=e.value,n instanceof t?n:new t((function(e){e(n)}))).then(s,a)}c((r=r.apply(e,n||[])).next())}))}function m(e,n){var t,r,o,i,s={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return i={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function a(a){return function(c){return function(a){if(t)throw new TypeError("Generator is already executing.");for(;i&&(i=0,a[0]&&(s=0)),s;)try{if(t=1,r&&(o=2&a[0]?r.return:a[0]?r.throw||((o=r.return)&&o.call(r),0):r.next)&&!(o=o.call(r,a[1])).done)return o;switch(r=0,o&&(a=[2&a[0],o.value]),a[0]){case 0:case 1:o=a;break;case 4:return s.label++,{value:a[1],done:!1};case 5:s.label++,r=a[1],a=[0];continue;case 7:a=s.ops.pop(),s.trys.pop();continue;default:if(!((o=(o=s.trys).length>0&&o[o.length-1])||6!==a[0]&&2!==a[0])){s=0;continue}if(3===a[0]&&(!o||a[1]>o[0]&&a[1]<o[3])){s.label=a[1];break}if(6===a[0]&&s.label<o[1]){s.label=o[1],o=a;break}if(o&&s.label<o[2]){s.label=o[2],s.ops.push(a);break}o[2]&&s.ops.pop(),s.trys.pop();continue}a=n.call(e,s)}catch(e){a=[6,e],r=0}finally{t=o=0}if(5&a[0])throw a[1];return{value:a[0]?a[1]:void 0,done:!0}}([a,c])}}}var g=Object.create?function(e,n,t,r){void 0===r&&(r=t);var o=Object.getOwnPropertyDescriptor(n,t);o&&!("get"in o?!n.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return n[t]}}),Object.defineProperty(e,r,o)}:function(e,n,t,r){void 0===r&&(r=t),e[r]=n[t]};function y(e,n){for(var t in e)"default"===t||Object.prototype.hasOwnProperty.call(n,t)||g(n,e,t)}function _(e){var n="function"==typeof Symbol&&Symbol.iterator,t=n&&e[n],r=0;if(t)return t.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(n?"Object is not iterable.":"Symbol.iterator is not defined.")}function b(e,n){var t="function"==typeof Symbol&&e[Symbol.iterator];if(!t)return e;var r,o,i=t.call(e),s=[];try{for(;(void 0===n||n-- >0)&&!(r=i.next()).done;)s.push(r.value)}catch(e){o={error:e}}finally{try{r&&!r.done&&(t=i.return)&&t.call(i)}finally{if(o)throw o.error}}return s}function v(){for(var e=[],n=0;n<arguments.length;n++)e=e.concat(b(arguments[n]));return e}function w(){for(var e=0,n=0,t=arguments.length;n<t;n++)e+=arguments[n].length;var r=Array(e),o=0;for(n=0;n<t;n++)for(var i=arguments[n],s=0,a=i.length;s<a;s++,o++)r[o]=i[s];return r}function E(e,n,t){if(t||2===arguments.length)for(var r,o=0,i=n.length;o<i;o++)!r&&o in n||(r||(r=Array.prototype.slice.call(n,0,o)),r[o]=n[o]);return e.concat(r||Array.prototype.slice.call(n))}function S(e){return this instanceof S?(this.v=e,this):new S(e)}function T(e,n,t){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var r,o=t.apply(e,n||[]),i=[];return r={},s("next"),s("throw"),s("return"),r[Symbol.asyncIterator]=function(){return this},r;function s(e){o[e]&&(r[e]=function(n){return new Promise((function(t,r){i.push([e,n,t,r])>1||a(e,n)}))})}function a(e,n){try{(t=o[e](n)).value instanceof S?Promise.resolve(t.value.v).then(c,l):d(i[0][2],t)}catch(e){d(i[0][3],e)}var t}function c(e){a("next",e)}function l(e){a("throw",e)}function d(e,n){e(n),i.shift(),i.length&&a(i[0][0],i[0][1])}}function C(e){var n,t;return n={},r("next"),r("throw",(function(e){throw e})),r("return"),n[Symbol.iterator]=function(){return this},n;function r(r,o){n[r]=e[r]?function(n){return(t=!t)?{value:S(e[r](n)),done:!1}:o?o(n):n}:o}}function k(e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var n,t=e[Symbol.asyncIterator];return t?t.call(e):(e=_(e),n={},r("next"),r("throw"),r("return"),n[Symbol.asyncIterator]=function(){return this},n);function r(t){n[t]=e[t]&&function(n){return new Promise((function(r,o){!function(e,n,t,r){Promise.resolve(r).then((function(n){e({value:n,done:t})}),n)}(r,o,(n=e[t](n)).done,n.value)}))}}}function I(e,n){return Object.defineProperty?Object.defineProperty(e,"raw",{value:n}):e.raw=n,e}var R=Object.create?function(e,n){Object.defineProperty(e,"default",{enumerable:!0,value:n})}:function(e,n){e.default=n};function O(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)"default"!==t&&Object.prototype.hasOwnProperty.call(e,t)&&g(n,e,t);return R(n,e),n}function P(e){return e&&e.__esModule?e:{default:e}}function D(e,n,t,r){if("a"===t&&!r)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof n?e!==n||!r:!n.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===t?r:"a"===t?r.call(e):r?r.value:n.get(e)}function M(e,n,t,r,o){if("m"===r)throw new TypeError("Private method is not writable");if("a"===r&&!o)throw new TypeError("Private accessor was defined without a setter");if("function"==typeof n?e!==n||!o:!n.has(e))throw new TypeError("Cannot write private member to an object whose class did not declare it");return"a"===r?o.call(e,t):o?o.value=t:n.set(e,t),t}function x(e,n){if(null===n||"object"!=typeof n&&"function"!=typeof n)throw new TypeError("Cannot use 'in' operator on non-object");return"function"==typeof e?n===e:e.has(n)}},43368:(e,n,t)=>{"use strict";const r=t(95766),o=t(62333),i="function"==typeof Symbol&&"function"==typeof Symbol.for?Symbol.for("nodejs.util.inspect.custom"):null;n.Buffer=c,n.SlowBuffer=function(e){return+e!=e&&(e=0),c.alloc(+e)},n.INSPECT_MAX_BYTES=50;const s=2147483647;function a(e){if(e>s)throw new RangeError('The value "'+e+'" is invalid for option "size"');const n=new Uint8Array(e);return Object.setPrototypeOf(n,c.prototype),n}function c(e,n,t){if("number"==typeof e){if("string"==typeof n)throw new TypeError('The "string" argument must be of type string. Received type number');return u(e)}return l(e,n,t)}function l(e,n,t){if("string"==typeof e)return function(e,n){if("string"==typeof n&&""!==n||(n="utf8"),!c.isEncoding(n))throw new TypeError("Unknown encoding: "+n);const t=0|m(e,n);let r=a(t);const o=r.write(e,n);return o!==t&&(r=r.slice(0,o)),r}(e,n);if(ArrayBuffer.isView(e))return function(e){if(Y(e,Uint8Array)){const n=new Uint8Array(e);return h(n.buffer,n.byteOffset,n.byteLength)}return p(e)}(e);if(null==e)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof e);if(Y(e,ArrayBuffer)||e&&Y(e.buffer,ArrayBuffer))return h(e,n,t);if("undefined"!=typeof SharedArrayBuffer&&(Y(e,SharedArrayBuffer)||e&&Y(e.buffer,SharedArrayBuffer)))return h(e,n,t);if("number"==typeof e)throw new TypeError('The "value" argument must not be of type number. Received type number');const r=e.valueOf&&e.valueOf();if(null!=r&&r!==e)return c.from(r,n,t);const o=function(e){if(c.isBuffer(e)){const n=0|f(e.length),t=a(n);return 0===t.length||e.copy(t,0,0,n),t}return void 0!==e.length?"number"!=typeof e.length||X(e.length)?a(0):p(e):"Buffer"===e.type&&Array.isArray(e.data)?p(e.data):void 0}(e);if(o)return o;if("undefined"!=typeof Symbol&&null!=Symbol.toPrimitive&&"function"==typeof e[Symbol.toPrimitive])return c.from(e[Symbol.toPrimitive]("string"),n,t);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof e)}function d(e){if("number"!=typeof e)throw new TypeError('"size" argument must be of type number');if(e<0)throw new RangeError('The value "'+e+'" is invalid for option "size"')}function u(e){return d(e),a(e<0?0:0|f(e))}function p(e){const n=e.length<0?0:0|f(e.length),t=a(n);for(let r=0;r<n;r+=1)t[r]=255&e[r];return t}function h(e,n,t){if(n<0||e.byteLength<n)throw new RangeError('"offset" is outside of buffer bounds');if(e.byteLength<n+(t||0))throw new RangeError('"length" is outside of buffer bounds');let r;return r=void 0===n&&void 0===t?new Uint8Array(e):void 0===t?new Uint8Array(e,n):new Uint8Array(e,n,t),Object.setPrototypeOf(r,c.prototype),r}function f(e){if(e>=s)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+s.toString(16)+" bytes");return 0|e}function m(e,n){if(c.isBuffer(e))return e.length;if(ArrayBuffer.isView(e)||Y(e,ArrayBuffer))return e.byteLength;if("string"!=typeof e)throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof e);const t=e.length,r=arguments.length>2&&!0===arguments[2];if(!r&&0===t)return 0;let o=!1;for(;;)switch(n){case"ascii":case"latin1":case"binary":return t;case"utf8":case"utf-8":return $(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*t;case"hex":return t>>>1;case"base64":return G(e).length;default:if(o)return r?-1:$(e).length;n=(""+n).toLowerCase(),o=!0}}function g(e,n,t){let r=!1;if((void 0===n||n<0)&&(n=0),n>this.length)return"";if((void 0===t||t>this.length)&&(t=this.length),t<=0)return"";if((t>>>=0)<=(n>>>=0))return"";for(e||(e="utf8");;)switch(e){case"hex":return P(this,n,t);case"utf8":case"utf-8":return k(this,n,t);case"ascii":return R(this,n,t);case"latin1":case"binary":return O(this,n,t);case"base64":return C(this,n,t);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return D(this,n,t);default:if(r)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),r=!0}}function y(e,n,t){const r=e[n];e[n]=e[t],e[t]=r}function _(e,n,t,r,o){if(0===e.length)return-1;if("string"==typeof t?(r=t,t=0):t>2147483647?t=2147483647:t<-2147483648&&(t=-2147483648),X(t=+t)&&(t=o?0:e.length-1),t<0&&(t=e.length+t),t>=e.length){if(o)return-1;t=e.length-1}else if(t<0){if(!o)return-1;t=0}if("string"==typeof n&&(n=c.from(n,r)),c.isBuffer(n))return 0===n.length?-1:b(e,n,t,r,o);if("number"==typeof n)return n&=255,"function"==typeof Uint8Array.prototype.indexOf?o?Uint8Array.prototype.indexOf.call(e,n,t):Uint8Array.prototype.lastIndexOf.call(e,n,t):b(e,[n],t,r,o);throw new TypeError("val must be string, number or Buffer")}function b(e,n,t,r,o){let i,s=1,a=e.length,c=n.length;if(void 0!==r&&("ucs2"===(r=String(r).toLowerCase())||"ucs-2"===r||"utf16le"===r||"utf-16le"===r)){if(e.length<2||n.length<2)return-1;s=2,a/=2,c/=2,t/=2}function l(e,n){return 1===s?e[n]:e.readUInt16BE(n*s)}if(o){let r=-1;for(i=t;i<a;i++)if(l(e,i)===l(n,-1===r?0:i-r)){if(-1===r&&(r=i),i-r+1===c)return r*s}else-1!==r&&(i-=i-r),r=-1}else for(t+c>a&&(t=a-c),i=t;i>=0;i--){let t=!0;for(let r=0;r<c;r++)if(l(e,i+r)!==l(n,r)){t=!1;break}if(t)return i}return-1}function v(e,n,t,r){t=Number(t)||0;const o=e.length-t;r?(r=Number(r))>o&&(r=o):r=o;const i=n.length;let s;for(r>i/2&&(r=i/2),s=0;s<r;++s){const r=parseInt(n.substr(2*s,2),16);if(X(r))return s;e[t+s]=r}return s}function w(e,n,t,r){return K($(n,e.length-t),e,t,r)}function E(e,n,t,r){return K(function(e){const n=[];for(let t=0;t<e.length;++t)n.push(255&e.charCodeAt(t));return n}(n),e,t,r)}function S(e,n,t,r){return K(G(n),e,t,r)}function T(e,n,t,r){return K(function(e,n){let t,r,o;const i=[];for(let s=0;s<e.length&&!((n-=2)<0);++s)t=e.charCodeAt(s),r=t>>8,o=t%256,i.push(o),i.push(r);return i}(n,e.length-t),e,t,r)}function C(e,n,t){return 0===n&&t===e.length?r.fromByteArray(e):r.fromByteArray(e.slice(n,t))}function k(e,n,t){t=Math.min(e.length,t);const r=[];let o=n;for(;o<t;){const n=e[o];let i=null,s=n>239?4:n>223?3:n>191?2:1;if(o+s<=t){let t,r,a,c;switch(s){case 1:n<128&&(i=n);break;case 2:t=e[o+1],128==(192&t)&&(c=(31&n)<<6|63&t,c>127&&(i=c));break;case 3:t=e[o+1],r=e[o+2],128==(192&t)&&128==(192&r)&&(c=(15&n)<<12|(63&t)<<6|63&r,c>2047&&(c<55296||c>57343)&&(i=c));break;case 4:t=e[o+1],r=e[o+2],a=e[o+3],128==(192&t)&&128==(192&r)&&128==(192&a)&&(c=(15&n)<<18|(63&t)<<12|(63&r)<<6|63&a,c>65535&&c<1114112&&(i=c))}}null===i?(i=65533,s=1):i>65535&&(i-=65536,r.push(i>>>10&1023|55296),i=56320|1023&i),r.push(i),o+=s}return function(e){const n=e.length;if(n<=I)return String.fromCharCode.apply(String,e);let t="",r=0;for(;r<n;)t+=String.fromCharCode.apply(String,e.slice(r,r+=I));return t}(r)}n.kMaxLength=s,c.TYPED_ARRAY_SUPPORT=function(){try{const e=new Uint8Array(1),n={foo:function(){return 42}};return Object.setPrototypeOf(n,Uint8Array.prototype),Object.setPrototypeOf(e,n),42===e.foo()}catch(e){return!1}}(),c.TYPED_ARRAY_SUPPORT||"undefined"==typeof console||"function"!=typeof console.error||console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."),Object.defineProperty(c.prototype,"parent",{enumerable:!0,get:function(){if(c.isBuffer(this))return this.buffer}}),Object.defineProperty(c.prototype,"offset",{enumerable:!0,get:function(){if(c.isBuffer(this))return this.byteOffset}}),c.poolSize=8192,c.from=function(e,n,t){return l(e,n,t)},Object.setPrototypeOf(c.prototype,Uint8Array.prototype),Object.setPrototypeOf(c,Uint8Array),c.alloc=function(e,n,t){return function(e,n,t){return d(e),e<=0?a(e):void 0!==n?"string"==typeof t?a(e).fill(n,t):a(e).fill(n):a(e)}(e,n,t)},c.allocUnsafe=function(e){return u(e)},c.allocUnsafeSlow=function(e){return u(e)},c.isBuffer=function(e){return null!=e&&!0===e._isBuffer&&e!==c.prototype},c.compare=function(e,n){if(Y(e,Uint8Array)&&(e=c.from(e,e.offset,e.byteLength)),Y(n,Uint8Array)&&(n=c.from(n,n.offset,n.byteLength)),!c.isBuffer(e)||!c.isBuffer(n))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(e===n)return 0;let t=e.length,r=n.length;for(let o=0,i=Math.min(t,r);o<i;++o)if(e[o]!==n[o]){t=e[o],r=n[o];break}return t<r?-1:r<t?1:0},c.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},c.concat=function(e,n){if(!Array.isArray(e))throw new TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return c.alloc(0);let t;if(void 0===n)for(n=0,t=0;t<e.length;++t)n+=e[t].length;const r=c.allocUnsafe(n);let o=0;for(t=0;t<e.length;++t){let n=e[t];if(Y(n,Uint8Array))o+n.length>r.length?(c.isBuffer(n)||(n=c.from(n)),n.copy(r,o)):Uint8Array.prototype.set.call(r,n,o);else{if(!c.isBuffer(n))throw new TypeError('"list" argument must be an Array of Buffers');n.copy(r,o)}o+=n.length}return r},c.byteLength=m,c.prototype._isBuffer=!0,c.prototype.swap16=function(){const e=this.length;if(e%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let n=0;n<e;n+=2)y(this,n,n+1);return this},c.prototype.swap32=function(){const e=this.length;if(e%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let n=0;n<e;n+=4)y(this,n,n+3),y(this,n+1,n+2);return this},c.prototype.swap64=function(){const e=this.length;if(e%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let n=0;n<e;n+=8)y(this,n,n+7),y(this,n+1,n+6),y(this,n+2,n+5),y(this,n+3,n+4);return this},c.prototype.toString=function(){const e=this.length;return 0===e?"":0===arguments.length?k(this,0,e):g.apply(this,arguments)},c.prototype.toLocaleString=c.prototype.toString,c.prototype.equals=function(e){if(!c.isBuffer(e))throw new TypeError("Argument must be a Buffer");return this===e||0===c.compare(this,e)},c.prototype.inspect=function(){let e="";const t=n.INSPECT_MAX_BYTES;return e=this.toString("hex",0,t).replace(/(.{2})/g,"$1 ").trim(),this.length>t&&(e+=" ... "),"<Buffer "+e+">"},i&&(c.prototype[i]=c.prototype.inspect),c.prototype.compare=function(e,n,t,r,o){if(Y(e,Uint8Array)&&(e=c.from(e,e.offset,e.byteLength)),!c.isBuffer(e))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof e);if(void 0===n&&(n=0),void 0===t&&(t=e?e.length:0),void 0===r&&(r=0),void 0===o&&(o=this.length),n<0||t>e.length||r<0||o>this.length)throw new RangeError("out of range index");if(r>=o&&n>=t)return 0;if(r>=o)return-1;if(n>=t)return 1;if(this===e)return 0;let i=(o>>>=0)-(r>>>=0),s=(t>>>=0)-(n>>>=0);const a=Math.min(i,s),l=this.slice(r,o),d=e.slice(n,t);for(let e=0;e<a;++e)if(l[e]!==d[e]){i=l[e],s=d[e];break}return i<s?-1:s<i?1:0},c.prototype.includes=function(e,n,t){return-1!==this.indexOf(e,n,t)},c.prototype.indexOf=function(e,n,t){return _(this,e,n,t,!0)},c.prototype.lastIndexOf=function(e,n,t){return _(this,e,n,t,!1)},c.prototype.write=function(e,n,t,r){if(void 0===n)r="utf8",t=this.length,n=0;else if(void 0===t&&"string"==typeof n)r=n,t=this.length,n=0;else{if(!isFinite(n))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");n>>>=0,isFinite(t)?(t>>>=0,void 0===r&&(r="utf8")):(r=t,t=void 0)}const o=this.length-n;if((void 0===t||t>o)&&(t=o),e.length>0&&(t<0||n<0)||n>this.length)throw new RangeError("Attempt to write outside buffer bounds");r||(r="utf8");let i=!1;for(;;)switch(r){case"hex":return v(this,e,n,t);case"utf8":case"utf-8":return w(this,e,n,t);case"ascii":case"latin1":case"binary":return E(this,e,n,t);case"base64":return S(this,e,n,t);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return T(this,e,n,t);default:if(i)throw new TypeError("Unknown encoding: "+r);r=(""+r).toLowerCase(),i=!0}},c.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};const I=4096;function R(e,n,t){let r="";t=Math.min(e.length,t);for(let o=n;o<t;++o)r+=String.fromCharCode(127&e[o]);return r}function O(e,n,t){let r="";t=Math.min(e.length,t);for(let o=n;o<t;++o)r+=String.fromCharCode(e[o]);return r}function P(e,n,t){const r=e.length;(!n||n<0)&&(n=0),(!t||t<0||t>r)&&(t=r);let o="";for(let r=n;r<t;++r)o+=J[e[r]];return o}function D(e,n,t){const r=e.slice(n,t);let o="";for(let e=0;e<r.length-1;e+=2)o+=String.fromCharCode(r[e]+256*r[e+1]);return o}function M(e,n,t){if(e%1!=0||e<0)throw new RangeError("offset is not uint");if(e+n>t)throw new RangeError("Trying to access beyond buffer length")}function x(e,n,t,r,o,i){if(!c.isBuffer(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(n>o||n<i)throw new RangeError('"value" argument is out of bounds');if(t+r>e.length)throw new RangeError("Index out of range")}function N(e,n,t,r,o){H(n,r,o,e,t,7);let i=Number(n&BigInt(4294967295));e[t++]=i,i>>=8,e[t++]=i,i>>=8,e[t++]=i,i>>=8,e[t++]=i;let s=Number(n>>BigInt(32)&BigInt(4294967295));return e[t++]=s,s>>=8,e[t++]=s,s>>=8,e[t++]=s,s>>=8,e[t++]=s,t}function A(e,n,t,r,o){H(n,r,o,e,t,7);let i=Number(n&BigInt(4294967295));e[t+7]=i,i>>=8,e[t+6]=i,i>>=8,e[t+5]=i,i>>=8,e[t+4]=i;let s=Number(n>>BigInt(32)&BigInt(4294967295));return e[t+3]=s,s>>=8,e[t+2]=s,s>>=8,e[t+1]=s,s>>=8,e[t]=s,t+8}function F(e,n,t,r,o,i){if(t+r>e.length)throw new RangeError("Index out of range");if(t<0)throw new RangeError("Index out of range")}function L(e,n,t,r,i){return n=+n,t>>>=0,i||F(e,0,t,4),o.write(e,n,t,r,23,4),t+4}function j(e,n,t,r,i){return n=+n,t>>>=0,i||F(e,0,t,8),o.write(e,n,t,r,52,8),t+8}c.prototype.slice=function(e,n){const t=this.length;(e=~~e)<0?(e+=t)<0&&(e=0):e>t&&(e=t),(n=void 0===n?t:~~n)<0?(n+=t)<0&&(n=0):n>t&&(n=t),n<e&&(n=e);const r=this.subarray(e,n);return Object.setPrototypeOf(r,c.prototype),r},c.prototype.readUintLE=c.prototype.readUIntLE=function(e,n,t){e>>>=0,n>>>=0,t||M(e,n,this.length);let r=this[e],o=1,i=0;for(;++i<n&&(o*=256);)r+=this[e+i]*o;return r},c.prototype.readUintBE=c.prototype.readUIntBE=function(e,n,t){e>>>=0,n>>>=0,t||M(e,n,this.length);let r=this[e+--n],o=1;for(;n>0&&(o*=256);)r+=this[e+--n]*o;return r},c.prototype.readUint8=c.prototype.readUInt8=function(e,n){return e>>>=0,n||M(e,1,this.length),this[e]},c.prototype.readUint16LE=c.prototype.readUInt16LE=function(e,n){return e>>>=0,n||M(e,2,this.length),this[e]|this[e+1]<<8},c.prototype.readUint16BE=c.prototype.readUInt16BE=function(e,n){return e>>>=0,n||M(e,2,this.length),this[e]<<8|this[e+1]},c.prototype.readUint32LE=c.prototype.readUInt32LE=function(e,n){return e>>>=0,n||M(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},c.prototype.readUint32BE=c.prototype.readUInt32BE=function(e,n){return e>>>=0,n||M(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},c.prototype.readBigUInt64LE=Q((function(e){q(e>>>=0,"offset");const n=this[e],t=this[e+7];void 0!==n&&void 0!==t||V(e,this.length-8);const r=n+256*this[++e]+65536*this[++e]+this[++e]*2**24,o=this[++e]+256*this[++e]+65536*this[++e]+t*2**24;return BigInt(r)+(BigInt(o)<<BigInt(32))})),c.prototype.readBigUInt64BE=Q((function(e){q(e>>>=0,"offset");const n=this[e],t=this[e+7];void 0!==n&&void 0!==t||V(e,this.length-8);const r=n*2**24+65536*this[++e]+256*this[++e]+this[++e],o=this[++e]*2**24+65536*this[++e]+256*this[++e]+t;return(BigInt(r)<<BigInt(32))+BigInt(o)})),c.prototype.readIntLE=function(e,n,t){e>>>=0,n>>>=0,t||M(e,n,this.length);let r=this[e],o=1,i=0;for(;++i<n&&(o*=256);)r+=this[e+i]*o;return o*=128,r>=o&&(r-=Math.pow(2,8*n)),r},c.prototype.readIntBE=function(e,n,t){e>>>=0,n>>>=0,t||M(e,n,this.length);let r=n,o=1,i=this[e+--r];for(;r>0&&(o*=256);)i+=this[e+--r]*o;return o*=128,i>=o&&(i-=Math.pow(2,8*n)),i},c.prototype.readInt8=function(e,n){return e>>>=0,n||M(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},c.prototype.readInt16LE=function(e,n){e>>>=0,n||M(e,2,this.length);const t=this[e]|this[e+1]<<8;return 32768&t?4294901760|t:t},c.prototype.readInt16BE=function(e,n){e>>>=0,n||M(e,2,this.length);const t=this[e+1]|this[e]<<8;return 32768&t?4294901760|t:t},c.prototype.readInt32LE=function(e,n){return e>>>=0,n||M(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},c.prototype.readInt32BE=function(e,n){return e>>>=0,n||M(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},c.prototype.readBigInt64LE=Q((function(e){q(e>>>=0,"offset");const n=this[e],t=this[e+7];void 0!==n&&void 0!==t||V(e,this.length-8);const r=this[e+4]+256*this[e+5]+65536*this[e+6]+(t<<24);return(BigInt(r)<<BigInt(32))+BigInt(n+256*this[++e]+65536*this[++e]+this[++e]*2**24)})),c.prototype.readBigInt64BE=Q((function(e){q(e>>>=0,"offset");const n=this[e],t=this[e+7];void 0!==n&&void 0!==t||V(e,this.length-8);const r=(n<<24)+65536*this[++e]+256*this[++e]+this[++e];return(BigInt(r)<<BigInt(32))+BigInt(this[++e]*2**24+65536*this[++e]+256*this[++e]+t)})),c.prototype.readFloatLE=function(e,n){return e>>>=0,n||M(e,4,this.length),o.read(this,e,!0,23,4)},c.prototype.readFloatBE=function(e,n){return e>>>=0,n||M(e,4,this.length),o.read(this,e,!1,23,4)},c.prototype.readDoubleLE=function(e,n){return e>>>=0,n||M(e,8,this.length),o.read(this,e,!0,52,8)},c.prototype.readDoubleBE=function(e,n){return e>>>=0,n||M(e,8,this.length),o.read(this,e,!1,52,8)},c.prototype.writeUintLE=c.prototype.writeUIntLE=function(e,n,t,r){e=+e,n>>>=0,t>>>=0,r||x(this,e,n,t,Math.pow(2,8*t)-1,0);let o=1,i=0;for(this[n]=255&e;++i<t&&(o*=256);)this[n+i]=e/o&255;return n+t},c.prototype.writeUintBE=c.prototype.writeUIntBE=function(e,n,t,r){e=+e,n>>>=0,t>>>=0,r||x(this,e,n,t,Math.pow(2,8*t)-1,0);let o=t-1,i=1;for(this[n+o]=255&e;--o>=0&&(i*=256);)this[n+o]=e/i&255;return n+t},c.prototype.writeUint8=c.prototype.writeUInt8=function(e,n,t){return e=+e,n>>>=0,t||x(this,e,n,1,255,0),this[n]=255&e,n+1},c.prototype.writeUint16LE=c.prototype.writeUInt16LE=function(e,n,t){return e=+e,n>>>=0,t||x(this,e,n,2,65535,0),this[n]=255&e,this[n+1]=e>>>8,n+2},c.prototype.writeUint16BE=c.prototype.writeUInt16BE=function(e,n,t){return e=+e,n>>>=0,t||x(this,e,n,2,65535,0),this[n]=e>>>8,this[n+1]=255&e,n+2},c.prototype.writeUint32LE=c.prototype.writeUInt32LE=function(e,n,t){return e=+e,n>>>=0,t||x(this,e,n,4,4294967295,0),this[n+3]=e>>>24,this[n+2]=e>>>16,this[n+1]=e>>>8,this[n]=255&e,n+4},c.prototype.writeUint32BE=c.prototype.writeUInt32BE=function(e,n,t){return e=+e,n>>>=0,t||x(this,e,n,4,4294967295,0),this[n]=e>>>24,this[n+1]=e>>>16,this[n+2]=e>>>8,this[n+3]=255&e,n+4},c.prototype.writeBigUInt64LE=Q((function(e,n=0){return N(this,e,n,BigInt(0),BigInt("0xffffffffffffffff"))})),c.prototype.writeBigUInt64BE=Q((function(e,n=0){return A(this,e,n,BigInt(0),BigInt("0xffffffffffffffff"))})),c.prototype.writeIntLE=function(e,n,t,r){if(e=+e,n>>>=0,!r){const r=Math.pow(2,8*t-1);x(this,e,n,t,r-1,-r)}let o=0,i=1,s=0;for(this[n]=255&e;++o<t&&(i*=256);)e<0&&0===s&&0!==this[n+o-1]&&(s=1),this[n+o]=(e/i>>0)-s&255;return n+t},c.prototype.writeIntBE=function(e,n,t,r){if(e=+e,n>>>=0,!r){const r=Math.pow(2,8*t-1);x(this,e,n,t,r-1,-r)}let o=t-1,i=1,s=0;for(this[n+o]=255&e;--o>=0&&(i*=256);)e<0&&0===s&&0!==this[n+o+1]&&(s=1),this[n+o]=(e/i>>0)-s&255;return n+t},c.prototype.writeInt8=function(e,n,t){return e=+e,n>>>=0,t||x(this,e,n,1,127,-128),e<0&&(e=255+e+1),this[n]=255&e,n+1},c.prototype.writeInt16LE=function(e,n,t){return e=+e,n>>>=0,t||x(this,e,n,2,32767,-32768),this[n]=255&e,this[n+1]=e>>>8,n+2},c.prototype.writeInt16BE=function(e,n,t){return e=+e,n>>>=0,t||x(this,e,n,2,32767,-32768),this[n]=e>>>8,this[n+1]=255&e,n+2},c.prototype.writeInt32LE=function(e,n,t){return e=+e,n>>>=0,t||x(this,e,n,4,2147483647,-2147483648),this[n]=255&e,this[n+1]=e>>>8,this[n+2]=e>>>16,this[n+3]=e>>>24,n+4},c.prototype.writeInt32BE=function(e,n,t){return e=+e,n>>>=0,t||x(this,e,n,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),this[n]=e>>>24,this[n+1]=e>>>16,this[n+2]=e>>>8,this[n+3]=255&e,n+4},c.prototype.writeBigInt64LE=Q((function(e,n=0){return N(this,e,n,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))})),c.prototype.writeBigInt64BE=Q((function(e,n=0){return A(this,e,n,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))})),c.prototype.writeFloatLE=function(e,n,t){return L(this,e,n,!0,t)},c.prototype.writeFloatBE=function(e,n,t){return L(this,e,n,!1,t)},c.prototype.writeDoubleLE=function(e,n,t){return j(this,e,n,!0,t)},c.prototype.writeDoubleBE=function(e,n,t){return j(this,e,n,!1,t)},c.prototype.copy=function(e,n,t,r){if(!c.isBuffer(e))throw new TypeError("argument should be a Buffer");if(t||(t=0),r||0===r||(r=this.length),n>=e.length&&(n=e.length),n||(n=0),r>0&&r<t&&(r=t),r===t)return 0;if(0===e.length||0===this.length)return 0;if(n<0)throw new RangeError("targetStart out of bounds");if(t<0||t>=this.length)throw new RangeError("Index out of range");if(r<0)throw new RangeError("sourceEnd out of bounds");r>this.length&&(r=this.length),e.length-n<r-t&&(r=e.length-n+t);const o=r-t;return this===e&&"function"==typeof Uint8Array.prototype.copyWithin?this.copyWithin(n,t,r):Uint8Array.prototype.set.call(e,this.subarray(t,r),n),o},c.prototype.fill=function(e,n,t,r){if("string"==typeof e){if("string"==typeof n?(r=n,n=0,t=this.length):"string"==typeof t&&(r=t,t=this.length),void 0!==r&&"string"!=typeof r)throw new TypeError("encoding must be a string");if("string"==typeof r&&!c.isEncoding(r))throw new TypeError("Unknown encoding: "+r);if(1===e.length){const n=e.charCodeAt(0);("utf8"===r&&n<128||"latin1"===r)&&(e=n)}}else"number"==typeof e?e&=255:"boolean"==typeof e&&(e=Number(e));if(n<0||this.length<n||this.length<t)throw new RangeError("Out of range index");if(t<=n)return this;let o;if(n>>>=0,t=void 0===t?this.length:t>>>0,e||(e=0),"number"==typeof e)for(o=n;o<t;++o)this[o]=e;else{const i=c.isBuffer(e)?e:c.from(e,r),s=i.length;if(0===s)throw new TypeError('The value "'+e+'" is invalid for argument "value"');for(o=0;o<t-n;++o)this[o+n]=i[o%s]}return this};const B={};function U(e,n,t){B[e]=class extends t{constructor(){super(),Object.defineProperty(this,"message",{value:n.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${e}]`,this.stack,delete this.name}get code(){return e}set code(e){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:e,writable:!0})}toString(){return`${this.name} [${e}]: ${this.message}`}}}function W(e){let n="",t=e.length;const r="-"===e[0]?1:0;for(;t>=r+4;t-=3)n=`_${e.slice(t-3,t)}${n}`;return`${e.slice(0,t)}${n}`}function H(e,n,t,r,o,i){if(e>t||e<n){const r="bigint"==typeof n?"n":"";let o;throw o=i>3?0===n||n===BigInt(0)?`>= 0${r} and < 2${r} ** ${8*(i+1)}${r}`:`>= -(2${r} ** ${8*(i+1)-1}${r}) and < 2 ** ${8*(i+1)-1}${r}`:`>= ${n}${r} and <= ${t}${r}`,new B.ERR_OUT_OF_RANGE("value",o,e)}!function(e,n,t){q(n,"offset"),void 0!==e[n]&&void 0!==e[n+t]||V(n,e.length-(t+1))}(r,o,i)}function q(e,n){if("number"!=typeof e)throw new B.ERR_INVALID_ARG_TYPE(n,"number",e)}function V(e,n,t){if(Math.floor(e)!==e)throw q(e,t),new B.ERR_OUT_OF_RANGE(t||"offset","an integer",e);if(n<0)throw new B.ERR_BUFFER_OUT_OF_BOUNDS;throw new B.ERR_OUT_OF_RANGE(t||"offset",`>= ${t?1:0} and <= ${n}`,e)}U("ERR_BUFFER_OUT_OF_BOUNDS",(function(e){return e?`${e} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"}),RangeError),U("ERR_INVALID_ARG_TYPE",(function(e,n){return`The "${e}" argument must be of type number. Received type ${typeof n}`}),TypeError),U("ERR_OUT_OF_RANGE",(function(e,n,t){let r=`The value of "${e}" is out of range.`,o=t;return Number.isInteger(t)&&Math.abs(t)>2**32?o=W(String(t)):"bigint"==typeof t&&(o=String(t),(t>BigInt(2)**BigInt(32)||t<-(BigInt(2)**BigInt(32)))&&(o=W(o)),o+="n"),r+=` It must be ${n}. Received ${o}`,r}),RangeError);const z=/[^+/0-9A-Za-z-_]/g;function $(e,n){let t;n=n||1/0;const r=e.length;let o=null;const i=[];for(let s=0;s<r;++s){if(t=e.charCodeAt(s),t>55295&&t<57344){if(!o){if(t>56319){(n-=3)>-1&&i.push(239,191,189);continue}if(s+1===r){(n-=3)>-1&&i.push(239,191,189);continue}o=t;continue}if(t<56320){(n-=3)>-1&&i.push(239,191,189),o=t;continue}t=65536+(o-55296<<10|t-56320)}else o&&(n-=3)>-1&&i.push(239,191,189);if(o=null,t<128){if((n-=1)<0)break;i.push(t)}else if(t<2048){if((n-=2)<0)break;i.push(t>>6|192,63&t|128)}else if(t<65536){if((n-=3)<0)break;i.push(t>>12|224,t>>6&63|128,63&t|128)}else{if(!(t<1114112))throw new Error("Invalid code point");if((n-=4)<0)break;i.push(t>>18|240,t>>12&63|128,t>>6&63|128,63&t|128)}}return i}function G(e){return r.toByteArray(function(e){if((e=(e=e.split("=")[0]).trim().replace(z,"")).length<2)return"";for(;e.length%4!=0;)e+="=";return e}(e))}function K(e,n,t,r){let o;for(o=0;o<r&&!(o+t>=n.length||o>=e.length);++o)n[o+t]=e[o];return o}function Y(e,n){return e instanceof n||null!=e&&null!=e.constructor&&null!=e.constructor.name&&e.constructor.name===n.name}function X(e){return e!=e}const J=function(){const e="0123456789abcdef",n=new Array(256);for(let t=0;t<16;++t){const r=16*t;for(let o=0;o<16;++o)n[r+o]=e[t]+e[o]}return n}();function Q(e){return"undefined"==typeof BigInt?Z:e}function Z(){throw new Error("BigInt not supported")}},34024:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.hasCORS=void 0;let t=!1;try{t="undefined"!=typeof XMLHttpRequest&&"withCredentials"in new XMLHttpRequest}catch(e){}n.hasCORS=t},25416:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.decode=n.encode=void 0,n.encode=function(e){let n="";for(let t in e)e.hasOwnProperty(t)&&(n.length&&(n+="&"),n+=encodeURIComponent(t)+"="+encodeURIComponent(e[t]));return n},n.decode=function(e){let n={},t=e.split("&");for(let e=0,r=t.length;e<r;e++){let r=t[e].split("=");n[decodeURIComponent(r[0])]=decodeURIComponent(r[1])}return n}},19187:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.parse=void 0;const t=/^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,r=["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"];n.parse=function(e){const n=e,o=e.indexOf("["),i=e.indexOf("]");-1!=o&&-1!=i&&(e=e.substring(0,o)+e.substring(o,i).replace(/:/g,";")+e.substring(i,e.length));let s=t.exec(e||""),a={},c=14;for(;c--;)a[r[c]]=s[c]||"";return-1!=o&&-1!=i&&(a.source=n,a.host=a.host.substring(1,a.host.length-1).replace(/;/g,":"),a.authority=a.authority.replace("[","").replace("]","").replace(/;/g,":"),a.ipv6uri=!0),a.pathNames=function(e,n){const t=n.replace(/\/{2,9}/g,"/").split("/");return"/"!=n.slice(0,1)&&0!==n.length||t.splice(0,1),"/"==n.slice(-1)&&t.splice(t.length-1,1),t}(0,a.path),a.queryKey=function(e,n){const t={};return n.replace(/(?:^|&)([^&=]*)=?([^&]*)/g,(function(e,n,r){n&&(t[n]=r)})),t}(0,a.query),a}},96294:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.yeast=n.decode=n.encode=void 0;const t="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""),r=64,o={};let i,s=0,a=0;function c(e){let n="";do{n=t[e%r]+n,e=Math.floor(e/r)}while(e>0);return n}for(n.encode=c,n.decode=function(e){let n=0;for(a=0;a<e.length;a++)n=n*r+o[e.charAt(a)];return n},n.yeast=function(){const e=c(+new Date);return e!==i?(s=0,i=e):e+"."+c(s++)};a<r;a++)o[t[a]]=a},17307:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.globalThisShim=void 0,n.globalThisShim="undefined"!=typeof self?self:"undefined"!=typeof window?window:Function("return this")()},61473:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.nextTick=n.parse=n.installTimerFunctions=n.transports=n.Transport=n.protocol=n.Socket=void 0;const r=t(3091);Object.defineProperty(n,"Socket",{enumerable:!0,get:function(){return r.Socket}}),n.protocol=r.Socket.protocol;var o=t(55817);Object.defineProperty(n,"Transport",{enumerable:!0,get:function(){return o.Transport}});var i=t(78508);Object.defineProperty(n,"transports",{enumerable:!0,get:function(){return i.transports}});var s=t(18719);Object.defineProperty(n,"installTimerFunctions",{enumerable:!0,get:function(){return s.installTimerFunctions}});var a=t(19187);Object.defineProperty(n,"parse",{enumerable:!0,get:function(){return a.parse}});var c=t(26089);Object.defineProperty(n,"nextTick",{enumerable:!0,get:function(){return c.nextTick}})},3091:function(e,n,t){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0}),n.Socket=void 0;const o=t(78508),i=t(18719),s=t(25416),a=t(19187),c=r(t(25130)),l=t(97416),d=t(67385),u=(0,c.default)("engine.io-client:socket");class p extends l.Emitter{constructor(e,n={}){super(),this.writeBuffer=[],e&&"object"==typeof e&&(n=e,e=null),e?(e=(0,a.parse)(e),n.hostname=e.host,n.secure="https"===e.protocol||"wss"===e.protocol,n.port=e.port,e.query&&(n.query=e.query)):n.host&&(n.hostname=(0,a.parse)(n.host).host),(0,i.installTimerFunctions)(this,n),this.secure=null!=n.secure?n.secure:"undefined"!=typeof location&&"https:"===location.protocol,n.hostname&&!n.port&&(n.port=this.secure?"443":"80"),this.hostname=n.hostname||("undefined"!=typeof location?location.hostname:"localhost"),this.port=n.port||("undefined"!=typeof location&&location.port?location.port:this.secure?"443":"80"),this.transports=n.transports||["polling","websocket"],this.writeBuffer=[],this.prevBufferLen=0,this.opts=Object.assign({path:"/engine.io",agent:!1,withCredentials:!1,upgrade:!0,timestampParam:"t",rememberUpgrade:!1,addTrailingSlash:!0,rejectUnauthorized:!0,perMessageDeflate:{threshold:1024},transportOptions:{},closeOnBeforeunload:!0},n),this.opts.path=this.opts.path.replace(/\/$/,"")+(this.opts.addTrailingSlash?"/":""),"string"==typeof this.opts.query&&(this.opts.query=(0,s.decode)(this.opts.query)),this.id=null,this.upgrades=null,this.pingInterval=null,this.pingTimeout=null,this.pingTimeoutTimer=null,"function"==typeof addEventListener&&(this.opts.closeOnBeforeunload&&(this.beforeunloadEventListener=()=>{this.transport&&(this.transport.removeAllListeners(),this.transport.close())},addEventListener("beforeunload",this.beforeunloadEventListener,!1)),"localhost"!==this.hostname&&(this.offlineEventListener=()=>{this.onClose("transport close",{description:"network connection lost"})},addEventListener("offline",this.offlineEventListener,!1))),this.open()}createTransport(e){u('creating transport "%s"',e);const n=Object.assign({},this.opts.query);n.EIO=d.protocol,n.transport=e,this.id&&(n.sid=this.id);const t=Object.assign({},this.opts.transportOptions[e],this.opts,{query:n,socket:this,hostname:this.hostname,secure:this.secure,port:this.port});return u("options: %j",t),new o.transports[e](t)}open(){let e;if(this.opts.rememberUpgrade&&p.priorWebsocketSuccess&&-1!==this.transports.indexOf("websocket"))e="websocket";else{if(0===this.transports.length)return void this.setTimeoutFn((()=>{this.emitReserved("error","No transports available")}),0);e=this.transports[0]}this.readyState="opening";try{e=this.createTransport(e)}catch(e){return u("error while creating transport: %s",e),this.transports.shift(),void this.open()}e.open(),this.setTransport(e)}setTransport(e){u("setting transport %s",e.name),this.transport&&(u("clearing existing transport %s",this.transport.name),this.transport.removeAllListeners()),this.transport=e,e.on("drain",this.onDrain.bind(this)).on("packet",this.onPacket.bind(this)).on("error",this.onError.bind(this)).on("close",(e=>this.onClose("transport close",e)))}probe(e){u('probing transport "%s"',e);let n=this.createTransport(e),t=!1;p.priorWebsocketSuccess=!1;const r=()=>{t||(u('probe transport "%s" opened',e),n.send([{type:"ping",data:"probe"}]),n.once("packet",(r=>{if(!t)if("pong"===r.type&&"probe"===r.data){if(u('probe transport "%s" pong',e),this.upgrading=!0,this.emitReserved("upgrading",n),!n)return;p.priorWebsocketSuccess="websocket"===n.name,u('pausing current transport "%s"',this.transport.name),this.transport.pause((()=>{t||"closed"!==this.readyState&&(u("changing transport and sending upgrade packet"),l(),this.setTransport(n),n.send([{type:"upgrade"}]),this.emitReserved("upgrade",n),n=null,this.upgrading=!1,this.flush())}))}else{u('probe transport "%s" failed',e);const t=new Error("probe error");t.transport=n.name,this.emitReserved("upgradeError",t)}})))};function o(){t||(t=!0,l(),n.close(),n=null)}const i=t=>{const r=new Error("probe error: "+t);r.transport=n.name,o(),u('probe transport "%s" failed because of error: %s',e,t),this.emitReserved("upgradeError",r)};function s(){i("transport closed")}function a(){i("socket closed")}function c(e){n&&e.name!==n.name&&(u('"%s" works - aborting "%s"',e.name,n.name),o())}const l=()=>{n.removeListener("open",r),n.removeListener("error",i),n.removeListener("close",s),this.off("close",a),this.off("upgrading",c)};n.once("open",r),n.once("error",i),n.once("close",s),this.once("close",a),this.once("upgrading",c),n.open()}onOpen(){if(u("socket open"),this.readyState="open",p.priorWebsocketSuccess="websocket"===this.transport.name,this.emitReserved("open"),this.flush(),"open"===this.readyState&&this.opts.upgrade){u("starting upgrade probes");let e=0;const n=this.upgrades.length;for(;e<n;e++)this.probe(this.upgrades[e])}}onPacket(e){if("opening"===this.readyState||"open"===this.readyState||"closing"===this.readyState)switch(u('socket receive: type "%s", data "%s"',e.type,e.data),this.emitReserved("packet",e),this.emitReserved("heartbeat"),e.type){case"open":this.onHandshake(JSON.parse(e.data));break;case"ping":this.resetPingTimeout(),this.sendPacket("pong"),this.emitReserved("ping"),this.emitReserved("pong");break;case"error":const n=new Error("server error");n.code=e.data,this.onError(n);break;case"message":this.emitReserved("data",e.data),this.emitReserved("message",e.data)}else u('packet received with socket readyState "%s"',this.readyState)}onHandshake(e){this.emitReserved("handshake",e),this.id=e.sid,this.transport.query.sid=e.sid,this.upgrades=this.filterUpgrades(e.upgrades),this.pingInterval=e.pingInterval,this.pingTimeout=e.pingTimeout,this.maxPayload=e.maxPayload,this.onOpen(),"closed"!==this.readyState&&this.resetPingTimeout()}resetPingTimeout(){this.clearTimeoutFn(this.pingTimeoutTimer),this.pingTimeoutTimer=this.setTimeoutFn((()=>{this.onClose("ping timeout")}),this.pingInterval+this.pingTimeout),this.opts.autoUnref&&this.pingTimeoutTimer.unref()}onDrain(){this.writeBuffer.splice(0,this.prevBufferLen),this.prevBufferLen=0,0===this.writeBuffer.length?this.emitReserved("drain"):this.flush()}flush(){if("closed"!==this.readyState&&this.transport.writable&&!this.upgrading&&this.writeBuffer.length){const e=this.getWritablePackets();u("flushing %d packets in socket",e.length),this.transport.send(e),this.prevBufferLen=e.length,this.emitReserved("flush")}}getWritablePackets(){if(!(this.maxPayload&&"polling"===this.transport.name&&this.writeBuffer.length>1))return this.writeBuffer;let e=1;for(let n=0;n<this.writeBuffer.length;n++){const t=this.writeBuffer[n].data;if(t&&(e+=(0,i.byteLength)(t)),n>0&&e>this.maxPayload)return u("only send %d out of %d packets",n,this.writeBuffer.length),this.writeBuffer.slice(0,n);e+=2}return u("payload size is %d (max: %d)",e,this.maxPayload),this.writeBuffer}write(e,n,t){return this.sendPacket("message",e,n,t),this}send(e,n,t){return this.sendPacket("message",e,n,t),this}sendPacket(e,n,t,r){if("function"==typeof n&&(r=n,n=void 0),"function"==typeof t&&(r=t,t=null),"closing"===this.readyState||"closed"===this.readyState)return;(t=t||{}).compress=!1!==t.compress;const o={type:e,data:n,options:t};this.emitReserved("packetCreate",o),this.writeBuffer.push(o),r&&this.once("flush",r),this.flush()}close(){const e=()=>{this.onClose("forced close"),u("socket closing - telling transport to close"),this.transport.close()},n=()=>{this.off("upgrade",n),this.off("upgradeError",n),e()},t=()=>{this.once("upgrade",n),this.once("upgradeError",n)};return"opening"!==this.readyState&&"open"!==this.readyState||(this.readyState="closing",this.writeBuffer.length?this.once("drain",(()=>{this.upgrading?t():e()})):this.upgrading?t():e()),this}onError(e){u("socket error %j",e),p.priorWebsocketSuccess=!1,this.emitReserved("error",e),this.onClose("transport error",e)}onClose(e,n){"opening"!==this.readyState&&"open"!==this.readyState&&"closing"!==this.readyState||(u('socket close with reason: "%s"',e),this.clearTimeoutFn(this.pingTimeoutTimer),this.transport.removeAllListeners("close"),this.transport.close(),this.transport.removeAllListeners(),"function"==typeof removeEventListener&&(removeEventListener("beforeunload",this.beforeunloadEventListener,!1),removeEventListener("offline",this.offlineEventListener,!1)),this.readyState="closed",this.id=null,this.emitReserved("close",e,n),this.writeBuffer=[],this.prevBufferLen=0)}filterUpgrades(e){const n=[];let t=0;const r=e.length;for(;t<r;t++)~this.transports.indexOf(e[t])&&n.push(e[t]);return n}}n.Socket=p,p.protocol=d.protocol},55817:function(e,n,t){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0}),n.Transport=void 0;const o=t(67385),i=t(97416),s=t(18719),a=(0,r(t(25130)).default)("engine.io-client:transport");class c extends Error{constructor(e,n,t){super(e),this.description=n,this.context=t,this.type="TransportError"}}class l extends i.Emitter{constructor(e){super(),this.writable=!1,(0,s.installTimerFunctions)(this,e),this.opts=e,this.query=e.query,this.socket=e.socket}onError(e,n,t){return super.emitReserved("error",new c(e,n,t)),this}open(){return this.readyState="opening",this.doOpen(),this}close(){return"opening"!==this.readyState&&"open"!==this.readyState||(this.doClose(),this.onClose()),this}send(e){"open"===this.readyState?this.write(e):a("transport is not open, discarding packets")}onOpen(){this.readyState="open",this.writable=!0,super.emitReserved("open")}onData(e){const n=(0,o.decodePacket)(e,this.socket.binaryType);this.onPacket(n)}onPacket(e){super.emitReserved("packet",e)}onClose(e){this.readyState="closed",super.emitReserved("close",e)}pause(e){}}n.Transport=l},78508:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.transports=void 0;const r=t(46788),o=t(98948);n.transports={websocket:o.WS,polling:r.Polling}},46788:function(e,n,t){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0}),n.Request=n.Polling=void 0;const o=t(55817),i=r(t(25130)),s=t(96294),a=t(25416),c=t(67385),l=t(43566),d=t(97416),u=t(18719),p=t(17307),h=(0,i.default)("engine.io-client:polling");function f(){}const m=null!=new l.XHR({xdomain:!1}).responseType;class g extends o.Transport{constructor(e){if(super(e),this.polling=!1,"undefined"!=typeof location){const n="https:"===location.protocol;let t=location.port;t||(t=n?"443":"80"),this.xd="undefined"!=typeof location&&e.hostname!==location.hostname||t!==e.port,this.xs=e.secure!==n}const n=e&&e.forceBase64;this.supportsBinary=m&&!n}get name(){return"polling"}doOpen(){this.poll()}pause(e){this.readyState="pausing";const n=()=>{h("paused"),this.readyState="paused",e()};if(this.polling||!this.writable){let e=0;this.polling&&(h("we are currently polling - waiting to pause"),e++,this.once("pollComplete",(function(){h("pre-pause polling complete"),--e||n()}))),this.writable||(h("we are currently writing - waiting to pause"),e++,this.once("drain",(function(){h("pre-pause writing complete"),--e||n()})))}else n()}poll(){h("polling"),this.polling=!0,this.doPoll(),this.emitReserved("poll")}onData(e){h("polling got data %s",e),(0,c.decodePayload)(e,this.socket.binaryType).forEach((e=>{if("opening"===this.readyState&&"open"===e.type&&this.onOpen(),"close"===e.type)return this.onClose({description:"transport closed by the server"}),!1;this.onPacket(e)})),"closed"!==this.readyState&&(this.polling=!1,this.emitReserved("pollComplete"),"open"===this.readyState?this.poll():h('ignoring poll - transport state "%s"',this.readyState))}doClose(){const e=()=>{h("writing close packet"),this.write([{type:"close"}])};"open"===this.readyState?(h("transport open - closing"),e()):(h("transport not open - deferring close"),this.once("open",e))}write(e){this.writable=!1,(0,c.encodePayload)(e,(e=>{this.doWrite(e,(()=>{this.writable=!0,this.emitReserved("drain")}))}))}uri(){let e=this.query||{};const n=this.opts.secure?"https":"http";let t="";!1!==this.opts.timestampRequests&&(e[this.opts.timestampParam]=(0,s.yeast)()),this.supportsBinary||e.sid||(e.b64=1),this.opts.port&&("https"===n&&443!==Number(this.opts.port)||"http"===n&&80!==Number(this.opts.port))&&(t=":"+this.opts.port);const r=(0,a.encode)(e);return n+"://"+(-1!==this.opts.hostname.indexOf(":")?"["+this.opts.hostname+"]":this.opts.hostname)+t+this.opts.path+(r.length?"?"+r:"")}request(e={}){return Object.assign(e,{xd:this.xd,xs:this.xs},this.opts),new y(this.uri(),e)}doWrite(e,n){const t=this.request({method:"POST",data:e});t.on("success",n),t.on("error",((e,n)=>{this.onError("xhr post error",e,n)}))}doPoll(){h("xhr poll");const e=this.request();e.on("data",this.onData.bind(this)),e.on("error",((e,n)=>{this.onError("xhr poll error",e,n)})),this.pollXhr=e}}n.Polling=g;class y extends d.Emitter{constructor(e,n){super(),(0,u.installTimerFunctions)(this,n),this.opts=n,this.method=n.method||"GET",this.uri=e,this.async=!1!==n.async,this.data=void 0!==n.data?n.data:null,this.create()}create(){const e=(0,u.pick)(this.opts,"agent","pfx","key","passphrase","cert","ca","ciphers","rejectUnauthorized","autoUnref");e.xdomain=!!this.opts.xd,e.xscheme=!!this.opts.xs;const n=this.xhr=new l.XHR(e);try{h("xhr open %s: %s",this.method,this.uri),n.open(this.method,this.uri,this.async);try{if(this.opts.extraHeaders){n.setDisableHeaderCheck&&n.setDisableHeaderCheck(!0);for(let e in this.opts.extraHeaders)this.opts.extraHeaders.hasOwnProperty(e)&&n.setRequestHeader(e,this.opts.extraHeaders[e])}}catch(e){}if("POST"===this.method)try{n.setRequestHeader("Content-type","text/plain;charset=UTF-8")}catch(e){}try{n.setRequestHeader("Accept","*/*")}catch(e){}"withCredentials"in n&&(n.withCredentials=this.opts.withCredentials),this.opts.requestTimeout&&(n.timeout=this.opts.requestTimeout),n.onreadystatechange=()=>{4===n.readyState&&(200===n.status||1223===n.status?this.onLoad():this.setTimeoutFn((()=>{this.onError("number"==typeof n.status?n.status:0)}),0))},h("xhr data %s",this.data),n.send(this.data)}catch(e){return void this.setTimeoutFn((()=>{this.onError(e)}),0)}"undefined"!=typeof document&&(this.index=y.requestsCount++,y.requests[this.index]=this)}onError(e){this.emitReserved("error",e,this.xhr),this.cleanup(!0)}cleanup(e){if(void 0!==this.xhr&&null!==this.xhr){if(this.xhr.onreadystatechange=f,e)try{this.xhr.abort()}catch(e){}"undefined"!=typeof document&&delete y.requests[this.index],this.xhr=null}}onLoad(){const e=this.xhr.responseText;null!==e&&(this.emitReserved("data",e),this.emitReserved("success"),this.cleanup())}abort(){this.cleanup()}}if(n.Request=y,y.requestsCount=0,y.requests={},"undefined"!=typeof document)if("function"==typeof attachEvent)attachEvent("onunload",_);else if("function"==typeof addEventListener){const e="onpagehide"in p.globalThisShim?"pagehide":"unload";addEventListener(e,_,!1)}function _(){for(let e in y.requests)y.requests.hasOwnProperty(e)&&y.requests[e].abort()}},26089:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.defaultBinaryType=n.usingBrowserWebSocket=n.WebSocket=n.nextTick=void 0;const r=t(17307);n.nextTick="function"==typeof Promise&&"function"==typeof Promise.resolve?e=>Promise.resolve().then(e):(e,n)=>n(e,0),n.WebSocket=r.globalThisShim.WebSocket||r.globalThisShim.MozWebSocket,n.usingBrowserWebSocket=!0,n.defaultBinaryType="arraybuffer"},98948:function(e,n,t){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0}),n.WS=void 0;const o=t(55817),i=t(25416),s=t(96294),a=t(18719),c=t(26089),l=r(t(25130)),d=t(67385),u=(0,l.default)("engine.io-client:websocket"),p="undefined"!=typeof navigator&&"string"==typeof navigator.product&&"reactnative"===navigator.product.toLowerCase();class h extends o.Transport{constructor(e){super(e),this.supportsBinary=!e.forceBase64}get name(){return"websocket"}doOpen(){if(!this.check())return;const e=this.uri(),n=this.opts.protocols,t=p?{}:(0,a.pick)(this.opts,"agent","perMessageDeflate","pfx","key","passphrase","cert","ca","ciphers","rejectUnauthorized","localAddress","protocolVersion","origin","maxPayload","family","checkServerIdentity");this.opts.extraHeaders&&(t.headers=this.opts.extraHeaders);try{this.ws=c.usingBrowserWebSocket&&!p?n?new c.WebSocket(e,n):new c.WebSocket(e):new c.WebSocket(e,n,t)}catch(e){return this.emitReserved("error",e)}this.ws.binaryType=this.socket.binaryType||c.defaultBinaryType,this.addEventListeners()}addEventListeners(){this.ws.onopen=()=>{this.opts.autoUnref&&this.ws._socket.unref(),this.onOpen()},this.ws.onclose=e=>this.onClose({description:"websocket connection closed",context:e}),this.ws.onmessage=e=>this.onData(e.data),this.ws.onerror=e=>this.onError("websocket error",e)}write(e){this.writable=!1;for(let n=0;n<e.length;n++){const t=e[n],r=n===e.length-1;(0,d.encodePacket)(t,this.supportsBinary,(e=>{const n={};!c.usingBrowserWebSocket&&(t.options&&(n.compress=t.options.compress),this.opts.perMessageDeflate)&&("string"==typeof e?Buffer.byteLength(e):e.length)<this.opts.perMessageDeflate.threshold&&(n.compress=!1);try{c.usingBrowserWebSocket?this.ws.send(e):this.ws.send(e,n)}catch(e){u("websocket closed before onclose event")}r&&(0,c.nextTick)((()=>{this.writable=!0,this.emitReserved("drain")}),this.setTimeoutFn)}))}}doClose(){void 0!==this.ws&&(this.ws.close(),this.ws=null)}uri(){let e=this.query||{};const n=this.opts.secure?"wss":"ws";let t="";this.opts.port&&("wss"===n&&443!==Number(this.opts.port)||"ws"===n&&80!==Number(this.opts.port))&&(t=":"+this.opts.port),this.opts.timestampRequests&&(e[this.opts.timestampParam]=(0,s.yeast)()),this.supportsBinary||(e.b64=1);const r=(0,i.encode)(e);return n+"://"+(-1!==this.opts.hostname.indexOf(":")?"["+this.opts.hostname+"]":this.opts.hostname)+t+this.opts.path+(r.length?"?"+r:"")}check(){return!!c.WebSocket}}n.WS=h},43566:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.XHR=void 0;const r=t(34024),o=t(17307);n.XHR=function(e){const n=e.xdomain;try{if("undefined"!=typeof XMLHttpRequest&&(!n||r.hasCORS))return new XMLHttpRequest}catch(e){}if(!n)try{return new(o.globalThisShim[["Active"].concat("Object").join("X")])("Microsoft.XMLHTTP")}catch(e){}}},18719:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.byteLength=n.installTimerFunctions=n.pick=void 0;const r=t(17307);n.pick=function(e,...n){return n.reduce(((n,t)=>(e.hasOwnProperty(t)&&(n[t]=e[t]),n)),{})};const o=r.globalThisShim.setTimeout,i=r.globalThisShim.clearTimeout;n.installTimerFunctions=function(e,n){n.useNativeTimers?(e.setTimeoutFn=o.bind(r.globalThisShim),e.clearTimeoutFn=i.bind(r.globalThisShim)):(e.setTimeoutFn=r.globalThisShim.setTimeout.bind(r.globalThisShim),e.clearTimeoutFn=r.globalThisShim.clearTimeout.bind(r.globalThisShim))};n.byteLength=function(e){return"string"==typeof e?function(e){let n=0,t=0;for(let r=0,o=e.length;r<o;r++)n=e.charCodeAt(r),n<128?t+=1:n<2048?t+=2:n<55296||n>=57344?t+=3:(r++,t+=4);return t}(e):Math.ceil(1.33*(e.byteLength||e.size))}},37950:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.ERROR_PACKET=n.PACKET_TYPES_REVERSE=n.PACKET_TYPES=void 0;const t=Object.create(null);n.PACKET_TYPES=t,t.open="0",t.close="1",t.ping="2",t.pong="3",t.message="4",t.upgrade="5",t.noop="6";const r=Object.create(null);n.PACKET_TYPES_REVERSE=r,Object.keys(t).forEach((e=>{r[t[e]]=e})),n.ERROR_PACKET={type:"error",data:"parser error"}},36640:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.decode=n.encode=void 0;const t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",r="undefined"==typeof Uint8Array?[]:new Uint8Array(256);for(let e=0;e<t.length;e++)r[t.charCodeAt(e)]=e;n.encode=e=>{let n,r=new Uint8Array(e),o=r.length,i="";for(n=0;n<o;n+=3)i+=t[r[n]>>2],i+=t[(3&r[n])<<4|r[n+1]>>4],i+=t[(15&r[n+1])<<2|r[n+2]>>6],i+=t[63&r[n+2]];return o%3==2?i=i.substring(0,i.length-1)+"=":o%3==1&&(i=i.substring(0,i.length-2)+"=="),i},n.decode=e=>{let n,t,o,i,s,a=.75*e.length,c=e.length,l=0;"="===e[e.length-1]&&(a--,"="===e[e.length-2]&&a--);const d=new ArrayBuffer(a),u=new Uint8Array(d);for(n=0;n<c;n+=4)t=r[e.charCodeAt(n)],o=r[e.charCodeAt(n+1)],i=r[e.charCodeAt(n+2)],s=r[e.charCodeAt(n+3)],u[l++]=t<<2|o>>4,u[l++]=(15&o)<<4|i>>2,u[l++]=(3&i)<<6|63&s;return d}},86559:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(37950),o=t(36640),i="function"==typeof ArrayBuffer,s=(e,n)=>{if(i){const t=(0,o.decode)(e);return a(t,n)}return{base64:!0,data:e}},a=(e,n)=>"blob"===n&&e instanceof ArrayBuffer?new Blob([e]):e;n.default=(e,n)=>{if("string"!=typeof e)return{type:"message",data:a(e,n)};const t=e.charAt(0);return"b"===t?{type:"message",data:s(e.substring(1),n)}:r.PACKET_TYPES_REVERSE[t]?e.length>1?{type:r.PACKET_TYPES_REVERSE[t],data:e.substring(1)}:{type:r.PACKET_TYPES_REVERSE[t]}:r.ERROR_PACKET}},55916:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const r=t(37950),o="function"==typeof Blob||"undefined"!=typeof Blob&&"[object BlobConstructor]"===Object.prototype.toString.call(Blob),i="function"==typeof ArrayBuffer,s=(e,n)=>{const t=new FileReader;return t.onload=function(){const e=t.result.split(",")[1];n("b"+(e||""))},t.readAsDataURL(e)};n.default=({type:e,data:n},t,a)=>{return o&&n instanceof Blob?t?a(n):s(n,a):i&&(n instanceof ArrayBuffer||(c=n,"function"==typeof ArrayBuffer.isView?ArrayBuffer.isView(c):c&&c.buffer instanceof ArrayBuffer))?t?a(n):s(new Blob([n]),a):a(r.PACKET_TYPES[e]+(n||""));var c}},67385:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.decodePayload=n.decodePacket=n.encodePayload=n.encodePacket=n.protocol=void 0;const r=t(55916);n.encodePacket=r.default;const o=t(86559);n.decodePacket=o.default;const i=String.fromCharCode(30);n.encodePayload=(e,n)=>{const t=e.length,o=new Array(t);let s=0;e.forEach(((e,a)=>{(0,r.default)(e,!1,(e=>{o[a]=e,++s===t&&n(o.join(i))}))}))},n.decodePayload=(e,n)=>{const t=e.split(i),r=[];for(let e=0;e<t.length;e++){const i=(0,o.default)(t[e],n);if(r.push(i),"error"===i.type)break}return r},n.protocol=4},93137:(e,n)=>{"use strict";function t(e){e=e||{},this.ms=e.min||100,this.max=e.max||1e4,this.factor=e.factor||2,this.jitter=e.jitter>0&&e.jitter<=1?e.jitter:0,this.attempts=0}Object.defineProperty(n,"__esModule",{value:!0}),n.Backoff=void 0,n.Backoff=t,t.prototype.duration=function(){var e=this.ms*Math.pow(this.factor,this.attempts++);if(this.jitter){var n=Math.random(),t=Math.floor(n*this.jitter*e);e=0==(1&Math.floor(10*n))?e-t:e+t}return 0|Math.min(e,this.max)},t.prototype.reset=function(){this.attempts=0},t.prototype.setMin=function(e){this.ms=e},t.prototype.setMax=function(e){this.max=e},t.prototype.setJitter=function(e){this.jitter=e}},16580:function(e,n,t){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0}),n.default=n.connect=n.io=n.Socket=n.Manager=n.protocol=void 0;const o=t(5702),i=t(55734);Object.defineProperty(n,"Manager",{enumerable:!0,get:function(){return i.Manager}});const s=t(49189);Object.defineProperty(n,"Socket",{enumerable:!0,get:function(){return s.Socket}});const a=r(t(25130)).default("socket.io-client"),c={};function l(e,n){"object"==typeof e&&(n=e,e=void 0),n=n||{};const t=o.url(e,n.path||"/socket.io"),r=t.source,s=t.id,l=t.path,d=c[s]&&l in c[s].nsps;let u;return n.forceNew||n["force new connection"]||!1===n.multiplex||d?(a("ignoring socket cache for %s",r),u=new i.Manager(r,n)):(c[s]||(a("new io instance for %s",r),c[s]=new i.Manager(r,n)),u=c[s]),t.query&&!n.query&&(n.query=t.queryKey),u.socket(t.path,n)}n.io=l,n.connect=l,n.default=l,Object.assign(l,{Manager:i.Manager,Socket:s.Socket,io:l,connect:l});var d=t(56642);Object.defineProperty(n,"protocol",{enumerable:!0,get:function(){return d.protocol}}),e.exports=l},55734:function(e,n,t){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,n,t,r){void 0===r&&(r=t),Object.defineProperty(e,r,{enumerable:!0,get:function(){return n[t]}})}:function(e,n,t,r){void 0===r&&(r=t),e[r]=n[t]}),o=this&&this.__setModuleDefault||(Object.create?function(e,n){Object.defineProperty(e,"default",{enumerable:!0,value:n})}:function(e,n){e.default=n}),i=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)"default"!==t&&Object.prototype.hasOwnProperty.call(e,t)&&r(n,e,t);return o(n,e),n},s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0}),n.Manager=void 0;const a=t(61473),c=t(49189),l=i(t(56642)),d=t(46166),u=t(93137),p=t(97416),h=s(t(25130)).default("socket.io-client:manager");class f extends p.Emitter{constructor(e,n){var t;super(),this.nsps={},this.subs=[],e&&"object"==typeof e&&(n=e,e=void 0),(n=n||{}).path=n.path||"/socket.io",this.opts=n,a.installTimerFunctions(this,n),this.reconnection(!1!==n.reconnection),this.reconnectionAttempts(n.reconnectionAttempts||1/0),this.reconnectionDelay(n.reconnectionDelay||1e3),this.reconnectionDelayMax(n.reconnectionDelayMax||5e3),this.randomizationFactor(null!==(t=n.randomizationFactor)&&void 0!==t?t:.5),this.backoff=new u.Backoff({min:this.reconnectionDelay(),max:this.reconnectionDelayMax(),jitter:this.randomizationFactor()}),this.timeout(null==n.timeout?2e4:n.timeout),this._readyState="closed",this.uri=e;const r=n.parser||l;this.encoder=new r.Encoder,this.decoder=new r.Decoder,this._autoConnect=!1!==n.autoConnect,this._autoConnect&&this.open()}reconnection(e){return arguments.length?(this._reconnection=!!e,this):this._reconnection}reconnectionAttempts(e){return void 0===e?this._reconnectionAttempts:(this._reconnectionAttempts=e,this)}reconnectionDelay(e){var n;return void 0===e?this._reconnectionDelay:(this._reconnectionDelay=e,null===(n=this.backoff)||void 0===n||n.setMin(e),this)}randomizationFactor(e){var n;return void 0===e?this._randomizationFactor:(this._randomizationFactor=e,null===(n=this.backoff)||void 0===n||n.setJitter(e),this)}reconnectionDelayMax(e){var n;return void 0===e?this._reconnectionDelayMax:(this._reconnectionDelayMax=e,null===(n=this.backoff)||void 0===n||n.setMax(e),this)}timeout(e){return arguments.length?(this._timeout=e,this):this._timeout}maybeReconnectOnOpen(){!this._reconnecting&&this._reconnection&&0===this.backoff.attempts&&this.reconnect()}open(e){if(h("readyState %s",this._readyState),~this._readyState.indexOf("open"))return this;h("opening %s",this.uri),this.engine=new a.Socket(this.uri,this.opts);const n=this.engine,t=this;this._readyState="opening",this.skipReconnect=!1;const r=d.on(n,"open",(function(){t.onopen(),e&&e()})),o=d.on(n,"error",(n=>{h("error"),t.cleanup(),t._readyState="closed",this.emitReserved("error",n),e?e(n):t.maybeReconnectOnOpen()}));if(!1!==this._timeout){const e=this._timeout;h("connect attempt will timeout after %d",e),0===e&&r();const t=this.setTimeoutFn((()=>{h("connect attempt timed out after %d",e),r(),n.close(),n.emit("error",new Error("timeout"))}),e);this.opts.autoUnref&&t.unref(),this.subs.push((function(){clearTimeout(t)}))}return this.subs.push(r),this.subs.push(o),this}connect(e){return this.open(e)}onopen(){h("open"),this.cleanup(),this._readyState="open",this.emitReserved("open");const e=this.engine;this.subs.push(d.on(e,"ping",this.onping.bind(this)),d.on(e,"data",this.ondata.bind(this)),d.on(e,"error",this.onerror.bind(this)),d.on(e,"close",this.onclose.bind(this)),d.on(this.decoder,"decoded",this.ondecoded.bind(this)))}onping(){this.emitReserved("ping")}ondata(e){try{this.decoder.add(e)}catch(e){this.onclose("parse error",e)}}ondecoded(e){a.nextTick((()=>{this.emitReserved("packet",e)}),this.setTimeoutFn)}onerror(e){h("error",e),this.emitReserved("error",e)}socket(e,n){let t=this.nsps[e];return t?this._autoConnect&&!t.active&&t.connect():(t=new c.Socket(this,e,n),this.nsps[e]=t),t}_destroy(e){const n=Object.keys(this.nsps);for(const e of n)if(this.nsps[e].active)return void h("socket %s is still active, skipping close",e);this._close()}_packet(e){h("writing packet %j",e);const n=this.encoder.encode(e);for(let t=0;t<n.length;t++)this.engine.write(n[t],e.options)}cleanup(){h("cleanup"),this.subs.forEach((e=>e())),this.subs.length=0,this.decoder.destroy()}_close(){h("disconnect"),this.skipReconnect=!0,this._reconnecting=!1,this.onclose("forced close"),this.engine&&this.engine.close()}disconnect(){return this._close()}onclose(e,n){h("closed due to %s",e),this.cleanup(),this.backoff.reset(),this._readyState="closed",this.emitReserved("close",e,n),this._reconnection&&!this.skipReconnect&&this.reconnect()}reconnect(){if(this._reconnecting||this.skipReconnect)return this;const e=this;if(this.backoff.attempts>=this._reconnectionAttempts)h("reconnect failed"),this.backoff.reset(),this.emitReserved("reconnect_failed"),this._reconnecting=!1;else{const n=this.backoff.duration();h("will wait %dms before reconnect attempt",n),this._reconnecting=!0;const t=this.setTimeoutFn((()=>{e.skipReconnect||(h("attempting reconnect"),this.emitReserved("reconnect_attempt",e.backoff.attempts),e.skipReconnect||e.open((n=>{n?(h("reconnect attempt error"),e._reconnecting=!1,e.reconnect(),this.emitReserved("reconnect_error",n)):(h("reconnect success"),e.onreconnect())})))}),n);this.opts.autoUnref&&t.unref(),this.subs.push((function(){clearTimeout(t)}))}}onreconnect(){const e=this.backoff.attempts;this._reconnecting=!1,this.backoff.reset(),this.emitReserved("reconnect",e)}}n.Manager=f},46166:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.on=void 0,n.on=function(e,n,t){return e.on(n,t),function(){e.off(n,t)}}},49189:function(e,n,t){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0}),n.Socket=void 0;const o=t(56642),i=t(46166),s=t(97416),a=r(t(25130)).default("socket.io-client:socket"),c=Object.freeze({connect:1,connect_error:1,disconnect:1,disconnecting:1,newListener:1,removeListener:1});class l extends s.Emitter{constructor(e,n,t){super(),this.connected=!1,this.recovered=!1,this.receiveBuffer=[],this.sendBuffer=[],this._queue=[],this._queueSeq=0,this.ids=0,this.acks={},this.flags={},this.io=e,this.nsp=n,t&&t.auth&&(this.auth=t.auth),this._opts=Object.assign({},t),this.io._autoConnect&&this.open()}get disconnected(){return!this.connected}subEvents(){if(this.subs)return;const e=this.io;this.subs=[i.on(e,"open",this.onopen.bind(this)),i.on(e,"packet",this.onpacket.bind(this)),i.on(e,"error",this.onerror.bind(this)),i.on(e,"close",this.onclose.bind(this))]}get active(){return!!this.subs}connect(){return this.connected||(this.subEvents(),this.io._reconnecting||this.io.open(),"open"===this.io._readyState&&this.onopen()),this}open(){return this.connect()}send(...e){return e.unshift("message"),this.emit.apply(this,e),this}emit(e,...n){if(c.hasOwnProperty(e))throw new Error('"'+e.toString()+'" is a reserved event name');if(n.unshift(e),this._opts.retries&&!this.flags.fromQueue&&!this.flags.volatile)return this._addToQueue(n),this;const t={type:o.PacketType.EVENT,data:n,options:{}};if(t.options.compress=!1!==this.flags.compress,"function"==typeof n[n.length-1]){const e=this.ids++;a("emitting packet with ack id %d",e);const r=n.pop();this._registerAckCallback(e,r),t.id=e}const r=this.io.engine&&this.io.engine.transport&&this.io.engine.transport.writable;return!this.flags.volatile||r&&this.connected?this.connected?(this.notifyOutgoingListeners(t),this.packet(t)):this.sendBuffer.push(t):a("discard packet as the transport is not currently writable"),this.flags={},this}_registerAckCallback(e,n){var t;const r=null!==(t=this.flags.timeout)&&void 0!==t?t:this._opts.ackTimeout;if(void 0===r)return void(this.acks[e]=n);const o=this.io.setTimeoutFn((()=>{delete this.acks[e];for(let n=0;n<this.sendBuffer.length;n++)this.sendBuffer[n].id===e&&(a("removing packet with ack id %d from the buffer",e),this.sendBuffer.splice(n,1));a("event with ack id %d has timed out after %d ms",e,r),n.call(this,new Error("operation has timed out"))}),r);this.acks[e]=(...e)=>{this.io.clearTimeoutFn(o),n.apply(this,[null,...e])}}emitWithAck(e,...n){const t=void 0!==this.flags.timeout||void 0!==this._opts.ackTimeout;return new Promise(((r,o)=>{n.push(((e,n)=>t?e?o(e):r(n):r(e))),this.emit(e,...n)}))}_addToQueue(e){let n;"function"==typeof e[e.length-1]&&(n=e.pop());const t={id:this._queueSeq++,tryCount:0,pending:!1,args:e,flags:Object.assign({fromQueue:!0},this.flags)};e.push(((e,...r)=>{if(t===this._queue[0])return null!==e?t.tryCount>this._opts.retries&&(a("packet [%d] is discarded after %d tries",t.id,t.tryCount),this._queue.shift(),n&&n(e)):(a("packet [%d] was successfully sent",t.id),this._queue.shift(),n&&n(null,...r)),t.pending=!1,this._drainQueue()})),this._queue.push(t),this._drainQueue()}_drainQueue(e=!1){if(a("draining queue"),!this.connected||0===this._queue.length)return;const n=this._queue[0];!n.pending||e?(n.pending=!0,n.tryCount++,a("sending packet [%d] (try n%d)",n.id,n.tryCount),this.flags=n.flags,this.emit.apply(this,n.args)):a("packet [%d] has already been sent and is waiting for an ack",n.id)}packet(e){e.nsp=this.nsp,this.io._packet(e)}onopen(){a("transport is open - connecting"),"function"==typeof this.auth?this.auth((e=>{this._sendConnectPacket(e)})):this._sendConnectPacket(this.auth)}_sendConnectPacket(e){this.packet({type:o.PacketType.CONNECT,data:this._pid?Object.assign({pid:this._pid,offset:this._lastOffset},e):e})}onerror(e){this.connected||this.emitReserved("connect_error",e)}onclose(e,n){a("close (%s)",e),this.connected=!1,delete this.id,this.emitReserved("disconnect",e,n)}onpacket(e){if(e.nsp===this.nsp)switch(e.type){case o.PacketType.CONNECT:e.data&&e.data.sid?this.onconnect(e.data.sid,e.data.pid):this.emitReserved("connect_error",new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));break;case o.PacketType.EVENT:case o.PacketType.BINARY_EVENT:this.onevent(e);break;case o.PacketType.ACK:case o.PacketType.BINARY_ACK:this.onack(e);break;case o.PacketType.DISCONNECT:this.ondisconnect();break;case o.PacketType.CONNECT_ERROR:this.destroy();const n=new Error(e.data.message);n.data=e.data.data,this.emitReserved("connect_error",n)}}onevent(e){const n=e.data||[];a("emitting event %j",n),null!=e.id&&(a("attaching ack callback to event"),n.push(this.ack(e.id))),this.connected?this.emitEvent(n):this.receiveBuffer.push(Object.freeze(n))}emitEvent(e){if(this._anyListeners&&this._anyListeners.length){const n=this._anyListeners.slice();for(const t of n)t.apply(this,e)}super.emit.apply(this,e),this._pid&&e.length&&"string"==typeof e[e.length-1]&&(this._lastOffset=e[e.length-1])}ack(e){const n=this;let t=!1;return function(...r){t||(t=!0,a("sending ack %j",r),n.packet({type:o.PacketType.ACK,id:e,data:r}))}}onack(e){const n=this.acks[e.id];"function"==typeof n?(a("calling ack %s with %j",e.id,e.data),n.apply(this,e.data),delete this.acks[e.id]):a("bad ack %s",e.id)}onconnect(e,n){a("socket connected with id %s",e),this.id=e,this.recovered=n&&this._pid===n,this._pid=n,this.connected=!0,this.emitBuffered(),this.emitReserved("connect"),this._drainQueue(!0)}emitBuffered(){this.receiveBuffer.forEach((e=>this.emitEvent(e))),this.receiveBuffer=[],this.sendBuffer.forEach((e=>{this.notifyOutgoingListeners(e),this.packet(e)})),this.sendBuffer=[]}ondisconnect(){a("server disconnect (%s)",this.nsp),this.destroy(),this.onclose("io server disconnect")}destroy(){this.subs&&(this.subs.forEach((e=>e())),this.subs=void 0),this.io._destroy(this)}disconnect(){return this.connected&&(a("performing disconnect (%s)",this.nsp),this.packet({type:o.PacketType.DISCONNECT})),this.destroy(),this.connected&&this.onclose("io client disconnect"),this}close(){return this.disconnect()}compress(e){return this.flags.compress=e,this}get volatile(){return this.flags.volatile=!0,this}timeout(e){return this.flags.timeout=e,this}onAny(e){return this._anyListeners=this._anyListeners||[],this._anyListeners.push(e),this}prependAny(e){return this._anyListeners=this._anyListeners||[],this._anyListeners.unshift(e),this}offAny(e){if(!this._anyListeners)return this;if(e){const n=this._anyListeners;for(let t=0;t<n.length;t++)if(e===n[t])return n.splice(t,1),this}else this._anyListeners=[];return this}listenersAny(){return this._anyListeners||[]}onAnyOutgoing(e){return this._anyOutgoingListeners=this._anyOutgoingListeners||[],this._anyOutgoingListeners.push(e),this}prependAnyOutgoing(e){return this._anyOutgoingListeners=this._anyOutgoingListeners||[],this._anyOutgoingListeners.unshift(e),this}offAnyOutgoing(e){if(!this._anyOutgoingListeners)return this;if(e){const n=this._anyOutgoingListeners;for(let t=0;t<n.length;t++)if(e===n[t])return n.splice(t,1),this}else this._anyOutgoingListeners=[];return this}listenersAnyOutgoing(){return this._anyOutgoingListeners||[]}notifyOutgoingListeners(e){if(this._anyOutgoingListeners&&this._anyOutgoingListeners.length){const n=this._anyOutgoingListeners.slice();for(const t of n)t.apply(this,e.data)}}}n.Socket=l},5702:function(e,n,t){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0}),n.url=void 0;const o=t(61473),i=r(t(25130)).default("socket.io-client:url");n.url=function(e,n="",t){let r=e;t=t||"undefined"!=typeof location&&location,null==e&&(e=t.protocol+"//"+t.host),"string"==typeof e&&("/"===e.charAt(0)&&(e="/"===e.charAt(1)?t.protocol+e:t.host+e),/^(https?|wss?):\/\//.test(e)||(i("protocol-less url %s",e),e=void 0!==t?t.protocol+"//"+e:"https://"+e),i("parse %s",e),r=o.parse(e)),r.port||(/^(http|ws)$/.test(r.protocol)?r.port="80":/^(http|ws)s$/.test(r.protocol)&&(r.port="443")),r.path=r.path||"/";const s=-1!==r.host.indexOf(":")?"["+r.host+"]":r.host;return r.id=r.protocol+"://"+s+":"+r.port+n,r.href=r.protocol+"://"+s+(t&&t.port===r.port?"":":"+r.port),r}},33406:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.reconstructPacket=n.deconstructPacket=void 0;const r=t(35648);function o(e,n){if(!e)return e;if((0,r.isBinary)(e)){const t={_placeholder:!0,num:n.length};return n.push(e),t}if(Array.isArray(e)){const t=new Array(e.length);for(let r=0;r<e.length;r++)t[r]=o(e[r],n);return t}if("object"==typeof e&&!(e instanceof Date)){const t={};for(const r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=o(e[r],n));return t}return e}function i(e,n){if(!e)return e;if(e&&!0===e._placeholder){if("number"==typeof e.num&&e.num>=0&&e.num<n.length)return n[e.num];throw new Error("illegal attachments")}if(Array.isArray(e))for(let t=0;t<e.length;t++)e[t]=i(e[t],n);else if("object"==typeof e)for(const t in e)Object.prototype.hasOwnProperty.call(e,t)&&(e[t]=i(e[t],n));return e}n.deconstructPacket=function(e){const n=[],t=e.data,r=e;return r.data=o(t,n),r.attachments=n.length,{packet:r,buffers:n}},n.reconstructPacket=function(e,n){return e.data=i(e.data,n),delete e.attachments,e}},56642:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.Decoder=n.Encoder=n.PacketType=n.protocol=void 0;const r=t(97416),o=t(33406),i=t(35648),s=(0,t(25130).default)("socket.io-parser");var a;n.protocol=5,function(e){e[e.CONNECT=0]="CONNECT",e[e.DISCONNECT=1]="DISCONNECT",e[e.EVENT=2]="EVENT",e[e.ACK=3]="ACK",e[e.CONNECT_ERROR=4]="CONNECT_ERROR",e[e.BINARY_EVENT=5]="BINARY_EVENT",e[e.BINARY_ACK=6]="BINARY_ACK"}(a=n.PacketType||(n.PacketType={})),n.Encoder=class{constructor(e){this.replacer=e}encode(e){return s("encoding packet %j",e),e.type!==a.EVENT&&e.type!==a.ACK||!(0,i.hasBinary)(e)?[this.encodeAsString(e)]:this.encodeAsBinary({type:e.type===a.EVENT?a.BINARY_EVENT:a.BINARY_ACK,nsp:e.nsp,data:e.data,id:e.id})}encodeAsString(e){let n=""+e.type;return e.type!==a.BINARY_EVENT&&e.type!==a.BINARY_ACK||(n+=e.attachments+"-"),e.nsp&&"/"!==e.nsp&&(n+=e.nsp+","),null!=e.id&&(n+=e.id),null!=e.data&&(n+=JSON.stringify(e.data,this.replacer)),s("encoded %j as %s",e,n),n}encodeAsBinary(e){const n=(0,o.deconstructPacket)(e),t=this.encodeAsString(n.packet),r=n.buffers;return r.unshift(t),r}};class c extends r.Emitter{constructor(e){super(),this.reviver=e}add(e){let n;if("string"==typeof e){if(this.reconstructor)throw new Error("got plaintext data when reconstructing a packet");n=this.decodeString(e);const t=n.type===a.BINARY_EVENT;t||n.type===a.BINARY_ACK?(n.type=t?a.EVENT:a.ACK,this.reconstructor=new l(n),0===n.attachments&&super.emitReserved("decoded",n)):super.emitReserved("decoded",n)}else{if(!(0,i.isBinary)(e)&&!e.base64)throw new Error("Unknown type: "+e);if(!this.reconstructor)throw new Error("got binary data when not reconstructing a packet");n=this.reconstructor.takeBinaryData(e),n&&(this.reconstructor=null,super.emitReserved("decoded",n))}}decodeString(e){let n=0;const t={type:Number(e.charAt(0))};if(void 0===a[t.type])throw new Error("unknown packet type "+t.type);if(t.type===a.BINARY_EVENT||t.type===a.BINARY_ACK){const r=n+1;for(;"-"!==e.charAt(++n)&&n!=e.length;);const o=e.substring(r,n);if(o!=Number(o)||"-"!==e.charAt(n))throw new Error("Illegal attachments");t.attachments=Number(o)}if("/"===e.charAt(n+1)){const r=n+1;for(;++n&&","!==e.charAt(n)&&n!==e.length;);t.nsp=e.substring(r,n)}else t.nsp="/";const r=e.charAt(n+1);if(""!==r&&Number(r)==r){const r=n+1;for(;++n;){const t=e.charAt(n);if(null==t||Number(t)!=t){--n;break}if(n===e.length)break}t.id=Number(e.substring(r,n+1))}if(e.charAt(++n)){const r=this.tryParse(e.substr(n));if(!c.isPayloadValid(t.type,r))throw new Error("invalid payload");t.data=r}return s("decoded %s as %j",e,t),t}tryParse(e){try{return JSON.parse(e,this.reviver)}catch(e){return!1}}static isPayloadValid(e,n){switch(e){case a.CONNECT:return"object"==typeof n;case a.DISCONNECT:return void 0===n;case a.CONNECT_ERROR:return"string"==typeof n||"object"==typeof n;case a.EVENT:case a.BINARY_EVENT:return Array.isArray(n)&&n.length>0;case a.ACK:case a.BINARY_ACK:return Array.isArray(n)}}destroy(){this.reconstructor&&(this.reconstructor.finishedReconstruction(),this.reconstructor=null)}}n.Decoder=c;class l{constructor(e){this.packet=e,this.buffers=[],this.reconPack=e}takeBinaryData(e){if(this.buffers.push(e),this.buffers.length===this.reconPack.attachments){const e=(0,o.reconstructPacket)(this.reconPack,this.buffers);return this.finishedReconstruction(),e}return null}finishedReconstruction(){this.reconPack=null,this.buffers=[]}}},35648:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.hasBinary=n.isBinary=void 0;const t="function"==typeof ArrayBuffer,r=e=>"function"==typeof ArrayBuffer.isView?ArrayBuffer.isView(e):e.buffer instanceof ArrayBuffer,o=Object.prototype.toString,i="function"==typeof Blob||"undefined"!=typeof Blob&&"[object BlobConstructor]"===o.call(Blob),s="function"==typeof File||"undefined"!=typeof File&&"[object FileConstructor]"===o.call(File);function a(e){return t&&(e instanceof ArrayBuffer||r(e))||i&&e instanceof Blob||s&&e instanceof File}n.isBinary=a,n.hasBinary=function e(n,t){if(!n||"object"!=typeof n)return!1;if(Array.isArray(n)){for(let t=0,r=n.length;t<r;t++)if(e(n[t]))return!0;return!1}if(a(n))return!0;if(n.toJSON&&"function"==typeof n.toJSON&&1===arguments.length)return e(n.toJSON(),!0);for(const t in n)if(Object.prototype.hasOwnProperty.call(n,t)&&e(n[t]))return!0;return!1}},97416:(e,n,t)=>{"use strict";function r(e){if(e)return function(e){for(var n in r.prototype)e[n]=r.prototype[n];return e}(e)}t.r(n),t.d(n,{Emitter:()=>r}),r.prototype.on=r.prototype.addEventListener=function(e,n){return this._callbacks=this._callbacks||{},(this._callbacks["$"+e]=this._callbacks["$"+e]||[]).push(n),this},r.prototype.once=function(e,n){function t(){this.off(e,t),n.apply(this,arguments)}return t.fn=n,this.on(e,t),this},r.prototype.off=r.prototype.removeListener=r.prototype.removeAllListeners=r.prototype.removeEventListener=function(e,n){if(this._callbacks=this._callbacks||{},0==arguments.length)return this._callbacks={},this;var t,r=this._callbacks["$"+e];if(!r)return this;if(1==arguments.length)return delete this._callbacks["$"+e],this;for(var o=0;o<r.length;o++)if((t=r[o])===n||t.fn===n){r.splice(o,1);break}return 0===r.length&&delete this._callbacks["$"+e],this},r.prototype.emit=function(e){this._callbacks=this._callbacks||{};for(var n=new Array(arguments.length-1),t=this._callbacks["$"+e],r=1;r<arguments.length;r++)n[r-1]=arguments[r];if(t){r=0;for(var o=(t=t.slice(0)).length;r<o;++r)t[r].apply(this,n)}return this},r.prototype.emitReserved=r.prototype.emit,r.prototype.listeners=function(e){return this._callbacks=this._callbacks||{},this._callbacks["$"+e]||[]},r.prototype.hasListeners=function(e){return!!this.listeners(e).length}}},__webpack_module_cache__={};function __webpack_require__(e){var n=__webpack_module_cache__[e];if(void 0!==n)return n.exports;var t=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e].call(t.exports,t,t.exports,__webpack_require__),t.exports}__webpack_require__.n=e=>{var n=e&&e.__esModule?()=>e.default:()=>e;return __webpack_require__.d(n,{a:n}),n},__webpack_require__.d=(e,n)=>{for(var t in n)__webpack_require__.o(n,t)&&!__webpack_require__.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:n[t]})},__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),__webpack_require__.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},function(e){var n="-",t="--",r="---";function o(e,o,i){return!1===i||null==i||i!=i?"":!0===i?function(e,n){return e+t+n}(e,o):function(e,t,o){return e+r+t+n+o.length+n+o.replace(/\s/gm,"_")}(e,o,i.toString())}(e=e||{}).sts=function(e){for(var n=[],t=1;t<arguments.length;t++){var r=arguments[t];if(r)if("string"==typeof r)n[n.length]=r;else if(2===t)for(var i in r){var s=o(e,i,r[i]);s&&(n[n.length]=s)}}return n.join(" ")},e.stc=function(e,n){var t=[];for(var r in n){var i=o(e,r,n[r]);i&&t.push(i)}return t.join(" ")}}(__webpack_require__),__webpack_require__.p="";var __webpack_exports__={};(()=>{"use strict";var e=__webpack_require__(93849);self.EngineCore||(self.EngineCore=e);const{getTopWindow:n,FeatureLoadersRegistry:t,runEngineApp:r}=e,o=new Map(Object.entries({"stylable-playground":{load:async()=>(await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,64578))).default,async preload(){},depFeatures:["code-editor","code-execution","compilation","code-languages","file-assets","firebase-persistency","firebase-fs-persistency","firebase-auth-ui","gui","project","project-ui","simulation-preview","stylable/stylable-compiler","stylable","stylable/stylable-language-service","typescript-compiler"],resolvedContexts:{processing:"worker",main:"window"}},"engine-core/communication":{load:async()=>(await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,18430))).default,async preload(){},depFeatures:[],resolvedContexts:{}},"engine-core/runtime-metadata":{load:async()=>(await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,68104))).default,async preload(){},depFeatures:[],resolvedContexts:{}},"code-editor":{load:async()=>(await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,12763))).default,async preload(){},depFeatures:["gui","project","project-ui","analytics"],resolvedContexts:{main:"window",processing:"worker"}},"code-execution":{load:async()=>(await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,57499)),(await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,43450))).default),async preload(){},depFeatures:["project","compilation","engine-core/communication","gui","actions","engine-resources/resource","global-events"],resolvedContexts:{main:"window",processing:"worker"}},"code-languages":{load:async()=>(await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,23870))).default,async preload(){},depFeatures:["gui","project-ui","code-editor"],resolvedContexts:{processing:"worker",main:"window"}},gui:{load:async()=>(await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,13757))).default,async preload(){},depFeatures:["engine-core/communication","react-renderer","storage","actions","analytics","react-resources","global-events"],resolvedContexts:{main:"window"}},"file-assets":{load:async()=>(await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,59178))).default,async preload(){},depFeatures:["project","engine-resources/resource"],resolvedContexts:{main:"window",processing:"worker"}},project:{load:async()=>(await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,31434))).default,async preload(){},depFeatures:["engine-core/communication","gui","engine-resources/resource","analytics"],resolvedContexts:{main:"window",processing:"worker"}},"project-ui":{load:async()=>(await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,43345))).default,async preload(){},depFeatures:["project","gui","storage","actions","analytics","notifications"],resolvedContexts:{main:"window",processing:"worker"}},compilation:{load:async()=>(await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,80134))).default,async preload(){},depFeatures:["gui","project","engine-resources/resource","user-application-server"],resolvedContexts:{main:"window",processing:"worker"}},"stylable/stylable-compiler":{load:async()=>(await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,84081))).default,async preload(){},depFeatures:["stylable","compilation","code-execution"],resolvedContexts:{main:"window",processing:"worker"}},"stylable/stylable-language-service":{load:async()=>(await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,13427))).default,async preload(){},depFeatures:["project","code-languages","stylable"],resolvedContexts:{main:"window",processing:"worker"}},stylable:{load:async()=>(await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,70286))).default,async preload(){},depFeatures:["code-execution","project","project-ui"],resolvedContexts:{main:"window",processing:"worker"}},"typescript-compiler":{load:async()=>(await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,38055)),(await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,59237))).default),async preload(){},depFeatures:["engine-core/communication","project","compilation","code-execution","typescript","user-application-server"],resolvedContexts:{main:"window",processing:"worker"}},"simulation-preview":{load:async()=>(await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,23926)),(await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,59320))).default),async preload(){},depFeatures:["code-execution","engine-core/communication","gui","project","compilation","engine-resources/resource","simulation-capabilities","actions","environment-info","global-events","wcs-server"],resolvedContexts:{processing:"worker",main:"window"}},"firebase-persistency":{load:async()=>(await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,94703))).default,async preload(){},depFeatures:["gui"],resolvedContexts:{main:"window"}},"firebase-fs-persistency":{load:async()=>(await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,74853))).default,async preload(){},depFeatures:["project","firebase-persistency","gui","notifications"],resolvedContexts:{main:"window",processing:"worker"}},"firebase-auth-ui":{load:async()=>(await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,98617))).default,async preload(){},depFeatures:["firebase-persistency","gui"],resolvedContexts:{main:"window"}},"engine-resources/resource":{load:async()=>(await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,15863))).default,async preload(){},depFeatures:["engine-core/communication"],resolvedContexts:{}},"react-renderer":{load:async()=>(await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,35855))).default,async preload(){},depFeatures:[],resolvedContexts:{main:"window"}},analytics:{load:async()=>(await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,33248))).default,async preload(){},depFeatures:[],resolvedContexts:{}},actions:{load:async()=>(await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,64049))).default,async preload(){},depFeatures:["global-events","engine-resources/resource"],resolvedContexts:{}},"global-events":{load:async()=>(await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,89580))).default,async preload(){},depFeatures:[],resolvedContexts:{}},"react-resources":{load:async()=>(await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,36041))).default,async preload(){},depFeatures:[],resolvedContexts:{}},storage:{load:async()=>(await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,44069))).default,async preload(){},depFeatures:[],resolvedContexts:{}},notifications:{load:async()=>(await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,88867))).default,async preload(){},depFeatures:["gui"],resolvedContexts:{main:"window"}},"user-application-server":{load:async()=>(await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,89102))).default,async preload(){},depFeatures:["wcs-server"],resolvedContexts:{main:"window",processing:"worker"}},typescript:{load:async()=>(await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,17166))).default,async preload(){},depFeatures:["project","code-languages","compilation","code-execution","file-assets","environment-info"],resolvedContexts:{main:"window",processing:"worker"}},"simulation-capabilities":{load:async()=>(await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,16894))).default,async preload(){},depFeatures:["code-execution","project","git-revisions","file-components","simple-ast","typescript","typescript-compiler","file-assets"],resolvedContexts:{main:"window",processing:"worker"}},"environment-info":{load:async()=>(await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,846))).default,async preload(){},depFeatures:["project","gui","actions","analytics"],resolvedContexts:{main:"window",processing:"worker"}},"wcs-server":{load:async()=>(await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,82745))).default,async preload(){},depFeatures:["engine-core/communication","engine-core/runtime-metadata","project"],resolvedContexts:{main:"window",processing:"worker"}},"simple-ast":{load:async()=>(await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,17831))).default,async preload(){},depFeatures:["project","typescript","engine-core/communication"],resolvedContexts:{main:"window",processing:"worker"}},"file-components":{load:async()=>(await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,22856))).default,async preload(){},depFeatures:["code-execution","project","simple-ast","demo-discovery","job-manager","gui","typescript-assets","typescript","file-assets","analytics","notifications"],resolvedContexts:{main:"window",processing:"worker"}},"git-revisions":{load:async()=>(await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,48337))).default,async preload(){},depFeatures:["project","git-commands","file-assets"],resolvedContexts:{main:"window",processing:"worker"}},"demo-discovery":{load:async()=>(await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,95944))).default,async preload(){},depFeatures:["discovery","project","file-assets"],resolvedContexts:{main:"window",processing:"worker"}},"job-manager":{load:async()=>(await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,12803))).default,async preload(){},depFeatures:["engine-core/communication"],resolvedContexts:{}},"typescript-assets":{load:async()=>(await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,30600))).default,async preload(){},depFeatures:["typescript","project","engine-resources/resource","file-assets","code-execution","typescript-compiler"],resolvedContexts:{main:"window",processing:"worker"}},"git-commands":{load:async()=>(await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,68941))).default,async preload(){},depFeatures:["project"],resolvedContexts:{main:"window",processing:"live-server"}},discovery:{load:async()=>(await Promise.resolve().then(__webpack_require__.bind(__webpack_require__,56830))).default,async preload(){},depFeatures:["project","file-assets"],resolvedContexts:{main:"window",processing:"worker"}}}));self._engine_={};const i={"stylable-playground/example":async()=>await Promise.all([Promise.resolve().then(__webpack_require__.bind(__webpack_require__,17340))])};(async function(){const n="undefined"!=typeof self?self:window,s=(n.parent,new URLSearchParams(n.location.search));let a="";s.has("publicPath")&&(a=s.get("publicPath")),__webpack_require__.p=a;const c=s.get("feature")||"stylable-playground",l=s.get("config")||"stylable-playground/example",d=[],u=s.get(e.INSTANCE_ID_PARAM_NAME);if(u&&(n.name=u),l){const e=i[l]?(await i[l]()).map((e=>e.default)):Promise.resolve([]),n=await Promise.all(e);d.push(...n.flat())}const p=o.get(c);if(!p)throw new Error("cannot find feature '"+c+"'. available features:\n"+Array.from(o.keys()).join("\n"));const{resolvedContexts:h={}}=p,f=new t(o,h),m=await f.getLoadedFeatures(c),g=[m[m.length-1]];return r({config:d,options:s,env:{env:"preview",envType:"iframe",endpointType:"multi",dependencies:[{env:"window-renderer",envType:"iframe",endpointType:"multi",dependencies:[]}]},publicPath:a,features:g,resolvedContexts:h})})().catch(console.error)})()})();